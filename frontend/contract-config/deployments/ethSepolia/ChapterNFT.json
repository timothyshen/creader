{
  "address": "0x624FC3272B419aeEfcC77C217b197b6da75fe6aC",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "contract IPAssetRegistry",
          "name": "_registry",
          "type": "address"
        },
        {
          "internalType": "contract IBodhi",
          "name": "_bodhi",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "owner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "spender",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "id",
          "type": "uint256"
        }
      ],
      "name": "Approval",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "owner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "operator",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "bool",
          "name": "approved",
          "type": "bool"
        }
      ],
      "name": "ApprovalForAll",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "from",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "id",
          "type": "uint256"
        }
      ],
      "name": "Transfer",
      "type": "event"
    },
    {
      "inputs": [],
      "name": "BODHI",
      "outputs": [
        {
          "internalType": "contract IBodhi",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "REGISTRY",
      "outputs": [
        {
          "internalType": "contract IPAssetRegistry",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "spender",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "id",
          "type": "uint256"
        }
      ],
      "name": "approve",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "owner",
          "type": "address"
        }
      ],
      "name": "balanceOf",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "chapters",
      "outputs": [
        {
          "internalType": "string",
          "name": "title",
          "type": "string"
        },
        {
          "internalType": "address",
          "name": "owner",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "string",
          "name": "_title",
          "type": "string"
        },
        {
          "internalType": "string",
          "name": "arTxId",
          "type": "string"
        }
      ],
      "name": "createChapter",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "getApproved",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "name": "isApprovedForAll",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "name",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "id",
          "type": "uint256"
        }
      ],
      "name": "ownerOf",
      "outputs": [
        {
          "internalType": "address",
          "name": "owner",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "from",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "id",
          "type": "uint256"
        }
      ],
      "name": "safeTransferFrom",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "from",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "id",
          "type": "uint256"
        },
        {
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        }
      ],
      "name": "safeTransferFrom",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "operator",
          "type": "address"
        },
        {
          "internalType": "bool",
          "name": "approved",
          "type": "bool"
        }
      ],
      "name": "setApprovalForAll",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes4",
          "name": "interfaceId",
          "type": "bytes4"
        }
      ],
      "name": "supportsInterface",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "symbol",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "id",
          "type": "uint256"
        }
      ],
      "name": "tokenURI",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "from",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "id",
          "type": "uint256"
        }
      ],
      "name": "transferFrom",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_tokenId",
          "type": "uint256"
        },
        {
          "internalType": "string",
          "name": "_title",
          "type": "string"
        }
      ],
      "name": "updateChapter",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0x97d3347191fe21accf75b6d7436766b57fd6f88bc53e53f2a26842f471734010",
  "receipt": {
    "to": null,
    "from": "0xcC2042a7c7997a04e26389B9689f2AE766342732",
    "contractAddress": "0x624FC3272B419aeEfcC77C217b197b6da75fe6aC",
    "transactionIndex": 44,
    "gasUsed": "1219577",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x806ec8939f444877b015b268c61d493f3da047157623c0460f0177ab9e8ae7dd",
    "transactionHash": "0x97d3347191fe21accf75b6d7436766b57fd6f88bc53e53f2a26842f471734010",
    "logs": [],
    "blockNumber": 6546249,
    "cumulativeGasUsed": "5758532",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0xd43fE0d865cb5C26b1351d3eAf2E3064BE3276F6",
    "0xC37615d658c293D629b329F3C963604E95b08bA0"
  ],
  "numDeployments": 1,
  "solcInputHash": "4a1eb2c88ced66b722c6afc5046faaab",
  "metadata": "{\"compiler\":{\"version\":\"0.8.23+commit.f704f362\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"contract IPAssetRegistry\",\"name\":\"_registry\",\"type\":\"address\"},{\"internalType\":\"contract IBodhi\",\"name\":\"_bodhi\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BODHI\",\"outputs\":[{\"internalType\":\"contract IBodhi\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"REGISTRY\",\"outputs\":[{\"internalType\":\"contract IPAssetRegistry\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"chapters\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"title\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_title\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"arTxId\",\"type\":\"string\"}],\"name\":\"createChapter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_title\",\"type\":\"string\"}],\"name\":\"updateChapter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/creader-io/ChapterNFT.sol\":\"ChapterNFT\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts-upgradeable/access/manager/AccessManagedUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (access/manager/AccessManaged.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IAuthority} from \\\"@openzeppelin/contracts/access/manager/IAuthority.sol\\\";\\nimport {AuthorityUtils} from \\\"@openzeppelin/contracts/access/manager/AuthorityUtils.sol\\\";\\nimport {IAccessManager} from \\\"@openzeppelin/contracts/access/manager/IAccessManager.sol\\\";\\nimport {IAccessManaged} from \\\"@openzeppelin/contracts/access/manager/IAccessManaged.sol\\\";\\nimport {ContextUpgradeable} from \\\"../../utils/ContextUpgradeable.sol\\\";\\nimport {Initializable} from \\\"../../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev This contract module makes available a {restricted} modifier. Functions decorated with this modifier will be\\n * permissioned according to an \\\"authority\\\": a contract like {AccessManager} that follows the {IAuthority} interface,\\n * implementing a policy that allows certain callers to access certain functions.\\n *\\n * IMPORTANT: The `restricted` modifier should never be used on `internal` functions, judiciously used in `public`\\n * functions, and ideally only used in `external` functions. See {restricted}.\\n */\\nabstract contract AccessManagedUpgradeable is Initializable, ContextUpgradeable, IAccessManaged {\\n    /// @custom:storage-location erc7201:openzeppelin.storage.AccessManaged\\n    struct AccessManagedStorage {\\n        address _authority;\\n\\n        bool _consumingSchedule;\\n    }\\n\\n    // keccak256(abi.encode(uint256(keccak256(\\\"openzeppelin.storage.AccessManaged\\\")) - 1)) & ~bytes32(uint256(0xff))\\n    bytes32 private constant AccessManagedStorageLocation = 0xf3177357ab46d8af007ab3fdb9af81da189e1068fefdc0073dca88a2cab40a00;\\n\\n    function _getAccessManagedStorage() private pure returns (AccessManagedStorage storage $) {\\n        assembly {\\n            $.slot := AccessManagedStorageLocation\\n        }\\n    }\\n\\n    /**\\n     * @dev Initializes the contract connected to an initial authority.\\n     */\\n    function __AccessManaged_init(address initialAuthority) internal onlyInitializing {\\n        __AccessManaged_init_unchained(initialAuthority);\\n    }\\n\\n    function __AccessManaged_init_unchained(address initialAuthority) internal onlyInitializing {\\n        _setAuthority(initialAuthority);\\n    }\\n\\n    /**\\n     * @dev Restricts access to a function as defined by the connected Authority for this contract and the\\n     * caller and selector of the function that entered the contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * In general, this modifier should only be used on `external` functions. It is okay to use it on `public`\\n     * functions that are used as external entry points and are not called internally. Unless you know what you're\\n     * doing, it should never be used on `internal` functions. Failure to follow these rules can have critical security\\n     * implications! This is because the permissions are determined by the function that entered the contract, i.e. the\\n     * function at the bottom of the call stack, and not the function where the modifier is visible in the source code.\\n     * ====\\n     *\\n     * [WARNING]\\n     * ====\\n     * Avoid adding this modifier to the https://docs.soliditylang.org/en/v0.8.20/contracts.html#receive-ether-function[`receive()`]\\n     * function or the https://docs.soliditylang.org/en/v0.8.20/contracts.html#fallback-function[`fallback()`]. These\\n     * functions are the only execution paths where a function selector cannot be unambiguosly determined from the calldata\\n     * since the selector defaults to `0x00000000` in the `receive()` function and similarly in the `fallback()` function\\n     * if no calldata is provided. (See {_checkCanCall}).\\n     *\\n     * The `receive()` function will always panic whereas the `fallback()` may panic depending on the calldata length.\\n     * ====\\n     */\\n    modifier restricted() {\\n        _checkCanCall(_msgSender(), _msgData());\\n        _;\\n    }\\n\\n    /// @inheritdoc IAccessManaged\\n    function authority() public view virtual returns (address) {\\n        AccessManagedStorage storage $ = _getAccessManagedStorage();\\n        return $._authority;\\n    }\\n\\n    /// @inheritdoc IAccessManaged\\n    function setAuthority(address newAuthority) public virtual {\\n        address caller = _msgSender();\\n        if (caller != authority()) {\\n            revert AccessManagedUnauthorized(caller);\\n        }\\n        if (newAuthority.code.length == 0) {\\n            revert AccessManagedInvalidAuthority(newAuthority);\\n        }\\n        _setAuthority(newAuthority);\\n    }\\n\\n    /// @inheritdoc IAccessManaged\\n    function isConsumingScheduledOp() public view returns (bytes4) {\\n        AccessManagedStorage storage $ = _getAccessManagedStorage();\\n        return $._consumingSchedule ? this.isConsumingScheduledOp.selector : bytes4(0);\\n    }\\n\\n    /**\\n     * @dev Transfers control to a new authority. Internal function with no access restriction. Allows bypassing the\\n     * permissions set by the current authority.\\n     */\\n    function _setAuthority(address newAuthority) internal virtual {\\n        AccessManagedStorage storage $ = _getAccessManagedStorage();\\n        $._authority = newAuthority;\\n        emit AuthorityUpdated(newAuthority);\\n    }\\n\\n    /**\\n     * @dev Reverts if the caller is not allowed to call the function identified by a selector. Panics if the calldata\\n     * is less than 4 bytes long.\\n     */\\n    function _checkCanCall(address caller, bytes calldata data) internal virtual {\\n        AccessManagedStorage storage $ = _getAccessManagedStorage();\\n        (bool immediate, uint32 delay) = AuthorityUtils.canCallWithDelay(\\n            authority(),\\n            caller,\\n            address(this),\\n            bytes4(data[0:4])\\n        );\\n        if (!immediate) {\\n            if (delay > 0) {\\n                $._consumingSchedule = true;\\n                IAccessManager(authority()).consumeScheduledOp(caller, data);\\n                $._consumingSchedule = false;\\n            } else {\\n                revert AccessManagedUnauthorized(caller);\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xd7e800ed57cb2dc4ce3d38fc310cf6c4918c0a67f9071ef8fb3e0cff24be6446\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\\n * reused. This mechanism prevents re-execution of each \\\"step\\\" but allows the creation of new initialization steps in\\n * case an upgrade adds a module that needs to be initialized.\\n *\\n * For example:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```solidity\\n * contract MyToken is ERC20Upgradeable {\\n *     function initialize() initializer public {\\n *         __ERC20_init(\\\"MyToken\\\", \\\"MTK\\\");\\n *     }\\n * }\\n *\\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\\n *     function initializeV2() reinitializer(2) public {\\n *         __ERC20Permit_init(\\\"MyToken\\\");\\n *     }\\n * }\\n * ```\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() {\\n *     _disableInitializers();\\n * }\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Storage of the initializable contract.\\n     *\\n     * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\\n     * when using with upgradeable contracts.\\n     *\\n     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\\n     */\\n    struct InitializableStorage {\\n        /**\\n         * @dev Indicates that the contract has been initialized.\\n         */\\n        uint64 _initialized;\\n        /**\\n         * @dev Indicates that the contract is in the process of being initialized.\\n         */\\n        bool _initializing;\\n    }\\n\\n    // keccak256(abi.encode(uint256(keccak256(\\\"openzeppelin.storage.Initializable\\\")) - 1)) & ~bytes32(uint256(0xff))\\n    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\\n\\n    /**\\n     * @dev The contract is already initialized.\\n     */\\n    error InvalidInitialization();\\n\\n    /**\\n     * @dev The contract is not initializing.\\n     */\\n    error NotInitializing();\\n\\n    /**\\n     * @dev Triggered when the contract has been initialized or reinitialized.\\n     */\\n    event Initialized(uint64 version);\\n\\n    /**\\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\\n     * `onlyInitializing` functions can be used to initialize parent contracts.\\n     *\\n     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\\n     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\\n     * production.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier initializer() {\\n        // solhint-disable-next-line var-name-mixedcase\\n        InitializableStorage storage $ = _getInitializableStorage();\\n\\n        // Cache values to avoid duplicated sloads\\n        bool isTopLevelCall = !$._initializing;\\n        uint64 initialized = $._initialized;\\n\\n        // Allowed calls:\\n        // - initialSetup: the contract is not in the initializing state and no previous version was\\n        //                 initialized\\n        // - construction: the contract is initialized at version 1 (no reininitialization) and the\\n        //                 current contract is just being deployed\\n        bool initialSetup = initialized == 0 && isTopLevelCall;\\n        bool construction = initialized == 1 && address(this).code.length == 0;\\n\\n        if (!initialSetup && !construction) {\\n            revert InvalidInitialization();\\n        }\\n        $._initialized = 1;\\n        if (isTopLevelCall) {\\n            $._initializing = true;\\n        }\\n        _;\\n        if (isTopLevelCall) {\\n            $._initializing = false;\\n            emit Initialized(1);\\n        }\\n    }\\n\\n    /**\\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\\n     * used to initialize parent contracts.\\n     *\\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\\n     * are added through upgrades and that require initialization.\\n     *\\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\\n     *\\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\\n     * a contract, executing them in the right order is up to the developer or operator.\\n     *\\n     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier reinitializer(uint64 version) {\\n        // solhint-disable-next-line var-name-mixedcase\\n        InitializableStorage storage $ = _getInitializableStorage();\\n\\n        if ($._initializing || $._initialized >= version) {\\n            revert InvalidInitialization();\\n        }\\n        $._initialized = version;\\n        $._initializing = true;\\n        _;\\n        $._initializing = false;\\n        emit Initialized(version);\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\\n     */\\n    modifier onlyInitializing() {\\n        _checkInitializing();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\\n     */\\n    function _checkInitializing() internal view virtual {\\n        if (!_isInitializing()) {\\n            revert NotInitializing();\\n        }\\n    }\\n\\n    /**\\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\\n     * through proxies.\\n     *\\n     * Emits an {Initialized} event the first time it is successfully executed.\\n     */\\n    function _disableInitializers() internal virtual {\\n        // solhint-disable-next-line var-name-mixedcase\\n        InitializableStorage storage $ = _getInitializableStorage();\\n\\n        if ($._initializing) {\\n            revert InvalidInitialization();\\n        }\\n        if ($._initialized != type(uint64).max) {\\n            $._initialized = type(uint64).max;\\n            emit Initialized(type(uint64).max);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\\n     */\\n    function _getInitializedVersion() internal view returns (uint64) {\\n        return _getInitializableStorage()._initialized;\\n    }\\n\\n    /**\\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\\n     */\\n    function _isInitializing() internal view returns (bool) {\\n        return _getInitializableStorage()._initializing;\\n    }\\n\\n    /**\\n     * @dev Returns a pointer to the storage namespace.\\n     */\\n    // solhint-disable-next-line var-name-mixedcase\\n    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\\n        assembly {\\n            $.slot := INITIALIZABLE_STORAGE\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x631188737069917d2f909d29ce62c4d48611d326686ba6683e26b72a23bfac0b\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/utils/UUPSUpgradeable.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC1822Proxiable} from \\\"@openzeppelin/contracts/interfaces/draft-IERC1822.sol\\\";\\nimport {ERC1967Utils} from \\\"@openzeppelin/contracts/proxy/ERC1967/ERC1967Utils.sol\\\";\\nimport {Initializable} from \\\"./Initializable.sol\\\";\\n\\n/**\\n * @dev An upgradeability mechanism designed for UUPS proxies. The functions included here can perform an upgrade of an\\n * {ERC1967Proxy}, when this contract is set as the implementation behind such a proxy.\\n *\\n * A security mechanism ensures that an upgrade does not turn off upgradeability accidentally, although this risk is\\n * reinstated if the upgrade retains upgradeability but removes the security mechanism, e.g. by replacing\\n * `UUPSUpgradeable` with a custom implementation of upgrades.\\n *\\n * The {_authorizeUpgrade} function must be overridden to include access restriction to the upgrade mechanism.\\n */\\nabstract contract UUPSUpgradeable is Initializable, IERC1822Proxiable {\\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\\n    address private immutable __self = address(this);\\n\\n    /**\\n     * @dev The version of the upgrade interface of the contract. If this getter is missing, both `upgradeTo(address)`\\n     * and `upgradeToAndCall(address,bytes)` are present, and `upgradeTo` must be used if no function should be called,\\n     * while `upgradeToAndCall` will invoke the `receive` function if the second argument is the empty byte string.\\n     * If the getter returns `\\\"5.0.0\\\"`, only `upgradeToAndCall(address,bytes)` is present, and the second argument must\\n     * be the empty byte string if no function should be called, making it impossible to invoke the `receive` function\\n     * during an upgrade.\\n     */\\n    string public constant UPGRADE_INTERFACE_VERSION = \\\"5.0.0\\\";\\n\\n    /**\\n     * @dev The call is from an unauthorized context.\\n     */\\n    error UUPSUnauthorizedCallContext();\\n\\n    /**\\n     * @dev The storage `slot` is unsupported as a UUID.\\n     */\\n    error UUPSUnsupportedProxiableUUID(bytes32 slot);\\n\\n    /**\\n     * @dev Check that the execution is being performed through a delegatecall call and that the execution context is\\n     * a proxy contract with an implementation (as defined in ERC1967) pointing to self. This should only be the case\\n     * for UUPS and transparent proxies that are using the current contract as their implementation. Execution of a\\n     * function through ERC1167 minimal proxies (clones) would not normally pass this test, but is not guaranteed to\\n     * fail.\\n     */\\n    modifier onlyProxy() {\\n        _checkProxy();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Check that the execution is not being performed through a delegate call. This allows a function to be\\n     * callable on the implementing contract but not through proxies.\\n     */\\n    modifier notDelegated() {\\n        _checkNotDelegated();\\n        _;\\n    }\\n\\n    function __UUPSUpgradeable_init() internal onlyInitializing {\\n    }\\n\\n    function __UUPSUpgradeable_init_unchained() internal onlyInitializing {\\n    }\\n    /**\\n     * @dev Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the\\n     * implementation. It is used to validate the implementation's compatibility when performing an upgrade.\\n     *\\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\\n     * function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier.\\n     */\\n    function proxiableUUID() external view virtual notDelegated returns (bytes32) {\\n        return ERC1967Utils.IMPLEMENTATION_SLOT;\\n    }\\n\\n    /**\\n     * @dev Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call\\n     * encoded in `data`.\\n     *\\n     * Calls {_authorizeUpgrade}.\\n     *\\n     * Emits an {Upgraded} event.\\n     *\\n     * @custom:oz-upgrades-unsafe-allow-reachable delegatecall\\n     */\\n    function upgradeToAndCall(address newImplementation, bytes memory data) public payable virtual onlyProxy {\\n        _authorizeUpgrade(newImplementation);\\n        _upgradeToAndCallUUPS(newImplementation, data);\\n    }\\n\\n    /**\\n     * @dev Reverts if the execution is not performed via delegatecall or the execution\\n     * context is not of a proxy with an ERC1967-compliant implementation pointing to self.\\n     * See {_onlyProxy}.\\n     */\\n    function _checkProxy() internal view virtual {\\n        if (\\n            address(this) == __self || // Must be called through delegatecall\\n            ERC1967Utils.getImplementation() != __self // Must be called through an active proxy\\n        ) {\\n            revert UUPSUnauthorizedCallContext();\\n        }\\n    }\\n\\n    /**\\n     * @dev Reverts if the execution is performed via delegatecall.\\n     * See {notDelegated}.\\n     */\\n    function _checkNotDelegated() internal view virtual {\\n        if (address(this) != __self) {\\n            // Must not be called through delegatecall\\n            revert UUPSUnauthorizedCallContext();\\n        }\\n    }\\n\\n    /**\\n     * @dev Function that should revert when `msg.sender` is not authorized to upgrade the contract. Called by\\n     * {upgradeToAndCall}.\\n     *\\n     * Normally, this function will use an xref:access.adoc[access control] modifier such as {Ownable-onlyOwner}.\\n     *\\n     * ```solidity\\n     * function _authorizeUpgrade(address) internal onlyOwner {}\\n     * ```\\n     */\\n    function _authorizeUpgrade(address newImplementation) internal virtual;\\n\\n    /**\\n     * @dev Performs an implementation upgrade with a security check for UUPS proxies, and additional setup call.\\n     *\\n     * As a security check, {proxiableUUID} is invoked in the new implementation, and the return value\\n     * is expected to be the implementation slot in ERC1967.\\n     *\\n     * Emits an {IERC1967-Upgraded} event.\\n     */\\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data) private {\\n        try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\\n            if (slot != ERC1967Utils.IMPLEMENTATION_SLOT) {\\n                revert UUPSUnsupportedProxiableUUID(slot);\\n            }\\n            ERC1967Utils.upgradeToAndCall(newImplementation, data);\\n        } catch {\\n            // The implementation is not UUPS\\n            revert ERC1967Utils.ERC1967InvalidImplementation(newImplementation);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x3f13b947637c4969c0644cab4ef399cdc4b67f101463b8775c5a43b118558e53\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\\n\\npragma solidity ^0.8.20;\\nimport {Initializable} from \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract ContextUpgradeable is Initializable {\\n    function __Context_init() internal onlyInitializing {\\n    }\\n\\n    function __Context_init_unchained() internal onlyInitializing {\\n    }\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    function _contextSuffixLength() internal view virtual returns (uint256) {\\n        return 0;\\n    }\\n}\\n\",\"keccak256\":\"0xdbef5f0c787055227243a7318ef74c8a5a1108ca3a07f2b3a00ef67769e1e397\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Pausable.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {ContextUpgradeable} from \\\"../utils/ContextUpgradeable.sol\\\";\\nimport {Initializable} from \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract PausableUpgradeable is Initializable, ContextUpgradeable {\\n    /// @custom:storage-location erc7201:openzeppelin.storage.Pausable\\n    struct PausableStorage {\\n        bool _paused;\\n    }\\n\\n    // keccak256(abi.encode(uint256(keccak256(\\\"openzeppelin.storage.Pausable\\\")) - 1)) & ~bytes32(uint256(0xff))\\n    bytes32 private constant PausableStorageLocation = 0xcd5ed15c6e187e77e9aee88184c21f4f2182ab5827cb3b7e07fbedcd63f03300;\\n\\n    function _getPausableStorage() private pure returns (PausableStorage storage $) {\\n        assembly {\\n            $.slot := PausableStorageLocation\\n        }\\n    }\\n\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n\\n    /**\\n     * @dev The operation failed because the contract is paused.\\n     */\\n    error EnforcedPause();\\n\\n    /**\\n     * @dev The operation failed because the contract is not paused.\\n     */\\n    error ExpectedPause();\\n\\n    /**\\n     * @dev Initializes the contract in unpaused state.\\n     */\\n    function __Pausable_init() internal onlyInitializing {\\n        __Pausable_init_unchained();\\n    }\\n\\n    function __Pausable_init_unchained() internal onlyInitializing {\\n        PausableStorage storage $ = _getPausableStorage();\\n        $._paused = false;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        _requireNotPaused();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        _requirePaused();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view virtual returns (bool) {\\n        PausableStorage storage $ = _getPausableStorage();\\n        return $._paused;\\n    }\\n\\n    /**\\n     * @dev Throws if the contract is paused.\\n     */\\n    function _requireNotPaused() internal view virtual {\\n        if (paused()) {\\n            revert EnforcedPause();\\n        }\\n    }\\n\\n    /**\\n     * @dev Throws if the contract is not paused.\\n     */\\n    function _requirePaused() internal view virtual {\\n        if (!paused()) {\\n            revert ExpectedPause();\\n        }\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        PausableStorage storage $ = _getPausableStorage();\\n        $._paused = true;\\n        emit Paused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        PausableStorage storage $ = _getPausableStorage();\\n        $._paused = false;\\n        emit Unpaused(_msgSender());\\n    }\\n}\\n\",\"keccak256\":\"0x92915b7f7f642c6be3f65bfd1522feb5d5b6ef25f755f4dbb51df32c868f2f97\",\"license\":\"MIT\"},\"@openzeppelin/contracts/access/manager/AuthorityUtils.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (access/manager/AuthorityUtils.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IAuthority} from \\\"./IAuthority.sol\\\";\\n\\nlibrary AuthorityUtils {\\n    /**\\n     * @dev Since `AccessManager` implements an extended IAuthority interface, invoking `canCall` with backwards compatibility\\n     * for the preexisting `IAuthority` interface requires special care to avoid reverting on insufficient return data.\\n     * This helper function takes care of invoking `canCall` in a backwards compatible way without reverting.\\n     */\\n    function canCallWithDelay(\\n        address authority,\\n        address caller,\\n        address target,\\n        bytes4 selector\\n    ) internal view returns (bool immediate, uint32 delay) {\\n        (bool success, bytes memory data) = authority.staticcall(\\n            abi.encodeCall(IAuthority.canCall, (caller, target, selector))\\n        );\\n        if (success) {\\n            if (data.length >= 0x40) {\\n                (immediate, delay) = abi.decode(data, (bool, uint32));\\n            } else if (data.length >= 0x20) {\\n                immediate = abi.decode(data, (bool));\\n            }\\n        }\\n        return (immediate, delay);\\n    }\\n}\\n\",\"keccak256\":\"0xb3875997b0d8705e29aa20fee88e1dfef93df438794ae1ad8ba2eb016a4dd4e4\",\"license\":\"MIT\"},\"@openzeppelin/contracts/access/manager/IAccessManaged.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (access/manager/IAccessManaged.sol)\\n\\npragma solidity ^0.8.20;\\n\\ninterface IAccessManaged {\\n    /**\\n     * @dev Authority that manages this contract was updated.\\n     */\\n    event AuthorityUpdated(address authority);\\n\\n    error AccessManagedUnauthorized(address caller);\\n    error AccessManagedRequiredDelay(address caller, uint32 delay);\\n    error AccessManagedInvalidAuthority(address authority);\\n\\n    /**\\n     * @dev Returns the current authority.\\n     */\\n    function authority() external view returns (address);\\n\\n    /**\\n     * @dev Transfers control to a new authority. The caller must be the current authority.\\n     */\\n    function setAuthority(address) external;\\n\\n    /**\\n     * @dev Returns true only in the context of a delayed restricted call, at the moment that the scheduled operation is\\n     * being consumed. Prevents denial of service for delayed restricted calls in the case that the contract performs\\n     * attacker controlled calls.\\n     */\\n    function isConsumingScheduledOp() external view returns (bytes4);\\n}\\n\",\"keccak256\":\"0xaba93d42cd70e1418782951132d97b31ddce5f50ad81090884b6d0e41caac9d6\",\"license\":\"MIT\"},\"@openzeppelin/contracts/access/manager/IAccessManager.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (access/manager/IAccessManager.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IAccessManaged} from \\\"./IAccessManaged.sol\\\";\\nimport {Time} from \\\"../../utils/types/Time.sol\\\";\\n\\ninterface IAccessManager {\\n    /**\\n     * @dev A delayed operation was scheduled.\\n     */\\n    event OperationScheduled(\\n        bytes32 indexed operationId,\\n        uint32 indexed nonce,\\n        uint48 schedule,\\n        address caller,\\n        address target,\\n        bytes data\\n    );\\n\\n    /**\\n     * @dev A scheduled operation was executed.\\n     */\\n    event OperationExecuted(bytes32 indexed operationId, uint32 indexed nonce);\\n\\n    /**\\n     * @dev A scheduled operation was canceled.\\n     */\\n    event OperationCanceled(bytes32 indexed operationId, uint32 indexed nonce);\\n\\n    /**\\n     * @dev Informational labelling for a roleId.\\n     */\\n    event RoleLabel(uint64 indexed roleId, string label);\\n\\n    /**\\n     * @dev Emitted when `account` is granted `roleId`.\\n     *\\n     * NOTE: The meaning of the `since` argument depends on the `newMember` argument.\\n     * If the role is granted to a new member, the `since` argument indicates when the account becomes a member of the role,\\n     * otherwise it indicates the execution delay for this account and roleId is updated.\\n     */\\n    event RoleGranted(uint64 indexed roleId, address indexed account, uint32 delay, uint48 since, bool newMember);\\n\\n    /**\\n     * @dev Emitted when `account` membership or `roleId` is revoked. Unlike granting, revoking is instantaneous.\\n     */\\n    event RoleRevoked(uint64 indexed roleId, address indexed account);\\n\\n    /**\\n     * @dev Role acting as admin over a given `roleId` is updated.\\n     */\\n    event RoleAdminChanged(uint64 indexed roleId, uint64 indexed admin);\\n\\n    /**\\n     * @dev Role acting as guardian over a given `roleId` is updated.\\n     */\\n    event RoleGuardianChanged(uint64 indexed roleId, uint64 indexed guardian);\\n\\n    /**\\n     * @dev Grant delay for a given `roleId` will be updated to `delay` when `since` is reached.\\n     */\\n    event RoleGrantDelayChanged(uint64 indexed roleId, uint32 delay, uint48 since);\\n\\n    /**\\n     * @dev Target mode is updated (true = closed, false = open).\\n     */\\n    event TargetClosed(address indexed target, bool closed);\\n\\n    /**\\n     * @dev Role required to invoke `selector` on `target` is updated to `roleId`.\\n     */\\n    event TargetFunctionRoleUpdated(address indexed target, bytes4 selector, uint64 indexed roleId);\\n\\n    /**\\n     * @dev Admin delay for a given `target` will be updated to `delay` when `since` is reached.\\n     */\\n    event TargetAdminDelayUpdated(address indexed target, uint32 delay, uint48 since);\\n\\n    error AccessManagerAlreadyScheduled(bytes32 operationId);\\n    error AccessManagerNotScheduled(bytes32 operationId);\\n    error AccessManagerNotReady(bytes32 operationId);\\n    error AccessManagerExpired(bytes32 operationId);\\n    error AccessManagerLockedAccount(address account);\\n    error AccessManagerLockedRole(uint64 roleId);\\n    error AccessManagerBadConfirmation();\\n    error AccessManagerUnauthorizedAccount(address msgsender, uint64 roleId);\\n    error AccessManagerUnauthorizedCall(address caller, address target, bytes4 selector);\\n    error AccessManagerUnauthorizedConsume(address target);\\n    error AccessManagerUnauthorizedCancel(address msgsender, address caller, address target, bytes4 selector);\\n    error AccessManagerInvalidInitialAdmin(address initialAdmin);\\n\\n    /**\\n     * @dev Check if an address (`caller`) is authorised to call a given function on a given contract directly (with\\n     * no restriction). Additionally, it returns the delay needed to perform the call indirectly through the {schedule}\\n     * & {execute} workflow.\\n     *\\n     * This function is usually called by the targeted contract to control immediate execution of restricted functions.\\n     * Therefore we only return true if the call can be performed without any delay. If the call is subject to a\\n     * previously set delay (not zero), then the function should return false and the caller should schedule the operation\\n     * for future execution.\\n     *\\n     * If `immediate` is true, the delay can be disregarded and the operation can be immediately executed, otherwise\\n     * the operation can be executed if and only if delay is greater than 0.\\n     *\\n     * NOTE: The IAuthority interface does not include the `uint32` delay. This is an extension of that interface that\\n     * is backward compatible. Some contracts may thus ignore the second return argument. In that case they will fail\\n     * to identify the indirect workflow, and will consider calls that require a delay to be forbidden.\\n     *\\n     * NOTE: This function does not report the permissions of this manager itself. These are defined by the\\n     * {_canCallSelf} function instead.\\n     */\\n    function canCall(\\n        address caller,\\n        address target,\\n        bytes4 selector\\n    ) external view returns (bool allowed, uint32 delay);\\n\\n    /**\\n     * @dev Expiration delay for scheduled proposals. Defaults to 1 week.\\n     *\\n     * IMPORTANT: Avoid overriding the expiration with 0. Otherwise every contract proposal will be expired immediately,\\n     * disabling any scheduling usage.\\n     */\\n    function expiration() external view returns (uint32);\\n\\n    /**\\n     * @dev Minimum setback for all delay updates, with the exception of execution delays. It\\n     * can be increased without setback (and reset via {revokeRole} in the case event of an\\n     * accidental increase). Defaults to 5 days.\\n     */\\n    function minSetback() external view returns (uint32);\\n\\n    /**\\n     * @dev Get whether the contract is closed disabling any access. Otherwise role permissions are applied.\\n     */\\n    function isTargetClosed(address target) external view returns (bool);\\n\\n    /**\\n     * @dev Get the role required to call a function.\\n     */\\n    function getTargetFunctionRole(address target, bytes4 selector) external view returns (uint64);\\n\\n    /**\\n     * @dev Get the admin delay for a target contract. Changes to contract configuration are subject to this delay.\\n     */\\n    function getTargetAdminDelay(address target) external view returns (uint32);\\n\\n    /**\\n     * @dev Get the id of the role that acts as an admin for the given role.\\n     *\\n     * The admin permission is required to grant the role, revoke the role and update the execution delay to execute\\n     * an operation that is restricted to this role.\\n     */\\n    function getRoleAdmin(uint64 roleId) external view returns (uint64);\\n\\n    /**\\n     * @dev Get the role that acts as a guardian for a given role.\\n     *\\n     * The guardian permission allows canceling operations that have been scheduled under the role.\\n     */\\n    function getRoleGuardian(uint64 roleId) external view returns (uint64);\\n\\n    /**\\n     * @dev Get the role current grant delay.\\n     *\\n     * Its value may change at any point without an event emitted following a call to {setGrantDelay}.\\n     * Changes to this value, including effect timepoint are notified in advance by the {RoleGrantDelayChanged} event.\\n     */\\n    function getRoleGrantDelay(uint64 roleId) external view returns (uint32);\\n\\n    /**\\n     * @dev Get the access details for a given account for a given role. These details include the timepoint at which\\n     * membership becomes active, and the delay applied to all operation by this user that requires this permission\\n     * level.\\n     *\\n     * Returns:\\n     * [0] Timestamp at which the account membership becomes valid. 0 means role is not granted.\\n     * [1] Current execution delay for the account.\\n     * [2] Pending execution delay for the account.\\n     * [3] Timestamp at which the pending execution delay will become active. 0 means no delay update is scheduled.\\n     */\\n    function getAccess(uint64 roleId, address account) external view returns (uint48, uint32, uint32, uint48);\\n\\n    /**\\n     * @dev Check if a given account currently has the permission level corresponding to a given role. Note that this\\n     * permission might be associated with an execution delay. {getAccess} can provide more details.\\n     */\\n    function hasRole(uint64 roleId, address account) external view returns (bool, uint32);\\n\\n    /**\\n     * @dev Give a label to a role, for improved role discoverability by UIs.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be a global admin\\n     *\\n     * Emits a {RoleLabel} event.\\n     */\\n    function labelRole(uint64 roleId, string calldata label) external;\\n\\n    /**\\n     * @dev Add `account` to `roleId`, or change its execution delay.\\n     *\\n     * This gives the account the authorization to call any function that is restricted to this role. An optional\\n     * execution delay (in seconds) can be set. If that delay is non 0, the user is required to schedule any operation\\n     * that is restricted to members of this role. The user will only be able to execute the operation after the delay has\\n     * passed, before it has expired. During this period, admin and guardians can cancel the operation (see {cancel}).\\n     *\\n     * If the account has already been granted this role, the execution delay will be updated. This update is not\\n     * immediate and follows the delay rules. For example, if a user currently has a delay of 3 hours, and this is\\n     * called to reduce that delay to 1 hour, the new delay will take some time to take effect, enforcing that any\\n     * operation executed in the 3 hours that follows this update was indeed scheduled before this update.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be an admin for the role (see {getRoleAdmin})\\n     * - granted role must not be the `PUBLIC_ROLE`\\n     *\\n     * Emits a {RoleGranted} event.\\n     */\\n    function grantRole(uint64 roleId, address account, uint32 executionDelay) external;\\n\\n    /**\\n     * @dev Remove an account from a role, with immediate effect. If the account does not have the role, this call has\\n     * no effect.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be an admin for the role (see {getRoleAdmin})\\n     * - revoked role must not be the `PUBLIC_ROLE`\\n     *\\n     * Emits a {RoleRevoked} event if the account had the role.\\n     */\\n    function revokeRole(uint64 roleId, address account) external;\\n\\n    /**\\n     * @dev Renounce role permissions for the calling account with immediate effect. If the sender is not in\\n     * the role this call has no effect.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `callerConfirmation`.\\n     *\\n     * Emits a {RoleRevoked} event if the account had the role.\\n     */\\n    function renounceRole(uint64 roleId, address callerConfirmation) external;\\n\\n    /**\\n     * @dev Change admin role for a given role.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be a global admin\\n     *\\n     * Emits a {RoleAdminChanged} event\\n     */\\n    function setRoleAdmin(uint64 roleId, uint64 admin) external;\\n\\n    /**\\n     * @dev Change guardian role for a given role.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be a global admin\\n     *\\n     * Emits a {RoleGuardianChanged} event\\n     */\\n    function setRoleGuardian(uint64 roleId, uint64 guardian) external;\\n\\n    /**\\n     * @dev Update the delay for granting a `roleId`.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be a global admin\\n     *\\n     * Emits a {RoleGrantDelayChanged} event.\\n     */\\n    function setGrantDelay(uint64 roleId, uint32 newDelay) external;\\n\\n    /**\\n     * @dev Set the role required to call functions identified by the `selectors` in the `target` contract.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be a global admin\\n     *\\n     * Emits a {TargetFunctionRoleUpdated} event per selector.\\n     */\\n    function setTargetFunctionRole(address target, bytes4[] calldata selectors, uint64 roleId) external;\\n\\n    /**\\n     * @dev Set the delay for changing the configuration of a given target contract.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be a global admin\\n     *\\n     * Emits a {TargetAdminDelayUpdated} event.\\n     */\\n    function setTargetAdminDelay(address target, uint32 newDelay) external;\\n\\n    /**\\n     * @dev Set the closed flag for a contract.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be a global admin\\n     *\\n     * Emits a {TargetClosed} event.\\n     */\\n    function setTargetClosed(address target, bool closed) external;\\n\\n    /**\\n     * @dev Return the timepoint at which a scheduled operation will be ready for execution. This returns 0 if the\\n     * operation is not yet scheduled, has expired, was executed, or was canceled.\\n     */\\n    function getSchedule(bytes32 id) external view returns (uint48);\\n\\n    /**\\n     * @dev Return the nonce for the latest scheduled operation with a given id. Returns 0 if the operation has never\\n     * been scheduled.\\n     */\\n    function getNonce(bytes32 id) external view returns (uint32);\\n\\n    /**\\n     * @dev Schedule a delayed operation for future execution, and return the operation identifier. It is possible to\\n     * choose the timestamp at which the operation becomes executable as long as it satisfies the execution delays\\n     * required for the caller. The special value zero will automatically set the earliest possible time.\\n     *\\n     * Returns the `operationId` that was scheduled. Since this value is a hash of the parameters, it can reoccur when\\n     * the same parameters are used; if this is relevant, the returned `nonce` can be used to uniquely identify this\\n     * scheduled operation from other occurrences of the same `operationId` in invocations of {execute} and {cancel}.\\n     *\\n     * Emits a {OperationScheduled} event.\\n     *\\n     * NOTE: It is not possible to concurrently schedule more than one operation with the same `target` and `data`. If\\n     * this is necessary, a random byte can be appended to `data` to act as a salt that will be ignored by the target\\n     * contract if it is using standard Solidity ABI encoding.\\n     */\\n    function schedule(address target, bytes calldata data, uint48 when) external returns (bytes32, uint32);\\n\\n    /**\\n     * @dev Execute a function that is delay restricted, provided it was properly scheduled beforehand, or the\\n     * execution delay is 0.\\n     *\\n     * Returns the nonce that identifies the previously scheduled operation that is executed, or 0 if the\\n     * operation wasn't previously scheduled (if the caller doesn't have an execution delay).\\n     *\\n     * Emits an {OperationExecuted} event only if the call was scheduled and delayed.\\n     */\\n    function execute(address target, bytes calldata data) external payable returns (uint32);\\n\\n    /**\\n     * @dev Cancel a scheduled (delayed) operation. Returns the nonce that identifies the previously scheduled\\n     * operation that is cancelled.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be the proposer, a guardian of the targeted function, or a global admin\\n     *\\n     * Emits a {OperationCanceled} event.\\n     */\\n    function cancel(address caller, address target, bytes calldata data) external returns (uint32);\\n\\n    /**\\n     * @dev Consume a scheduled operation targeting the caller. If such an operation exists, mark it as consumed\\n     * (emit an {OperationExecuted} event and clean the state). Otherwise, throw an error.\\n     *\\n     * This is useful for contract that want to enforce that calls targeting them were scheduled on the manager,\\n     * with all the verifications that it implies.\\n     *\\n     * Emit a {OperationExecuted} event.\\n     */\\n    function consumeScheduledOp(address caller, bytes calldata data) external;\\n\\n    /**\\n     * @dev Hashing function for delayed operations.\\n     */\\n    function hashOperation(address caller, address target, bytes calldata data) external view returns (bytes32);\\n\\n    /**\\n     * @dev Changes the authority of a target managed by this manager instance.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be a global admin\\n     */\\n    function updateAuthority(address target, address newAuthority) external;\\n}\\n\",\"keccak256\":\"0xdabf85e3bab52e7cfade4f77e661bcf7a2f9f95097bfd2ca5ddb193a0c21ee8b\",\"license\":\"MIT\"},\"@openzeppelin/contracts/access/manager/IAuthority.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (access/manager/IAuthority.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Standard interface for permissioning originally defined in Dappsys.\\n */\\ninterface IAuthority {\\n    /**\\n     * @dev Returns true if the caller can invoke on a target the function identified by a function selector.\\n     */\\n    function canCall(address caller, address target, bytes4 selector) external view returns (bool allowed);\\n}\\n\",\"keccak256\":\"0x4cc0766bd7fb7b3bafb70afa2a93b6e313a0baec7a35ad1b57505be7861c1030\",\"license\":\"MIT\"},\"@openzeppelin/contracts/interfaces/draft-IERC1822.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/draft-IERC1822.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\\n * proxy whose upgrades are fully controlled by the current implementation.\\n */\\ninterface IERC1822Proxiable {\\n    /**\\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\\n     * address.\\n     *\\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\\n     * function revert if invoked through a proxy.\\n     */\\n    function proxiableUUID() external view returns (bytes32);\\n}\\n\",\"keccak256\":\"0x2a1f9944df2015c081d89cd41ba22ffaf10aa6285969f0dc612b235cc448999c\",\"license\":\"MIT\"},\"@openzeppelin/contracts/proxy/ERC1967/ERC1967Utils.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/ERC1967/ERC1967Utils.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IBeacon} from \\\"../beacon/IBeacon.sol\\\";\\nimport {Address} from \\\"../../utils/Address.sol\\\";\\nimport {StorageSlot} from \\\"../../utils/StorageSlot.sol\\\";\\n\\n/**\\n * @dev This abstract contract provides getters and event emitting update functions for\\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\\n */\\nlibrary ERC1967Utils {\\n    // We re-declare ERC-1967 events here because they can't be used directly from IERC1967.\\n    // This will be fixed in Solidity 0.8.21. At that point we should remove these events.\\n    /**\\n     * @dev Emitted when the implementation is upgraded.\\n     */\\n    event Upgraded(address indexed implementation);\\n\\n    /**\\n     * @dev Emitted when the admin account has changed.\\n     */\\n    event AdminChanged(address previousAdmin, address newAdmin);\\n\\n    /**\\n     * @dev Emitted when the beacon is changed.\\n     */\\n    event BeaconUpgraded(address indexed beacon);\\n\\n    /**\\n     * @dev Storage slot with the address of the current implementation.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.implementation\\\" subtracted by 1.\\n     */\\n    // solhint-disable-next-line private-vars-leading-underscore\\n    bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n\\n    /**\\n     * @dev The `implementation` of the proxy is invalid.\\n     */\\n    error ERC1967InvalidImplementation(address implementation);\\n\\n    /**\\n     * @dev The `admin` of the proxy is invalid.\\n     */\\n    error ERC1967InvalidAdmin(address admin);\\n\\n    /**\\n     * @dev The `beacon` of the proxy is invalid.\\n     */\\n    error ERC1967InvalidBeacon(address beacon);\\n\\n    /**\\n     * @dev An upgrade function sees `msg.value > 0` that may be lost.\\n     */\\n    error ERC1967NonPayable();\\n\\n    /**\\n     * @dev Returns the current implementation address.\\n     */\\n    function getImplementation() internal view returns (address) {\\n        return StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new address in the EIP1967 implementation slot.\\n     */\\n    function _setImplementation(address newImplementation) private {\\n        if (newImplementation.code.length == 0) {\\n            revert ERC1967InvalidImplementation(newImplementation);\\n        }\\n        StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value = newImplementation;\\n    }\\n\\n    /**\\n     * @dev Performs implementation upgrade with additional setup call if data is nonempty.\\n     * This function is payable only if the setup call is performed, otherwise `msg.value` is rejected\\n     * to avoid stuck value in the contract.\\n     *\\n     * Emits an {IERC1967-Upgraded} event.\\n     */\\n    function upgradeToAndCall(address newImplementation, bytes memory data) internal {\\n        _setImplementation(newImplementation);\\n        emit Upgraded(newImplementation);\\n\\n        if (data.length > 0) {\\n            Address.functionDelegateCall(newImplementation, data);\\n        } else {\\n            _checkNonPayable();\\n        }\\n    }\\n\\n    /**\\n     * @dev Storage slot with the admin of the contract.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.admin\\\" subtracted by 1.\\n     */\\n    // solhint-disable-next-line private-vars-leading-underscore\\n    bytes32 internal constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\\n\\n    /**\\n     * @dev Returns the current admin.\\n     *\\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using\\n     * the https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\\n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\\n     */\\n    function getAdmin() internal view returns (address) {\\n        return StorageSlot.getAddressSlot(ADMIN_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new address in the EIP1967 admin slot.\\n     */\\n    function _setAdmin(address newAdmin) private {\\n        if (newAdmin == address(0)) {\\n            revert ERC1967InvalidAdmin(address(0));\\n        }\\n        StorageSlot.getAddressSlot(ADMIN_SLOT).value = newAdmin;\\n    }\\n\\n    /**\\n     * @dev Changes the admin of the proxy.\\n     *\\n     * Emits an {IERC1967-AdminChanged} event.\\n     */\\n    function changeAdmin(address newAdmin) internal {\\n        emit AdminChanged(getAdmin(), newAdmin);\\n        _setAdmin(newAdmin);\\n    }\\n\\n    /**\\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.beacon\\\" subtracted by 1.\\n     */\\n    // solhint-disable-next-line private-vars-leading-underscore\\n    bytes32 internal constant BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\\n\\n    /**\\n     * @dev Returns the current beacon.\\n     */\\n    function getBeacon() internal view returns (address) {\\n        return StorageSlot.getAddressSlot(BEACON_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\\n     */\\n    function _setBeacon(address newBeacon) private {\\n        if (newBeacon.code.length == 0) {\\n            revert ERC1967InvalidBeacon(newBeacon);\\n        }\\n\\n        StorageSlot.getAddressSlot(BEACON_SLOT).value = newBeacon;\\n\\n        address beaconImplementation = IBeacon(newBeacon).implementation();\\n        if (beaconImplementation.code.length == 0) {\\n            revert ERC1967InvalidImplementation(beaconImplementation);\\n        }\\n    }\\n\\n    /**\\n     * @dev Change the beacon and trigger a setup call if data is nonempty.\\n     * This function is payable only if the setup call is performed, otherwise `msg.value` is rejected\\n     * to avoid stuck value in the contract.\\n     *\\n     * Emits an {IERC1967-BeaconUpgraded} event.\\n     *\\n     * CAUTION: Invoking this function has no effect on an instance of {BeaconProxy} since v5, since\\n     * it uses an immutable beacon without looking at the value of the ERC-1967 beacon slot for\\n     * efficiency.\\n     */\\n    function upgradeBeaconToAndCall(address newBeacon, bytes memory data) internal {\\n        _setBeacon(newBeacon);\\n        emit BeaconUpgraded(newBeacon);\\n\\n        if (data.length > 0) {\\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\\n        } else {\\n            _checkNonPayable();\\n        }\\n    }\\n\\n    /**\\n     * @dev Reverts if `msg.value` is not zero. It can be used to avoid `msg.value` stuck in the contract\\n     * if an upgrade doesn't perform an initialization call.\\n     */\\n    function _checkNonPayable() private {\\n        if (msg.value > 0) {\\n            revert ERC1967NonPayable();\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x06a78f9b3ee3e6d0eb4e4cd635ba49960bea34cac1db8c0a27c75f2319f1fd65\",\"license\":\"MIT\"},\"@openzeppelin/contracts/proxy/beacon/IBeacon.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/beacon/IBeacon.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\\n */\\ninterface IBeacon {\\n    /**\\n     * @dev Must return an address that can be used as a delegate call target.\\n     *\\n     * {UpgradeableBeacon} will check that this address is a contract.\\n     */\\n    function implementation() external view returns (address);\\n}\\n\",\"keccak256\":\"0xc59a78b07b44b2cf2e8ab4175fca91e8eca1eee2df7357b8d2a8833e5ea1f64c\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC1155/IERC1155Receiver.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC165} from \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Interface that must be implemented by smart contracts in order to receive\\n * ERC-1155 token transfers.\\n */\\ninterface IERC1155Receiver is IERC165 {\\n    /**\\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\\n     *\\n     * NOTE: To accept the transfer, this must return\\n     * `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))`\\n     * (i.e. 0xf23a6e61, or its own function selector).\\n     *\\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\\n     * @param from The address which previously owned the token\\n     * @param id The ID of the token being transferred\\n     * @param value The amount of tokens being transferred\\n     * @param data Additional data with no specified format\\n     * @return `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))` if transfer is allowed\\n     */\\n    function onERC1155Received(\\n        address operator,\\n        address from,\\n        uint256 id,\\n        uint256 value,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n\\n    /**\\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\\n     * been updated.\\n     *\\n     * NOTE: To accept the transfer(s), this must return\\n     * `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))`\\n     * (i.e. 0xbc197c81, or its own function selector).\\n     *\\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\\n     * @param from The address which previously owned the token\\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\\n     * @param data Additional data with no specified format\\n     * @return `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))` if transfer is allowed\\n     */\\n    function onERC1155BatchReceived(\\n        address operator,\\n        address from,\\n        uint256[] calldata ids,\\n        uint256[] calldata values,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\",\"keccak256\":\"0xb69597a63b202e28401128bed6a6d259e8730191274471af7303eafb247881a3\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC721/IERC721.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC165} from \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\\n     *   a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or\\n     *   {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\\n     *   a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the address zero.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x5ef46daa3b58ef2702279d514780316efaa952915ee1aa3396f041ee2982b0b4\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/IERC721Receiver.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721Receiver {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be\\n     * reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\",\"keccak256\":\"0x7f7a26306c79a65fb8b3b6c757cd74660c532cd8a02e165488e30027dd34ca49\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/extensions/IERC721Metadata.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC721} from \\\"../IERC721.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721Metadata is IERC721 {\\n    /**\\n     * @dev Returns the token collection name.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the token collection symbol.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\\n     */\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n}\\n\",\"keccak256\":\"0x37d1aaaa5a2908a09e9dcf56a26ddf762ecf295afb5964695937344fc6802ce1\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev The ETH balance of the account is not enough to perform the operation.\\n     */\\n    error AddressInsufficientBalance(address account);\\n\\n    /**\\n     * @dev There's no code at `target` (it is not a contract).\\n     */\\n    error AddressEmptyCode(address target);\\n\\n    /**\\n     * @dev A call to an address target failed. The target may have reverted.\\n     */\\n    error FailedInnerCall();\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        if (address(this).balance < amount) {\\n            revert AddressInsufficientBalance(address(this));\\n        }\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        if (!success) {\\n            revert FailedInnerCall();\\n        }\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason or custom error, it is bubbled\\n     * up by this function (like regular Solidity function calls). However, if\\n     * the call reverted with no returned reason, this function reverts with a\\n     * {FailedInnerCall} error.\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        if (address(this).balance < value) {\\n            revert AddressInsufficientBalance(address(this));\\n        }\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\\n     * unsuccessful call.\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata\\n    ) internal view returns (bytes memory) {\\n        if (!success) {\\n            _revert(returndata);\\n        } else {\\n            // only check if target is a contract if the call was successful and the return data is empty\\n            // otherwise we already know that it was a contract\\n            if (returndata.length == 0 && target.code.length == 0) {\\n                revert AddressEmptyCode(target);\\n            }\\n            return returndata;\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\\n     * revert reason or with a default {FailedInnerCall} error.\\n     */\\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\\n        if (!success) {\\n            _revert(returndata);\\n        } else {\\n            return returndata;\\n        }\\n    }\\n\\n    /**\\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\\n     */\\n    function _revert(bytes memory returndata) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert FailedInnerCall();\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xaf28a975a78550e45f65e559a3ad6a5ad43b9b8a37366999abd1b7084eb70721\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/ShortStrings.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/ShortStrings.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {StorageSlot} from \\\"./StorageSlot.sol\\\";\\n\\n// | string  | 0xAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA   |\\n// | length  | 0x                                                              BB |\\ntype ShortString is bytes32;\\n\\n/**\\n * @dev This library provides functions to convert short memory strings\\n * into a `ShortString` type that can be used as an immutable variable.\\n *\\n * Strings of arbitrary length can be optimized using this library if\\n * they are short enough (up to 31 bytes) by packing them with their\\n * length (1 byte) in a single EVM word (32 bytes). Additionally, a\\n * fallback mechanism can be used for every other case.\\n *\\n * Usage example:\\n *\\n * ```solidity\\n * contract Named {\\n *     using ShortStrings for *;\\n *\\n *     ShortString private immutable _name;\\n *     string private _nameFallback;\\n *\\n *     constructor(string memory contractName) {\\n *         _name = contractName.toShortStringWithFallback(_nameFallback);\\n *     }\\n *\\n *     function name() external view returns (string memory) {\\n *         return _name.toStringWithFallback(_nameFallback);\\n *     }\\n * }\\n * ```\\n */\\nlibrary ShortStrings {\\n    // Used as an identifier for strings longer than 31 bytes.\\n    bytes32 private constant FALLBACK_SENTINEL = 0x00000000000000000000000000000000000000000000000000000000000000FF;\\n\\n    error StringTooLong(string str);\\n    error InvalidShortString();\\n\\n    /**\\n     * @dev Encode a string of at most 31 chars into a `ShortString`.\\n     *\\n     * This will trigger a `StringTooLong` error is the input string is too long.\\n     */\\n    function toShortString(string memory str) internal pure returns (ShortString) {\\n        bytes memory bstr = bytes(str);\\n        if (bstr.length > 31) {\\n            revert StringTooLong(str);\\n        }\\n        return ShortString.wrap(bytes32(uint256(bytes32(bstr)) | bstr.length));\\n    }\\n\\n    /**\\n     * @dev Decode a `ShortString` back to a \\\"normal\\\" string.\\n     */\\n    function toString(ShortString sstr) internal pure returns (string memory) {\\n        uint256 len = byteLength(sstr);\\n        // using `new string(len)` would work locally but is not memory safe.\\n        string memory str = new string(32);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(str, len)\\n            mstore(add(str, 0x20), sstr)\\n        }\\n        return str;\\n    }\\n\\n    /**\\n     * @dev Return the length of a `ShortString`.\\n     */\\n    function byteLength(ShortString sstr) internal pure returns (uint256) {\\n        uint256 result = uint256(ShortString.unwrap(sstr)) & 0xFF;\\n        if (result > 31) {\\n            revert InvalidShortString();\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Encode a string into a `ShortString`, or write it to storage if it is too long.\\n     */\\n    function toShortStringWithFallback(string memory value, string storage store) internal returns (ShortString) {\\n        if (bytes(value).length < 32) {\\n            return toShortString(value);\\n        } else {\\n            StorageSlot.getStringSlot(store).value = value;\\n            return ShortString.wrap(FALLBACK_SENTINEL);\\n        }\\n    }\\n\\n    /**\\n     * @dev Decode a string that was encoded to `ShortString` or written to storage using {setWithFallback}.\\n     */\\n    function toStringWithFallback(ShortString value, string storage store) internal pure returns (string memory) {\\n        if (ShortString.unwrap(value) != FALLBACK_SENTINEL) {\\n            return toString(value);\\n        } else {\\n            return store;\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the length of a string that was encoded to `ShortString` or written to storage using\\n     * {setWithFallback}.\\n     *\\n     * WARNING: This will return the \\\"byte length\\\" of the string. This may not reflect the actual length in terms of\\n     * actual characters as the UTF-8 encoding of a single character can span over multiple bytes.\\n     */\\n    function byteLengthWithFallback(ShortString value, string storage store) internal view returns (uint256) {\\n        if (ShortString.unwrap(value) != FALLBACK_SENTINEL) {\\n            return byteLength(value);\\n        } else {\\n            return bytes(store).length;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x18a7171df639a934592915a520ecb97c5bbc9675a1105607aac8a94e72bf62c6\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/StorageSlot.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/StorageSlot.sol)\\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Library for reading and writing primitive types to specific storage slots.\\n *\\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\\n * This library helps with reading and writing to such slots without the need for inline assembly.\\n *\\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\\n *\\n * Example usage to set ERC1967 implementation slot:\\n * ```solidity\\n * contract ERC1967 {\\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n *\\n *     function _getImplementation() internal view returns (address) {\\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\n *     }\\n *\\n *     function _setImplementation(address newImplementation) internal {\\n *         require(newImplementation.code.length > 0);\\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\\n *     }\\n * }\\n * ```\\n */\\nlibrary StorageSlot {\\n    struct AddressSlot {\\n        address value;\\n    }\\n\\n    struct BooleanSlot {\\n        bool value;\\n    }\\n\\n    struct Bytes32Slot {\\n        bytes32 value;\\n    }\\n\\n    struct Uint256Slot {\\n        uint256 value;\\n    }\\n\\n    struct StringSlot {\\n        string value;\\n    }\\n\\n    struct BytesSlot {\\n        bytes value;\\n    }\\n\\n    /**\\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\\n     */\\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\\n     */\\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\\n     */\\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\\n     */\\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\\n     */\\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\\n     */\\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := store.slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\\n     */\\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\\n     */\\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := store.slot\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x32ba59b4b7299237c8ba56319110989d7978a039faf754793064e967e5894418\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Strings.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {Math} from \\\"./math/Math.sol\\\";\\nimport {SignedMath} from \\\"./math/SignedMath.sol\\\";\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant HEX_DIGITS = \\\"0123456789abcdef\\\";\\n    uint8 private constant ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev The `value` string doesn't fit in the specified `length`.\\n     */\\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            uint256 length = Math.log10(value) + 1;\\n            string memory buffer = new string(length);\\n            uint256 ptr;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                ptr := add(buffer, add(32, length))\\n            }\\n            while (true) {\\n                ptr--;\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\\n                }\\n                value /= 10;\\n                if (value == 0) break;\\n            }\\n            return buffer;\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\\n     */\\n    function toStringSigned(int256 value) internal pure returns (string memory) {\\n        return string.concat(value < 0 ? \\\"-\\\" : \\\"\\\", toString(SignedMath.abs(value)));\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            return toHexString(value, Math.log256(value) + 1);\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        uint256 localValue = value;\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = HEX_DIGITS[localValue & 0xf];\\n            localValue >>= 4;\\n        }\\n        if (localValue != 0) {\\n            revert StringsInsufficientHexLength(value, length);\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal\\n     * representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\\n    }\\n\\n    /**\\n     * @dev Returns true if the two strings are equal.\\n     */\\n    function equal(string memory a, string memory b) internal pure returns (bool) {\\n        return bytes(a).length == bytes(b).length && keccak256(bytes(a)) == keccak256(bytes(b));\\n    }\\n}\\n\",\"keccak256\":\"0x55f102ea785d8399c0e58d1108e2d289506dde18abc6db1b7f68c1f9f9bc5792\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/ERC165Checker.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC165} from \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Library used to query support of an interface declared via {IERC165}.\\n *\\n * Note that these functions return the actual result of the query: they do not\\n * `revert` if an interface is not supported. It is up to the caller to decide\\n * what to do in these cases.\\n */\\nlibrary ERC165Checker {\\n    // As per the EIP-165 spec, no interface should ever match 0xffffffff\\n    bytes4 private constant INTERFACE_ID_INVALID = 0xffffffff;\\n\\n    /**\\n     * @dev Returns true if `account` supports the {IERC165} interface.\\n     */\\n    function supportsERC165(address account) internal view returns (bool) {\\n        // Any contract that implements ERC165 must explicitly indicate support of\\n        // InterfaceId_ERC165 and explicitly indicate non-support of InterfaceId_Invalid\\n        return\\n            supportsERC165InterfaceUnchecked(account, type(IERC165).interfaceId) &&\\n            !supportsERC165InterfaceUnchecked(account, INTERFACE_ID_INVALID);\\n    }\\n\\n    /**\\n     * @dev Returns true if `account` supports the interface defined by\\n     * `interfaceId`. Support for {IERC165} itself is queried automatically.\\n     *\\n     * See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(address account, bytes4 interfaceId) internal view returns (bool) {\\n        // query support of both ERC165 as per the spec and support of _interfaceId\\n        return supportsERC165(account) && supportsERC165InterfaceUnchecked(account, interfaceId);\\n    }\\n\\n    /**\\n     * @dev Returns a boolean array where each value corresponds to the\\n     * interfaces passed in and whether they're supported or not. This allows\\n     * you to batch check interfaces for a contract where your expectation\\n     * is that some interfaces may not be supported.\\n     *\\n     * See {IERC165-supportsInterface}.\\n     */\\n    function getSupportedInterfaces(\\n        address account,\\n        bytes4[] memory interfaceIds\\n    ) internal view returns (bool[] memory) {\\n        // an array of booleans corresponding to interfaceIds and whether they're supported or not\\n        bool[] memory interfaceIdsSupported = new bool[](interfaceIds.length);\\n\\n        // query support of ERC165 itself\\n        if (supportsERC165(account)) {\\n            // query support of each interface in interfaceIds\\n            for (uint256 i = 0; i < interfaceIds.length; i++) {\\n                interfaceIdsSupported[i] = supportsERC165InterfaceUnchecked(account, interfaceIds[i]);\\n            }\\n        }\\n\\n        return interfaceIdsSupported;\\n    }\\n\\n    /**\\n     * @dev Returns true if `account` supports all the interfaces defined in\\n     * `interfaceIds`. Support for {IERC165} itself is queried automatically.\\n     *\\n     * Batch-querying can lead to gas savings by skipping repeated checks for\\n     * {IERC165} support.\\n     *\\n     * See {IERC165-supportsInterface}.\\n     */\\n    function supportsAllInterfaces(address account, bytes4[] memory interfaceIds) internal view returns (bool) {\\n        // query support of ERC165 itself\\n        if (!supportsERC165(account)) {\\n            return false;\\n        }\\n\\n        // query support of each interface in interfaceIds\\n        for (uint256 i = 0; i < interfaceIds.length; i++) {\\n            if (!supportsERC165InterfaceUnchecked(account, interfaceIds[i])) {\\n                return false;\\n            }\\n        }\\n\\n        // all interfaces supported\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Query if a contract implements an interface, does not check ERC165 support\\n     * @param account The address of the contract to query for support of an interface\\n     * @param interfaceId The interface identifier, as specified in ERC-165\\n     * @return true if the contract at account indicates support of the interface with\\n     * identifier interfaceId, false otherwise\\n     * @dev Assumes that account contains a contract that supports ERC165, otherwise\\n     * the behavior of this method is undefined. This precondition can be checked\\n     * with {supportsERC165}.\\n     *\\n     * Some precompiled contracts will falsely indicate support for a given interface, so caution\\n     * should be exercised when using this function.\\n     *\\n     * Interface identification is specified in ERC-165.\\n     */\\n    function supportsERC165InterfaceUnchecked(address account, bytes4 interfaceId) internal view returns (bool) {\\n        // prepare call\\n        bytes memory encodedParams = abi.encodeCall(IERC165.supportsInterface, (interfaceId));\\n\\n        // perform static call\\n        bool success;\\n        uint256 returnSize;\\n        uint256 returnValue;\\n        assembly {\\n            success := staticcall(30000, account, add(encodedParams, 0x20), mload(encodedParams), 0x00, 0x20)\\n            returnSize := returndatasize()\\n            returnValue := mload(0x00)\\n        }\\n\\n        return success && returnSize >= 0x20 && returnValue > 0;\\n    }\\n}\\n\",\"keccak256\":\"0xac3d50e321a48a40b4496970ce725900f13aeb2255b7c1203f5adbe98c4a911a\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/introspection/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x4296879f55019b23e135000eb36896057e7101fb7fb859c5ef690cf14643757b\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/math/Math.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    /**\\n     * @dev Muldiv operation overflow.\\n     */\\n    error MathOverflowedMulDiv();\\n\\n    enum Rounding {\\n        Floor, // Toward negative infinity\\n        Ceil, // Toward positive infinity\\n        Trunc, // Toward zero\\n        Expand // Away from zero\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds towards infinity instead\\n     * of rounding towards zero.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (b == 0) {\\n            // Guarantee the same behavior as in a regular Solidity division.\\n            return a / b;\\n        }\\n\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\\n     * denominator == 0.\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\\n     * Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0 = x * y; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\\n                // The surrounding unchecked block does not change this fact.\\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            if (denominator <= prod1) {\\n                revert MathOverflowedMulDiv();\\n            }\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\\n            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\\n\\n            uint256 twos = denominator & (0 - denominator);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\\n            // works in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\\n     * towards zero.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \\u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \\u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10 ** 64) {\\n                value /= 10 ** 64;\\n                result += 64;\\n            }\\n            if (value >= 10 ** 32) {\\n                value /= 10 ** 32;\\n                result += 32;\\n            }\\n            if (value >= 10 ** 16) {\\n                value /= 10 ** 16;\\n                result += 16;\\n            }\\n            if (value >= 10 ** 8) {\\n                value /= 10 ** 8;\\n                result += 8;\\n            }\\n            if (value >= 10 ** 4) {\\n                value /= 10 ** 4;\\n                result += 4;\\n            }\\n            if (value >= 10 ** 2) {\\n                value /= 10 ** 2;\\n                result += 2;\\n            }\\n            if (value >= 10 ** 1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\\n     */\\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\\n        return uint8(rounding) % 2 == 1;\\n    }\\n}\\n\",\"keccak256\":\"0x005ec64c6313f0555d59e278f9a7a5ab2db5bdc72a027f255a37c327af1ec02d\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/math/SafeCast.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SafeCast.sol)\\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\\n * checks.\\n *\\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\\n * easily result in undesired exploitation or bugs, since developers usually\\n * assume that overflows raise errors. `SafeCast` restores this intuition by\\n * reverting the transaction when such an operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeCast {\\n    /**\\n     * @dev Value doesn't fit in an uint of `bits` size.\\n     */\\n    error SafeCastOverflowedUintDowncast(uint8 bits, uint256 value);\\n\\n    /**\\n     * @dev An int value doesn't fit in an uint of `bits` size.\\n     */\\n    error SafeCastOverflowedIntToUint(int256 value);\\n\\n    /**\\n     * @dev Value doesn't fit in an int of `bits` size.\\n     */\\n    error SafeCastOverflowedIntDowncast(uint8 bits, int256 value);\\n\\n    /**\\n     * @dev An uint value doesn't fit in an int of `bits` size.\\n     */\\n    error SafeCastOverflowedUintToInt(uint256 value);\\n\\n    /**\\n     * @dev Returns the downcasted uint248 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint248).\\n     *\\n     * Counterpart to Solidity's `uint248` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 248 bits\\n     */\\n    function toUint248(uint256 value) internal pure returns (uint248) {\\n        if (value > type(uint248).max) {\\n            revert SafeCastOverflowedUintDowncast(248, value);\\n        }\\n        return uint248(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint240 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint240).\\n     *\\n     * Counterpart to Solidity's `uint240` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 240 bits\\n     */\\n    function toUint240(uint256 value) internal pure returns (uint240) {\\n        if (value > type(uint240).max) {\\n            revert SafeCastOverflowedUintDowncast(240, value);\\n        }\\n        return uint240(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint232 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint232).\\n     *\\n     * Counterpart to Solidity's `uint232` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 232 bits\\n     */\\n    function toUint232(uint256 value) internal pure returns (uint232) {\\n        if (value > type(uint232).max) {\\n            revert SafeCastOverflowedUintDowncast(232, value);\\n        }\\n        return uint232(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint224 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint224).\\n     *\\n     * Counterpart to Solidity's `uint224` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 224 bits\\n     */\\n    function toUint224(uint256 value) internal pure returns (uint224) {\\n        if (value > type(uint224).max) {\\n            revert SafeCastOverflowedUintDowncast(224, value);\\n        }\\n        return uint224(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint216 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint216).\\n     *\\n     * Counterpart to Solidity's `uint216` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 216 bits\\n     */\\n    function toUint216(uint256 value) internal pure returns (uint216) {\\n        if (value > type(uint216).max) {\\n            revert SafeCastOverflowedUintDowncast(216, value);\\n        }\\n        return uint216(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint208 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint208).\\n     *\\n     * Counterpart to Solidity's `uint208` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 208 bits\\n     */\\n    function toUint208(uint256 value) internal pure returns (uint208) {\\n        if (value > type(uint208).max) {\\n            revert SafeCastOverflowedUintDowncast(208, value);\\n        }\\n        return uint208(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint200 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint200).\\n     *\\n     * Counterpart to Solidity's `uint200` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 200 bits\\n     */\\n    function toUint200(uint256 value) internal pure returns (uint200) {\\n        if (value > type(uint200).max) {\\n            revert SafeCastOverflowedUintDowncast(200, value);\\n        }\\n        return uint200(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint192 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint192).\\n     *\\n     * Counterpart to Solidity's `uint192` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 192 bits\\n     */\\n    function toUint192(uint256 value) internal pure returns (uint192) {\\n        if (value > type(uint192).max) {\\n            revert SafeCastOverflowedUintDowncast(192, value);\\n        }\\n        return uint192(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint184 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint184).\\n     *\\n     * Counterpart to Solidity's `uint184` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 184 bits\\n     */\\n    function toUint184(uint256 value) internal pure returns (uint184) {\\n        if (value > type(uint184).max) {\\n            revert SafeCastOverflowedUintDowncast(184, value);\\n        }\\n        return uint184(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint176 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint176).\\n     *\\n     * Counterpart to Solidity's `uint176` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 176 bits\\n     */\\n    function toUint176(uint256 value) internal pure returns (uint176) {\\n        if (value > type(uint176).max) {\\n            revert SafeCastOverflowedUintDowncast(176, value);\\n        }\\n        return uint176(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint168 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint168).\\n     *\\n     * Counterpart to Solidity's `uint168` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 168 bits\\n     */\\n    function toUint168(uint256 value) internal pure returns (uint168) {\\n        if (value > type(uint168).max) {\\n            revert SafeCastOverflowedUintDowncast(168, value);\\n        }\\n        return uint168(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint160 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint160).\\n     *\\n     * Counterpart to Solidity's `uint160` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 160 bits\\n     */\\n    function toUint160(uint256 value) internal pure returns (uint160) {\\n        if (value > type(uint160).max) {\\n            revert SafeCastOverflowedUintDowncast(160, value);\\n        }\\n        return uint160(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint152 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint152).\\n     *\\n     * Counterpart to Solidity's `uint152` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 152 bits\\n     */\\n    function toUint152(uint256 value) internal pure returns (uint152) {\\n        if (value > type(uint152).max) {\\n            revert SafeCastOverflowedUintDowncast(152, value);\\n        }\\n        return uint152(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint144 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint144).\\n     *\\n     * Counterpart to Solidity's `uint144` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 144 bits\\n     */\\n    function toUint144(uint256 value) internal pure returns (uint144) {\\n        if (value > type(uint144).max) {\\n            revert SafeCastOverflowedUintDowncast(144, value);\\n        }\\n        return uint144(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint136 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint136).\\n     *\\n     * Counterpart to Solidity's `uint136` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 136 bits\\n     */\\n    function toUint136(uint256 value) internal pure returns (uint136) {\\n        if (value > type(uint136).max) {\\n            revert SafeCastOverflowedUintDowncast(136, value);\\n        }\\n        return uint136(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint128 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint128).\\n     *\\n     * Counterpart to Solidity's `uint128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     */\\n    function toUint128(uint256 value) internal pure returns (uint128) {\\n        if (value > type(uint128).max) {\\n            revert SafeCastOverflowedUintDowncast(128, value);\\n        }\\n        return uint128(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint120 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint120).\\n     *\\n     * Counterpart to Solidity's `uint120` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 120 bits\\n     */\\n    function toUint120(uint256 value) internal pure returns (uint120) {\\n        if (value > type(uint120).max) {\\n            revert SafeCastOverflowedUintDowncast(120, value);\\n        }\\n        return uint120(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint112 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint112).\\n     *\\n     * Counterpart to Solidity's `uint112` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 112 bits\\n     */\\n    function toUint112(uint256 value) internal pure returns (uint112) {\\n        if (value > type(uint112).max) {\\n            revert SafeCastOverflowedUintDowncast(112, value);\\n        }\\n        return uint112(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint104 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint104).\\n     *\\n     * Counterpart to Solidity's `uint104` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 104 bits\\n     */\\n    function toUint104(uint256 value) internal pure returns (uint104) {\\n        if (value > type(uint104).max) {\\n            revert SafeCastOverflowedUintDowncast(104, value);\\n        }\\n        return uint104(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint96 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint96).\\n     *\\n     * Counterpart to Solidity's `uint96` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 96 bits\\n     */\\n    function toUint96(uint256 value) internal pure returns (uint96) {\\n        if (value > type(uint96).max) {\\n            revert SafeCastOverflowedUintDowncast(96, value);\\n        }\\n        return uint96(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint88 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint88).\\n     *\\n     * Counterpart to Solidity's `uint88` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 88 bits\\n     */\\n    function toUint88(uint256 value) internal pure returns (uint88) {\\n        if (value > type(uint88).max) {\\n            revert SafeCastOverflowedUintDowncast(88, value);\\n        }\\n        return uint88(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint80 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint80).\\n     *\\n     * Counterpart to Solidity's `uint80` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 80 bits\\n     */\\n    function toUint80(uint256 value) internal pure returns (uint80) {\\n        if (value > type(uint80).max) {\\n            revert SafeCastOverflowedUintDowncast(80, value);\\n        }\\n        return uint80(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint72 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint72).\\n     *\\n     * Counterpart to Solidity's `uint72` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 72 bits\\n     */\\n    function toUint72(uint256 value) internal pure returns (uint72) {\\n        if (value > type(uint72).max) {\\n            revert SafeCastOverflowedUintDowncast(72, value);\\n        }\\n        return uint72(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint64 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint64).\\n     *\\n     * Counterpart to Solidity's `uint64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     */\\n    function toUint64(uint256 value) internal pure returns (uint64) {\\n        if (value > type(uint64).max) {\\n            revert SafeCastOverflowedUintDowncast(64, value);\\n        }\\n        return uint64(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint56 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint56).\\n     *\\n     * Counterpart to Solidity's `uint56` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 56 bits\\n     */\\n    function toUint56(uint256 value) internal pure returns (uint56) {\\n        if (value > type(uint56).max) {\\n            revert SafeCastOverflowedUintDowncast(56, value);\\n        }\\n        return uint56(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint48 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint48).\\n     *\\n     * Counterpart to Solidity's `uint48` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 48 bits\\n     */\\n    function toUint48(uint256 value) internal pure returns (uint48) {\\n        if (value > type(uint48).max) {\\n            revert SafeCastOverflowedUintDowncast(48, value);\\n        }\\n        return uint48(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint40 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint40).\\n     *\\n     * Counterpart to Solidity's `uint40` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 40 bits\\n     */\\n    function toUint40(uint256 value) internal pure returns (uint40) {\\n        if (value > type(uint40).max) {\\n            revert SafeCastOverflowedUintDowncast(40, value);\\n        }\\n        return uint40(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint32 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint32).\\n     *\\n     * Counterpart to Solidity's `uint32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     */\\n    function toUint32(uint256 value) internal pure returns (uint32) {\\n        if (value > type(uint32).max) {\\n            revert SafeCastOverflowedUintDowncast(32, value);\\n        }\\n        return uint32(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint24 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint24).\\n     *\\n     * Counterpart to Solidity's `uint24` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 24 bits\\n     */\\n    function toUint24(uint256 value) internal pure returns (uint24) {\\n        if (value > type(uint24).max) {\\n            revert SafeCastOverflowedUintDowncast(24, value);\\n        }\\n        return uint24(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint16 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint16).\\n     *\\n     * Counterpart to Solidity's `uint16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     */\\n    function toUint16(uint256 value) internal pure returns (uint16) {\\n        if (value > type(uint16).max) {\\n            revert SafeCastOverflowedUintDowncast(16, value);\\n        }\\n        return uint16(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint8 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint8).\\n     *\\n     * Counterpart to Solidity's `uint8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits\\n     */\\n    function toUint8(uint256 value) internal pure returns (uint8) {\\n        if (value > type(uint8).max) {\\n            revert SafeCastOverflowedUintDowncast(8, value);\\n        }\\n        return uint8(value);\\n    }\\n\\n    /**\\n     * @dev Converts a signed int256 into an unsigned uint256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be greater than or equal to 0.\\n     */\\n    function toUint256(int256 value) internal pure returns (uint256) {\\n        if (value < 0) {\\n            revert SafeCastOverflowedIntToUint(value);\\n        }\\n        return uint256(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int248 from int256, reverting on\\n     * overflow (when the input is less than smallest int248 or\\n     * greater than largest int248).\\n     *\\n     * Counterpart to Solidity's `int248` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 248 bits\\n     */\\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\\n        downcasted = int248(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(248, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int240 from int256, reverting on\\n     * overflow (when the input is less than smallest int240 or\\n     * greater than largest int240).\\n     *\\n     * Counterpart to Solidity's `int240` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 240 bits\\n     */\\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\\n        downcasted = int240(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(240, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int232 from int256, reverting on\\n     * overflow (when the input is less than smallest int232 or\\n     * greater than largest int232).\\n     *\\n     * Counterpart to Solidity's `int232` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 232 bits\\n     */\\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\\n        downcasted = int232(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(232, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int224 from int256, reverting on\\n     * overflow (when the input is less than smallest int224 or\\n     * greater than largest int224).\\n     *\\n     * Counterpart to Solidity's `int224` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 224 bits\\n     */\\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\\n        downcasted = int224(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(224, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int216 from int256, reverting on\\n     * overflow (when the input is less than smallest int216 or\\n     * greater than largest int216).\\n     *\\n     * Counterpart to Solidity's `int216` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 216 bits\\n     */\\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\\n        downcasted = int216(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(216, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int208 from int256, reverting on\\n     * overflow (when the input is less than smallest int208 or\\n     * greater than largest int208).\\n     *\\n     * Counterpart to Solidity's `int208` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 208 bits\\n     */\\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\\n        downcasted = int208(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(208, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int200 from int256, reverting on\\n     * overflow (when the input is less than smallest int200 or\\n     * greater than largest int200).\\n     *\\n     * Counterpart to Solidity's `int200` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 200 bits\\n     */\\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\\n        downcasted = int200(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(200, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int192 from int256, reverting on\\n     * overflow (when the input is less than smallest int192 or\\n     * greater than largest int192).\\n     *\\n     * Counterpart to Solidity's `int192` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 192 bits\\n     */\\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\\n        downcasted = int192(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(192, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int184 from int256, reverting on\\n     * overflow (when the input is less than smallest int184 or\\n     * greater than largest int184).\\n     *\\n     * Counterpart to Solidity's `int184` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 184 bits\\n     */\\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\\n        downcasted = int184(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(184, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int176 from int256, reverting on\\n     * overflow (when the input is less than smallest int176 or\\n     * greater than largest int176).\\n     *\\n     * Counterpart to Solidity's `int176` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 176 bits\\n     */\\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\\n        downcasted = int176(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(176, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int168 from int256, reverting on\\n     * overflow (when the input is less than smallest int168 or\\n     * greater than largest int168).\\n     *\\n     * Counterpart to Solidity's `int168` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 168 bits\\n     */\\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\\n        downcasted = int168(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(168, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int160 from int256, reverting on\\n     * overflow (when the input is less than smallest int160 or\\n     * greater than largest int160).\\n     *\\n     * Counterpart to Solidity's `int160` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 160 bits\\n     */\\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\\n        downcasted = int160(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(160, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int152 from int256, reverting on\\n     * overflow (when the input is less than smallest int152 or\\n     * greater than largest int152).\\n     *\\n     * Counterpart to Solidity's `int152` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 152 bits\\n     */\\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\\n        downcasted = int152(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(152, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int144 from int256, reverting on\\n     * overflow (when the input is less than smallest int144 or\\n     * greater than largest int144).\\n     *\\n     * Counterpart to Solidity's `int144` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 144 bits\\n     */\\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\\n        downcasted = int144(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(144, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int136 from int256, reverting on\\n     * overflow (when the input is less than smallest int136 or\\n     * greater than largest int136).\\n     *\\n     * Counterpart to Solidity's `int136` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 136 bits\\n     */\\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\\n        downcasted = int136(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(136, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int128 from int256, reverting on\\n     * overflow (when the input is less than smallest int128 or\\n     * greater than largest int128).\\n     *\\n     * Counterpart to Solidity's `int128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     */\\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\\n        downcasted = int128(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(128, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int120 from int256, reverting on\\n     * overflow (when the input is less than smallest int120 or\\n     * greater than largest int120).\\n     *\\n     * Counterpart to Solidity's `int120` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 120 bits\\n     */\\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\\n        downcasted = int120(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(120, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int112 from int256, reverting on\\n     * overflow (when the input is less than smallest int112 or\\n     * greater than largest int112).\\n     *\\n     * Counterpart to Solidity's `int112` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 112 bits\\n     */\\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\\n        downcasted = int112(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(112, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int104 from int256, reverting on\\n     * overflow (when the input is less than smallest int104 or\\n     * greater than largest int104).\\n     *\\n     * Counterpart to Solidity's `int104` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 104 bits\\n     */\\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\\n        downcasted = int104(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(104, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int96 from int256, reverting on\\n     * overflow (when the input is less than smallest int96 or\\n     * greater than largest int96).\\n     *\\n     * Counterpart to Solidity's `int96` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 96 bits\\n     */\\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\\n        downcasted = int96(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(96, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int88 from int256, reverting on\\n     * overflow (when the input is less than smallest int88 or\\n     * greater than largest int88).\\n     *\\n     * Counterpart to Solidity's `int88` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 88 bits\\n     */\\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\\n        downcasted = int88(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(88, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int80 from int256, reverting on\\n     * overflow (when the input is less than smallest int80 or\\n     * greater than largest int80).\\n     *\\n     * Counterpart to Solidity's `int80` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 80 bits\\n     */\\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\\n        downcasted = int80(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(80, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int72 from int256, reverting on\\n     * overflow (when the input is less than smallest int72 or\\n     * greater than largest int72).\\n     *\\n     * Counterpart to Solidity's `int72` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 72 bits\\n     */\\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\\n        downcasted = int72(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(72, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int64 from int256, reverting on\\n     * overflow (when the input is less than smallest int64 or\\n     * greater than largest int64).\\n     *\\n     * Counterpart to Solidity's `int64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     */\\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\\n        downcasted = int64(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(64, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int56 from int256, reverting on\\n     * overflow (when the input is less than smallest int56 or\\n     * greater than largest int56).\\n     *\\n     * Counterpart to Solidity's `int56` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 56 bits\\n     */\\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\\n        downcasted = int56(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(56, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int48 from int256, reverting on\\n     * overflow (when the input is less than smallest int48 or\\n     * greater than largest int48).\\n     *\\n     * Counterpart to Solidity's `int48` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 48 bits\\n     */\\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\\n        downcasted = int48(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(48, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int40 from int256, reverting on\\n     * overflow (when the input is less than smallest int40 or\\n     * greater than largest int40).\\n     *\\n     * Counterpart to Solidity's `int40` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 40 bits\\n     */\\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\\n        downcasted = int40(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(40, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int32 from int256, reverting on\\n     * overflow (when the input is less than smallest int32 or\\n     * greater than largest int32).\\n     *\\n     * Counterpart to Solidity's `int32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     */\\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\\n        downcasted = int32(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(32, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int24 from int256, reverting on\\n     * overflow (when the input is less than smallest int24 or\\n     * greater than largest int24).\\n     *\\n     * Counterpart to Solidity's `int24` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 24 bits\\n     */\\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\\n        downcasted = int24(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(24, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int16 from int256, reverting on\\n     * overflow (when the input is less than smallest int16 or\\n     * greater than largest int16).\\n     *\\n     * Counterpart to Solidity's `int16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     */\\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\\n        downcasted = int16(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(16, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int8 from int256, reverting on\\n     * overflow (when the input is less than smallest int8 or\\n     * greater than largest int8).\\n     *\\n     * Counterpart to Solidity's `int8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits\\n     */\\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\\n        downcasted = int8(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(8, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts an unsigned uint256 into a signed int256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be less than or equal to maxInt256.\\n     */\\n    function toInt256(uint256 value) internal pure returns (int256) {\\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\\n        if (value > uint256(type(int256).max)) {\\n            revert SafeCastOverflowedUintToInt(value);\\n        }\\n        return int256(value);\\n    }\\n}\\n\",\"keccak256\":\"0xe19a4d5f31d2861e7344e8e535e2feafb913d806d3e2b5fe7782741a2a7094fe\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/math/SignedMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SignedMath.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Standard signed math utilities missing in the Solidity language.\\n */\\nlibrary SignedMath {\\n    /**\\n     * @dev Returns the largest of two signed numbers.\\n     */\\n    function max(int256 a, int256 b) internal pure returns (int256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two signed numbers.\\n     */\\n    function min(int256 a, int256 b) internal pure returns (int256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two signed numbers without overflow.\\n     * The result is rounded towards zero.\\n     */\\n    function average(int256 a, int256 b) internal pure returns (int256) {\\n        // Formula from the book \\\"Hacker's Delight\\\"\\n        int256 x = (a & b) + ((a ^ b) >> 1);\\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\\n    }\\n\\n    /**\\n     * @dev Returns the absolute unsigned value of a signed value.\\n     */\\n    function abs(int256 n) internal pure returns (uint256) {\\n        unchecked {\\n            // must be unchecked in order to support `n = type(int256).min`\\n            return uint256(n >= 0 ? n : -n);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x5f7e4076e175393767754387c962926577f1660dd9b810187b9002407656be72\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/types/Time.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/types/Time.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {Math} from \\\"../math/Math.sol\\\";\\nimport {SafeCast} from \\\"../math/SafeCast.sol\\\";\\n\\n/**\\n * @dev This library provides helpers for manipulating time-related objects.\\n *\\n * It uses the following types:\\n * - `uint48` for timepoints\\n * - `uint32` for durations\\n *\\n * While the library doesn't provide specific types for timepoints and duration, it does provide:\\n * - a `Delay` type to represent duration that can be programmed to change value automatically at a given point\\n * - additional helper functions\\n */\\nlibrary Time {\\n    using Time for *;\\n\\n    /**\\n     * @dev Get the block timestamp as a Timepoint.\\n     */\\n    function timestamp() internal view returns (uint48) {\\n        return SafeCast.toUint48(block.timestamp);\\n    }\\n\\n    /**\\n     * @dev Get the block number as a Timepoint.\\n     */\\n    function blockNumber() internal view returns (uint48) {\\n        return SafeCast.toUint48(block.number);\\n    }\\n\\n    // ==================================================== Delay =====================================================\\n    /**\\n     * @dev A `Delay` is a uint32 duration that can be programmed to change value automatically at a given point in the\\n     * future. The \\\"effect\\\" timepoint describes when the transitions happens from the \\\"old\\\" value to the \\\"new\\\" value.\\n     * This allows updating the delay applied to some operation while keeping some guarantees.\\n     *\\n     * In particular, the {update} function guarantees that if the delay is reduced, the old delay still applies for\\n     * some time. For example if the delay is currently 7 days to do an upgrade, the admin should not be able to set\\n     * the delay to 0 and upgrade immediately. If the admin wants to reduce the delay, the old delay (7 days) should\\n     * still apply for some time.\\n     *\\n     *\\n     * The `Delay` type is 112 bits long, and packs the following:\\n     *\\n     * ```\\n     *   | [uint48]: effect date (timepoint)\\n     *   |           | [uint32]: value before (duration)\\n     *   \\u2193           \\u2193       \\u2193 [uint32]: value after (duration)\\n     * 0xAAAAAAAAAAAABBBBBBBBCCCCCCCC\\n     * ```\\n     *\\n     * NOTE: The {get} and {withUpdate} functions operate using timestamps. Block number based delays are not currently\\n     * supported.\\n     */\\n    type Delay is uint112;\\n\\n    /**\\n     * @dev Wrap a duration into a Delay to add the one-step \\\"update in the future\\\" feature\\n     */\\n    function toDelay(uint32 duration) internal pure returns (Delay) {\\n        return Delay.wrap(duration);\\n    }\\n\\n    /**\\n     * @dev Get the value at a given timepoint plus the pending value and effect timepoint if there is a scheduled\\n     * change after this timepoint. If the effect timepoint is 0, then the pending value should not be considered.\\n     */\\n    function _getFullAt(Delay self, uint48 timepoint) private pure returns (uint32, uint32, uint48) {\\n        (uint32 valueBefore, uint32 valueAfter, uint48 effect) = self.unpack();\\n        return effect <= timepoint ? (valueAfter, 0, 0) : (valueBefore, valueAfter, effect);\\n    }\\n\\n    /**\\n     * @dev Get the current value plus the pending value and effect timepoint if there is a scheduled change. If the\\n     * effect timepoint is 0, then the pending value should not be considered.\\n     */\\n    function getFull(Delay self) internal view returns (uint32, uint32, uint48) {\\n        return _getFullAt(self, timestamp());\\n    }\\n\\n    /**\\n     * @dev Get the current value.\\n     */\\n    function get(Delay self) internal view returns (uint32) {\\n        (uint32 delay, , ) = self.getFull();\\n        return delay;\\n    }\\n\\n    /**\\n     * @dev Update a Delay object so that it takes a new duration after a timepoint that is automatically computed to\\n     * enforce the old delay at the moment of the update. Returns the updated Delay object and the timestamp when the\\n     * new delay becomes effective.\\n     */\\n    function withUpdate(\\n        Delay self,\\n        uint32 newValue,\\n        uint32 minSetback\\n    ) internal view returns (Delay updatedDelay, uint48 effect) {\\n        uint32 value = self.get();\\n        uint32 setback = uint32(Math.max(minSetback, value > newValue ? value - newValue : 0));\\n        effect = timestamp() + setback;\\n        return (pack(value, newValue, effect), effect);\\n    }\\n\\n    /**\\n     * @dev Split a delay into its components: valueBefore, valueAfter and effect (transition timepoint).\\n     */\\n    function unpack(Delay self) internal pure returns (uint32 valueBefore, uint32 valueAfter, uint48 effect) {\\n        uint112 raw = Delay.unwrap(self);\\n\\n        valueAfter = uint32(raw);\\n        valueBefore = uint32(raw >> 32);\\n        effect = uint48(raw >> 64);\\n\\n        return (valueBefore, valueAfter, effect);\\n    }\\n\\n    /**\\n     * @dev pack the components into a Delay object.\\n     */\\n    function pack(uint32 valueBefore, uint32 valueAfter, uint48 effect) internal pure returns (Delay) {\\n        return Delay.wrap((uint112(effect) << 64) | (uint112(valueBefore) << 32) | uint112(valueAfter));\\n    }\\n}\\n\",\"keccak256\":\"0xc7755af115020049e4140f224f9ee88d7e1799ffb0646f37bf0df24bf6213f58\",\"license\":\"MIT\"},\"@story-protocol/protocol-core/contracts/interfaces/IIPAccount.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.23;\\n\\nimport { IERC721Receiver } from \\\"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\\\";\\nimport { IERC1155Receiver } from \\\"@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\\\";\\nimport { IERC6551Account } from \\\"erc6551/interfaces/IERC6551Account.sol\\\";\\nimport { IIPAccountStorage } from \\\"./IIPAccountStorage.sol\\\";\\n\\n/// @title IIPAccount\\n/// @dev IPAccount is a token-bound account that adopts the EIP-6551 standard.\\n/// These accounts are deployed at deterministic addresses through the official 6551 account registry.\\n/// As a deployed smart contract, IPAccount can store IP-related information,\\n/// like ownership of other NFTs such as license NFT or Royalty NFT.\\n/// IPAccount can interact with modules by making calls as a normal transaction sender.\\n/// This allows for seamless operations on the state and data of IP.\\n/// IPAccount is core identity for all actions.\\ninterface IIPAccount is IERC6551Account, IERC721Receiver, IERC1155Receiver, IIPAccountStorage {\\n    /// @notice Emitted when a transaction is executed.\\n    /// @param to The recipient of the transaction.\\n    /// @param value The amount of Ether sent.\\n    /// @param data The data sent along with the transaction.\\n    /// @param nonce The nonce of the transaction.\\n    event Executed(address indexed to, uint256 value, bytes data, uint256 nonce);\\n\\n    /// @notice Emitted when a transaction is executed on behalf of the signer.\\n    /// @param to The recipient of the transaction.\\n    /// @param value The amount of Ether sent.\\n    /// @param data The data sent along with the transaction.\\n    /// @param nonce The nonce of the transaction.\\n    /// @param deadline The deadline of the transaction signature.\\n    /// @param signer The signer of the transaction.\\n    /// @param signature The signature of the transaction, EIP-712 encoded.\\n    event ExecutedWithSig(\\n        address indexed to,\\n        uint256 value,\\n        bytes data,\\n        uint256 nonce,\\n        uint256 deadline,\\n        address indexed signer,\\n        bytes signature\\n    );\\n\\n    /// @notice Returns the IPAccount's internal nonce for transaction ordering.\\n    function state() external view returns (uint256);\\n\\n    /// @notice Returns the identifier of the non-fungible token which owns the account\\n    /// @return chainId The EIP-155 ID of the chain the token exists on\\n    /// @return tokenContract The contract address of the token\\n    /// @return tokenId The ID of the token\\n    function token() external view returns (uint256, address, uint256);\\n\\n    /// @notice Checks if the signer is valid for the given data\\n    /// @param signer The signer to check\\n    /// @param data The data to check against\\n    /// @return The function selector if the signer is valid, 0 otherwise\\n    function isValidSigner(address signer, bytes calldata data) external view returns (bytes4);\\n\\n    /// @notice Returns the owner of the IP Account.\\n    /// @return owner The address of the owner.\\n    function owner() external view returns (address);\\n\\n    /// @notice Executes a transaction from the IP Account on behalf of the signer.\\n    /// @param to The recipient of the transaction.\\n    /// @param value The amount of Ether to send.\\n    /// @param data The data to send along with the transaction.\\n    /// @param signer The signer of the transaction.\\n    /// @param deadline The deadline of the transaction signature.\\n    /// @param signature The signature of the transaction, EIP-712 encoded.\\n    /// @return result The return data from the transaction.\\n    function executeWithSig(\\n        address to,\\n        uint256 value,\\n        bytes calldata data,\\n        address signer,\\n        uint256 deadline,\\n        bytes calldata signature\\n    ) external payable returns (bytes memory);\\n\\n    /// @notice Executes a transaction from the IP Account.\\n    /// @param to The recipient of the transaction.\\n    /// @param value The amount of Ether to send.\\n    /// @param data The data to send along with the transaction.\\n    /// @return result The return data from the transaction.\\n    function execute(address to, uint256 value, bytes calldata data) external payable returns (bytes memory);\\n}\\n\",\"keccak256\":\"0x6b4b6fbedebe4da10a346aeeb027ed3dc2d4953578ded7bd53d391440fb79926\",\"license\":\"BUSL-1.1\"},\"@story-protocol/protocol-core/contracts/interfaces/IIPAccountStorage.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\n// See https://github.com/storyprotocol/protocol-contracts/blob/main/StoryProtocol-AlphaTestingAgreement-17942166.3.pdf\\npragma solidity ^0.8.23;\\n\\n/// @title IPAccount Namespaced Storage Interface\\n/// @dev Provides a structured way to store IPAccount's state using a namespaced storage pattern.\\n/// This interface facilitates conflict-free data writing by different Modules into the same IPAccount\\n/// by utilizing namespaces.\\n/// The default namespace for write operations is determined by the `msg.sender`, ensuring that only the owning Module\\n/// (i.e., the Module calling the write functions) can write data into its respective namespace.\\n/// However, read operations are unrestricted and can access any namespace.\\n///\\n/// Rules:\\n/// - The default namespace for a Module is its own address.\\n/// - Every Module can read data from any namespace.\\n/// - Only the owning Module (i.e., the Module whose address is used as the namespace) can write data into\\n///   its respective namespace.\\ninterface IIPAccountStorage {\\n    /// @dev Sets a bytes value under a given key within the default namespace, determined by `msg.sender`.\\n    /// @param key The key under which to store the value.\\n    /// @param value The bytes value to be stored.\\n    function setBytes(bytes32 key, bytes calldata value) external;\\n\\n    /// @dev Retrieves a bytes value by a given key from the default namespace.\\n    /// @param key The key whose value is to be retrieved.\\n    /// @return The bytes value stored under the specified key.\\n    function getBytes(bytes32 key) external view returns (bytes memory);\\n\\n    /// @dev Retrieves a bytes value by a given key from a specified namespace.\\n    /// @param namespace The namespace from which to retrieve the value.\\n    /// @param key The key whose value is to be retrieved.\\n    /// @return The bytes value stored under the specified key in the given namespace.\\n    function getBytes(bytes32 namespace, bytes32 key) external view returns (bytes memory);\\n\\n    /// @dev Sets a bytes32 value under a given key within the default namespace, determined by `msg.sender`.\\n    /// @param key The key under which to store the value.\\n    /// @param value The bytes32 value to be stored.\\n    function setBytes32(bytes32 key, bytes32 value) external;\\n\\n    /// @dev Retrieves a bytes32 value by a given key from the default namespace.\\n    /// @param key The key whose value is to be retrieved.\\n    /// @return The bytes32 value stored under the specified key.\\n    function getBytes32(bytes32 key) external view returns (bytes32);\\n\\n    /// @dev Retrieves a bytes32 value by a given key from a specified namespace.\\n    /// @param namespace The namespace from which to retrieve the value.\\n    /// @param key The key whose value is to be retrieved.\\n    /// @return The bytes32 value stored under the specified key in the given namespace.\\n    function getBytes32(bytes32 namespace, bytes32 key) external view returns (bytes32);\\n}\\n\",\"keccak256\":\"0x002356819552d10fda363237ace488b948af1304883d834c0abcaa52dd0ab903\",\"license\":\"UNLICENSED\"},\"@story-protocol/protocol-core/contracts/interfaces/registries/IIPAccountRegistry.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.23;\\n\\n/// @title Interface for IP Account Registry\\n/// @notice This interface manages the registration and tracking of IP Accounts\\ninterface IIPAccountRegistry {\\n    /// @notice Event emitted when a new IP Account is created\\n    /// @param account The address of the new IP Account\\n    /// @param implementation The address of the IP Account implementation\\n    /// @param chainId The chain ID where the token contract was deployed\\n    /// @param tokenContract The address of the token contract associated with the IP Account\\n    /// @param tokenId The ID of the token associated with the IP Account\\n    event IPAccountRegistered(\\n        address indexed account,\\n        address indexed implementation,\\n        uint256 indexed chainId,\\n        address tokenContract,\\n        uint256 tokenId\\n    );\\n\\n    /// @notice Returns the IPAccount implementation address\\n    function IP_ACCOUNT_IMPL() external view returns (address);\\n\\n    /// @notice Returns the IPAccount salt\\n    function IP_ACCOUNT_SALT() external view returns (bytes32);\\n\\n    /// @notice Returns the public ERC6551 registry address\\n    function ERC6551_PUBLIC_REGISTRY() external view returns (address);\\n\\n    /// @notice Deploys an IPAccount contract with the IPAccount implementation and returns the address of the new IP\\n    /// @dev The IPAccount deployment deltegates to public ERC6551 Registry\\n    /// @param chainId The chain ID where the IP Account will be created\\n    /// @param tokenContract The address of the token contract to be associated with the IP Account\\n    /// @param tokenId The ID of the token to be associated with the IP Account\\n    /// @return ipAccountAddress The address of the newly created IP Account\\n    function registerIpAccount(uint256 chainId, address tokenContract, uint256 tokenId) external returns (address);\\n\\n    /// @notice Returns the IPAccount address for the given NFT token.\\n    /// @param chainId The chain ID where the IP Account is located\\n    /// @param tokenContract The address of the token contract associated with the IP Account\\n    /// @param tokenId The ID of the token associated with the IP Account\\n    /// @return ipAccountAddress The address of the IP Account associated with the given NFT token\\n    function ipAccount(uint256 chainId, address tokenContract, uint256 tokenId) external view returns (address);\\n\\n    /// @notice Returns the IPAccount implementation address.\\n    /// @return The address of the IPAccount implementation\\n    function getIPAccountImpl() external view returns (address);\\n}\\n\",\"keccak256\":\"0x68aa5cbaebd58ffc2411222abb47eb57ddd13aba07bff13c6b4e4a737e7c37fe\",\"license\":\"BUSL-1.1\"},\"@story-protocol/protocol-core/contracts/interfaces/registries/IIPAssetRegistry.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.23;\\n\\nimport { IIPAccountRegistry } from \\\"./IIPAccountRegistry.sol\\\";\\n\\n/// @title Interface for IP Account Registry\\n/// @notice This interface manages the registration and tracking of IP Accounts\\ninterface IIPAssetRegistry is IIPAccountRegistry {\\n    /// @notice Emits when an IP is officially registered into the protocol.\\n    /// @param ipId The canonical identifier for the IP.\\n    /// @param chainId The chain identifier of where the IP resides.\\n    /// @param tokenContract The token contract address of the IP NFT.\\n    /// @param tokenId The token identifier of the IP.\\n    /// @param name The name of the IP.\\n    /// @param uri The URI of the IP.\\n    /// @param registrationDate The date and time the IP was registered.\\n    event IPRegistered(\\n        address ipId,\\n        uint256 indexed chainId,\\n        address indexed tokenContract,\\n        uint256 indexed tokenId,\\n        string name,\\n        string uri,\\n        uint256 registrationDate\\n    );\\n\\n    /// @notice Tracks the total number of IP assets in existence.\\n    function totalSupply() external view returns (uint256);\\n\\n    /// @notice Registers an NFT as an IP asset.\\n    /// @param chainid The chain identifier of where the IP NFT resides.\\n    /// @param tokenContract The address of the NFT.\\n    /// @param tokenId The token identifier of the NFT.\\n    /// @return id The address of the newly registered IP.\\n    function register(uint256 chainid, address tokenContract, uint256 tokenId) external returns (address id);\\n\\n    /// @notice Gets the canonical IP identifier associated with an IP NFT.\\n    /// @dev This is equivalent to the address of its bound IP account.\\n    /// @param chainId The chain identifier of where the IP resides.\\n    /// @param tokenContract The address of the IP.\\n    /// @param tokenId The token identifier of the IP.\\n    /// @return ipId The IP's canonical address identifier.\\n    function ipId(uint256 chainId, address tokenContract, uint256 tokenId) external view returns (address);\\n\\n    /// @notice Checks whether an IP was registered based on its ID.\\n    /// @param id The canonical identifier for the IP.\\n    /// @return isRegistered Whether the IP was registered into the protocol.\\n    function isRegistered(address id) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x908667d5f302aa50635cbabe47d04b20054c338a9995529dffb719de43c35e43\",\"license\":\"BUSL-1.1\"},\"@story-protocol/protocol-core/contracts/lib/Errors.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.23;\\n\\n/// @title Errors Library\\n/// @notice Library for all Story Protocol contract errors.\\nlibrary Errors {\\n    ////////////////////////////////////////////////////////////////////////////\\n    //                                IP Account                              //\\n    ////////////////////////////////////////////////////////////////////////////\\n\\n    /// @notice Zero address provided for Access Controller.\\n    error IPAccount__ZeroAccessController();\\n\\n    /// @notice Invalid signer provided.\\n    error IPAccount__InvalidSigner();\\n\\n    /// @notice Invalid signature provided, must be an EIP-712 signature.\\n    error IPAccount__InvalidSignature();\\n\\n    /// @notice Signature is expired.\\n    error IPAccount__ExpiredSignature();\\n\\n    /// @notice Provided calldata is invalid.\\n    error IPAccount__InvalidCalldata();\\n\\n    ////////////////////////////////////////////////////////////////////////////\\n    //                            IP Account Storage                          //\\n    ////////////////////////////////////////////////////////////////////////////\\n\\n    /// @notice Caller writing to IP Account storage is not a registered module.\\n    error IPAccountStorage__NotRegisteredModule(address module);\\n\\n    ////////////////////////////////////////////////////////////////////////////\\n    //                           IP Account Registry                          //\\n    ////////////////////////////////////////////////////////////////////////////\\n\\n    /// @notice Zero address provided for IP Account implementation.\\n    error IPAccountRegistry_ZeroIpAccountImpl();\\n\\n    ////////////////////////////////////////////////////////////////////////////\\n    //                            IP Asset Registry                           //\\n    ////////////////////////////////////////////////////////////////////////////\\n\\n    /// @notice Zero address provided for Access Manager in initializer.\\n    error IPAssetRegistry__ZeroAccessManager();\\n\\n    /// @notice The IP asset has already been registered.\\n    error IPAssetRegistry__AlreadyRegistered();\\n\\n    /// @notice The NFT token contract is not valid ERC721 contract.\\n    error IPAssetRegistry__UnsupportedIERC721(address contractAddress);\\n\\n    /// @notice The NFT token contract does not support ERC721Metadata.\\n    error IPAssetRegistry__UnsupportedIERC721Metadata(address contractAddress);\\n\\n    /// @notice The NFT token id does not exist or invalid.\\n    error IPAssetRegistry__InvalidToken(address contractAddress, uint256 tokenId);\\n\\n    ////////////////////////////////////////////////////////////////////////////\\n    //                            License Registry                            //\\n    ////////////////////////////////////////////////////////////////////////////\\n\\n    /// @notice Zero address provided for Access Manager in initializer.\\n    error LicenseRegistry__ZeroAccessManager();\\n\\n    /// @notice Zero address provided for Licensing Module.\\n    error LicenseRegistry__ZeroLicensingModule();\\n\\n    /// @notice Zero address provided for Dispute Module.\\n    error LicenseRegistry__ZeroDisputeModule();\\n\\n    /// @notice Caller is not the Licensing Module.\\n    error LicenseRegistry__CallerNotLicensingModule();\\n\\n    /// @notice Emitted when trying to transfer a license that is not transferable (by policy)\\n    error LicenseRegistry__NotTransferable();\\n\\n    /// @notice License Template is not registered in the License Registry.\\n    error LicenseRegistry__UnregisteredLicenseTemplate(address licenseTemplate);\\n\\n    /// @notice License Terms or License Template not found.\\n    error LicenseRegistry__LicenseTermsNotExists(address licenseTemplate, uint256 licenseTermsId);\\n\\n    /// @notice Licensor IP does not have the provided license terms attached.\\n    error LicenseRegistry__LicensorIpHasNoLicenseTerms(address ipId, address licenseTemplate, uint256 licenseTermsId);\\n\\n    /// @notice Invalid License Template address provided.\\n    error LicenseRegistry__NotLicenseTemplate(address licenseTemplate);\\n\\n    /// @notice IP is expired.\\n    error LicenseRegistry__IpExpired(address ipId);\\n\\n    /// @notice Parent IP is expired.\\n    error LicenseRegistry__ParentIpExpired(address ipId);\\n\\n    /// @notice Parent IP is dispute tagged.\\n    error LicenseRegistry__ParentIpTagged(address ipId);\\n\\n    /// @notice Parent IP does not have the provided license terms attached.\\n    error LicenseRegistry__ParentIpHasNoLicenseTerms(address ipId, uint256 licenseTermsId);\\n\\n    /// @notice Empty Parent IP list provided.\\n    error LicenseRegistry__NoParentIp();\\n\\n    /// @notice Provided derivative IP already has license terms attached.\\n    error LicenseRegistry__DerivativeIpAlreadyHasLicense(address childIpId);\\n\\n    /// @notice Provided derivative IP is already registered.\\n    error LicenseRegistry__DerivativeAlreadyRegistered(address childIpId);\\n\\n    /// @notice Provided derivative IP is the same as the parent IP.\\n    error LicenseRegistry__DerivativeIsParent(address ipId);\\n\\n    /// @notice Provided license template does not match the parent IP's current license template.\\n    error LicenseRegistry__ParentIpUnmatchedLicenseTemplate(address ipId, address licenseTemplate);\\n\\n    /// @notice Index out of bounds.\\n    error LicenseRegistry__IndexOutOfBounds(address ipId, uint256 index, uint256 length);\\n\\n    /// @notice Provided license template and terms ID is already attached to IP.\\n    error LicenseRegistry__LicenseTermsAlreadyAttached(address ipId, address licenseTemplate, uint256 licenseTermsId);\\n\\n    /// @notice Provided license template does not match the IP's current license template.\\n    error LicenseRegistry__UnmatchedLicenseTemplate(address ipId, address licenseTemplate, address newLicenseTemplate);\\n\\n    /// @notice Provided license template and terms ID is a duplicate.\\n    error LicenseRegistry__DuplicateLicense(address ipId, address licenseTemplate, uint256 licenseTermsId);\\n\\n    ////////////////////////////////////////////////////////////////////////////\\n    //                             License Token                              //\\n    ////////////////////////////////////////////////////////////////////////////\\n\\n    /// @notice Zero address provided for Access Manager in initializer.\\n    error LicenseToken__ZeroAccessManager();\\n\\n    /// @notice Zero address provided for Licensing Module.\\n    error LicenseToken__ZeroLicensingModule();\\n\\n    /// @notice Zero address provided for Dispute Module.\\n    error LicenseToken__ZeroDisputeModule();\\n\\n    /// @notice Caller is not the Licensing Module.\\n    error LicenseToken__CallerNotLicensingModule();\\n\\n    /// @notice License token is revoked.\\n    error LicenseToken__RevokedLicense(uint256 tokenId);\\n\\n    /// @notice License token is not transferable.\\n    error LicenseToken__NotTransferable();\\n\\n    /// @notice License token is expired.\\n    error LicenseToken__LicenseTokenExpired(uint256 tokenId, uint256 expiredAt, uint256 currentTimestamp);\\n\\n    /// @notice License token is not owned by the caller.\\n    error LicenseToken__NotLicenseTokenOwner(uint256 tokenId, address iPowner, address tokenOwner);\\n\\n    /// @notice All license tokens must be from the same license template.\\n    error LicenseToken__AllLicenseTokensMustFromSameLicenseTemplate(\\n        address licenseTemplate,\\n        address anotherLicenseTemplate\\n    );\\n\\n    ////////////////////////////////////////////////////////////////////////////\\n    //                           Licensing Module                             //\\n    ////////////////////////////////////////////////////////////////////////////\\n\\n    /// @notice Zero address provided for Access Manager in initializer.\\n    error LicensingModule__ZeroAccessManager();\\n\\n    /// @notice Receiver is zero address.\\n    error LicensingModule__ReceiverZeroAddress();\\n\\n    /// @notice Mint amount is zero.\\n    error LicensingModule__MintAmountZero();\\n\\n    /// @notice IP is dispute tagged.\\n    error LicensingModule__DisputedIpId();\\n\\n    /// @notice License template and terms ID is not found.\\n    error LicensingModule__LicenseTermsNotFound(address licenseTemplate, uint256 licenseTermsId);\\n\\n    /// @notice Derivative IP cannot add license terms.\\n    error LicensingModule__DerivativesCannotAddLicenseTerms();\\n\\n    /// @notice Receiver check failed.\\n    error LicensingModule__ReceiverCheckFailed(address receiver);\\n\\n    /// @notice IP list and license terms list length mismatch.\\n    error LicensingModule__LicenseTermsLengthMismatch(uint256 ipLength, uint256 licenseTermsLength);\\n\\n    /// @notice Parent IP list is empty.\\n    error LicensingModule__NoParentIp();\\n\\n    /// @notice Incompatible royalty policy.\\n    error LicensingModule__IncompatibleRoyaltyPolicy(address royaltyPolicy, address anotherRoyaltyPolicy);\\n\\n    /// @notice License template and terms are not compatible for the derivative IP.\\n    error LicensingModule__LicenseNotCompatibleForDerivative(address childIpId);\\n\\n    /// @notice License token list is empty.\\n    error LicensingModule__NoLicenseToken();\\n\\n    /// @notice License tokens are not compatible for the derivative IP.\\n    error LicensingModule__LicenseTokenNotCompatibleForDerivative(address childIpId, uint256[] licenseTokenIds);\\n\\n    /// @notice License template denied minting license token during the verification stage.\\n    error LicensingModule__LicenseDenyMintLicenseToken(\\n        address licenseTemplate,\\n        uint256 licenseTermsId,\\n        address licensorIpId\\n    );\\n\\n    ////////////////////////////////////////////////////////////////////////////\\n    //                             Dispute Module                             //\\n    ////////////////////////////////////////////////////////////////////////////\\n\\n    /// @notice Zero address provided for Access Manager in initializer.\\n    error DisputeModule__ZeroAccessManager();\\n\\n    /// @notice Zero address provided for License Registry.\\n    error DisputeModule__ZeroLicenseRegistry();\\n\\n    /// @notice Zero address provided for IP Asset Registry.\\n    error DisputeModule__ZeroIPAssetRegistry();\\n\\n    /// @notice Zero address provided for Access Controller.\\n    error DisputeModule__ZeroAccessController();\\n\\n    /// @notice Zero address provided for Arbitration Policy.\\n    error DisputeModule__ZeroArbitrationPolicy();\\n\\n    /// @notice Zero address provided for Arbitration Relayer.\\n    error DisputeModule__ZeroArbitrationRelayer();\\n\\n    /// @notice Zero bytes provided for Dispute Tag.\\n    error DisputeModule__ZeroDisputeTag();\\n\\n    /// @notice Zero bytes provided for Dispute Evidence.\\n    error DisputeModule__ZeroLinkToDisputeEvidence();\\n\\n    /// @notice Not a whitelisted arbitration policy.\\n    error DisputeModule__NotWhitelistedArbitrationPolicy();\\n\\n    /// @notice Not a whitelisted arbitration relayer.\\n    error DisputeModule__NotWhitelistedArbitrationRelayer();\\n\\n    /// @notice Not a whitelisted dispute tag.\\n    error DisputeModule__NotWhitelistedDisputeTag();\\n\\n    /// @notice Not the dispute initiator.\\n    error DisputeModule__NotDisputeInitiator();\\n\\n    /// @notice Not in dispute state, the dispute is not IN_DISPUTE.\\n    error DisputeModule__NotInDisputeState();\\n\\n    /// @notice Not able to resolve a dispute, either the dispute is IN_DISPUTE or empty.\\n    error DisputeModule__NotAbleToResolve();\\n\\n    /// @notice Not a registered IP.\\n    error DisputeModule__NotRegisteredIpId();\\n\\n    /// @notice Provided parent IP and the parent dispute's target IP is different.\\n    error DisputeModule__ParentIpIdMismatch();\\n\\n    /// @notice Provided parent dispute's target IP is not dispute tagged.\\n    error DisputeModule__ParentNotTagged();\\n\\n    /// @notice Provided parent dispute's target IP is not the derivative IP's parent.\\n    error DisputeModule__NotDerivative();\\n\\n    /// @notice Provided parent dispute has not been resolved.\\n    error DisputeModule__ParentDisputeNotResolved();\\n\\n    ////////////////////////////////////////////////////////////////////////////\\n    //                         ArbitrationPolicy SP                          //\\n    ////////////////////////////////////////////////////////////////////////////\\n\\n    /// @notice Zero address provided for Access Manager in initializer.\\n    error ArbitrationPolicySP__ZeroAccessManager();\\n\\n    /// @notice Zero address provided for Dispute Module.\\n    error ArbitrationPolicySP__ZeroDisputeModule();\\n\\n    /// @notice Zero address provided for Payment Token.\\n    error ArbitrationPolicySP__ZeroPaymentToken();\\n\\n    /// @notice Caller is not the Dispute Module.\\n    error ArbitrationPolicySP__NotDisputeModule();\\n\\n    ////////////////////////////////////////////////////////////////////////////\\n    //                            Royalty Module                              //\\n    ////////////////////////////////////////////////////////////////////////////\\n\\n    /// @notice Zero address provided for Access Manager in initializer.\\n    error RoyaltyModule__ZeroAccessManager();\\n\\n    /// @notice Zero address provided for Dispute Module.\\n    error RoyaltyModule__ZeroDisputeModule();\\n\\n    /// @notice Zero address provided for License Registry.\\n    error RoyaltyModule__ZeroLicenseRegistry();\\n\\n    /// @notice Zero address provided for Licensing Module.\\n    error RoyaltyModule__ZeroLicensingModule();\\n\\n    /// @notice Zero address provided for Royalty Policy.\\n    error RoyaltyModule__ZeroRoyaltyPolicy();\\n\\n    /// @notice Zero address provided for Royalty Token.\\n    error RoyaltyModule__ZeroRoyaltyToken();\\n\\n    /// @notice Not a whitelisted royalty policy.\\n    error RoyaltyModule__NotWhitelistedRoyaltyPolicy();\\n\\n    /// @notice Not a whitelisted royalty token.\\n    error RoyaltyModule__NotWhitelistedRoyaltyToken();\\n\\n    /// @notice Royalty policy for IP is unset.\\n    error RoyaltyModule__NoRoyaltyPolicySet();\\n\\n    /// @notice Royalty policy between IPs are incompatible (different).\\n    error RoyaltyModule__IncompatibleRoyaltyPolicy();\\n\\n    /// @notice Caller is unauthorized.\\n    error RoyaltyModule__NotAllowedCaller();\\n\\n    /// @notice IP can only mint licenses of selected royalty policy.\\n    error RoyaltyModule__CanOnlyMintSelectedPolicy();\\n\\n    /// @notice Parent IP list for linking is empty.\\n    error RoyaltyModule__NoParentsOnLinking();\\n\\n    /// @notice IP is expired.\\n    error RoyaltyModule__IpIsExpired();\\n\\n    /// @notice IP is dipute tagged.\\n    error RoyaltyModule__IpIsTagged();\\n\\n    ////////////////////////////////////////////////////////////////////////////\\n    //                            Royalty Policy LAP                          //\\n    ////////////////////////////////////////////////////////////////////////////\\n\\n    /// @notice Zero address provided for Access Manager in initializer.\\n    error RoyaltyPolicyLAP__ZeroAccessManager();\\n\\n    /// @notice Zero address provided for IP Royalty Vault Beacon.\\n    error RoyaltyPolicyLAP__ZeroIpRoyaltyVaultBeacon();\\n\\n    /// @notice Zero address provided for Royalty Module.\\n    error RoyaltyPolicyLAP__ZeroRoyaltyModule();\\n\\n    /// @notice Zero address provided for Licensing Module.\\n    error RoyaltyPolicyLAP__ZeroLicensingModule();\\n\\n    /// @notice Caller is not the Royalty Module.\\n    error RoyaltyPolicyLAP__NotRoyaltyModule();\\n\\n    /// @notice Size of parent IP list is above the LAP royalty policy limit.\\n    error RoyaltyPolicyLAP__AboveParentLimit();\\n\\n    /// @notice Amount of ancestors for derivative IP is above the LAP royalty policy limit.\\n    error RoyaltyPolicyLAP__AboveAncestorsLimit();\\n\\n    /// @notice Total royalty stack exceeds the protocol limit.\\n    error RoyaltyPolicyLAP__AboveRoyaltyStackLimit();\\n\\n    /// @notice Size of parent royalties list and parent IP list mismatch.\\n    error RoyaltyPolicyLAP__InvalidParentRoyaltiesLength();\\n\\n    /// @notice IP cannot be linked to a parent, because it is either already linked to parents or derivatives (root).\\n    error RoyaltyPolicyLAP__UnlinkableToParents();\\n\\n    /// @notice Policy is already initialized and IP is at the ancestors limit, so it can't mint more licenses.\\n    error RoyaltyPolicyLAP__LastPositionNotAbleToMintLicense();\\n\\n    ////////////////////////////////////////////////////////////////////////////\\n    //                             IP Royalty Vault                           //\\n    ////////////////////////////////////////////////////////////////////////////\\n\\n    /// @notice Zero address provided for Royalty Policy LAP.\\n    error IpRoyaltyVault__ZeroRoyaltyPolicyLAP();\\n\\n    /// @notice Zero address provided for Dispute Module.\\n    error IpRoyaltyVault__ZeroDisputeModule();\\n\\n    /// @notice Caller is not the Royalty Policy LAP.\\n    error IpRoyaltyVault__NotRoyaltyPolicyLAP();\\n\\n    /// @notice Snapshot interval is too short, wait for the interval to pass for the next snapshot.\\n    error IpRoyaltyVault__SnapshotIntervalTooShort();\\n\\n    /// @notice Royalty Tokens is already claimed.\\n    error IpRoyaltyVault__AlreadyClaimed();\\n\\n    /// @notice Royalty Tokens claimer is not an ancestor of derivative IP.\\n    error IpRoyaltyVault__ClaimerNotAnAncestor();\\n\\n    /// @notice IP is dispute tagged.\\n    error IpRoyaltyVault__IpTagged();\\n\\n    /// @notice IP Royalty Vault is paused.\\n    error IpRoyaltyVault__EnforcedPause();\\n\\n    ////////////////////////////////////////////////////////////////////////////\\n    //                             Module Registry                            //\\n    ////////////////////////////////////////////////////////////////////////////\\n\\n    /// @notice Zero address provided for Access Manager in initializer.\\n    error ModuleRegistry__ZeroAccessManager();\\n\\n    /// @notice Module is zero address.\\n    error ModuleRegistry__ModuleAddressZeroAddress();\\n\\n    /// @notice Provided module address is not a contract.\\n    error ModuleRegistry__ModuleAddressNotContract();\\n\\n    /// @notice Module is already registered.\\n    error ModuleRegistry__ModuleAlreadyRegistered();\\n\\n    /// @notice Provided module name is empty string.\\n    error ModuleRegistry__NameEmptyString();\\n\\n    /// @notice Provided module name is already regsitered.\\n    error ModuleRegistry__NameAlreadyRegistered();\\n\\n    /// @notice Module name does not match the given name.\\n    error ModuleRegistry__NameDoesNotMatch();\\n\\n    /// @notice Module is not registered\\n    error ModuleRegistry__ModuleNotRegistered();\\n\\n    /// @notice Provided interface ID is zero bytes4.\\n    error ModuleRegistry__InterfaceIdZero();\\n\\n    /// @notice Module type is already registered.\\n    error ModuleRegistry__ModuleTypeAlreadyRegistered();\\n\\n    /// @notice Module type is not registered.\\n    error ModuleRegistry__ModuleTypeNotRegistered();\\n\\n    /// @notice Module address does not support the interface ID (module type).\\n    error ModuleRegistry__ModuleNotSupportExpectedModuleTypeInterfaceId();\\n\\n    /// @notice Module type is empty string.\\n    error ModuleRegistry__ModuleTypeEmptyString();\\n\\n    ////////////////////////////////////////////////////////////////////////////\\n    //                            Access Controller                           //\\n    ////////////////////////////////////////////////////////////////////////////\\n\\n    /// @notice Zero address provided for Access Manager in initializer.\\n    error AccessController__ZeroAccessManager();\\n\\n    /// @notice IP Account is zero address.\\n    error AccessController__IPAccountIsZeroAddress();\\n\\n    /// @notice IP Account is not a valid SP IP Account address.\\n    error AccessController__IPAccountIsNotValid(address ipAccount);\\n\\n    /// @notice Signer is zero address.\\n    error AccessController__SignerIsZeroAddress();\\n\\n    /// @notice Caller is not the IP Account or its owner.\\n    error AccessController__CallerIsNotIPAccountOrOwner();\\n\\n    /// @notice Invalid permission value, must be 0 (ABSTAIN), 1 (ALLOW) or 2 (DENY).\\n    error AccessController__PermissionIsNotValid();\\n\\n    /// @notice Both the caller and recipient (to) are not registered modules.\\n    error AccessController__BothCallerAndRecipientAreNotRegisteredModule(address signer, address to);\\n\\n    /// @notice Permission denied.\\n    error AccessController__PermissionDenied(address ipAccount, address signer, address to, bytes4 func);\\n\\n    ////////////////////////////////////////////////////////////////////////////\\n    //                            Access Controlled                           //\\n    ////////////////////////////////////////////////////////////////////////////\\n\\n    /// @notice Zero address passed.\\n    error AccessControlled__ZeroAddress();\\n\\n    /// @notice IP Account is not a valid SP IP Account address.\\n    error AccessControlled__NotIpAccount(address ipAccount);\\n\\n    /// @notice Caller is not the IP Account.\\n    error AccessControlled__CallerIsNotIpAccount(address caller);\\n\\n    ////////////////////////////////////////////////////////////////////////////\\n    //                          Core Metadata Module                          //\\n    ////////////////////////////////////////////////////////////////////////////\\n\\n    /// @notice Core metadata is already frozen (immutable).\\n    error CoreMetadataModule__MetadataAlreadyFrozen();\\n\\n    ////////////////////////////////////////////////////////////////////////////\\n    //                          Protocol Pause Admin                          //\\n    ////////////////////////////////////////////////////////////////////////////\\n\\n    /// @notice Zero address passed.\\n    error ProtocolPauseAdmin__ZeroAddress();\\n\\n    /// @notice Adding a contract that is paused.\\n    error ProtocolPauseAdmin__AddingPausedContract();\\n\\n    /// @notice Contract is already added to the pausable list.\\n    error ProtocolPauseAdmin__PausableAlreadyAdded();\\n\\n    /// @notice Removing a contract that is not in the pausable list.\\n    error ProtocolPauseAdmin__PausableNotFound();\\n}\\n\",\"keccak256\":\"0xe97d2675aa56e46281e81c5556b0b9f0d40b4abf369e103480582bf5c8403e5a\",\"license\":\"BUSL-1.1\"},\"@story-protocol/protocol-core/contracts/lib/IPAccountStorageOps.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\n// See https://github.com/storyprotocol/protocol-contracts/blob/main/StoryProtocol-AlphaTestingAgreement-17942166.3.pdf\\npragma solidity ^0.8.23;\\n\\nimport { IIPAccountStorage } from \\\"../interfaces/IIPAccountStorage.sol\\\";\\nimport { ShortString, ShortStrings } from \\\"@openzeppelin/contracts/utils/ShortStrings.sol\\\";\\nimport { Strings } from \\\"@openzeppelin/contracts/utils/Strings.sol\\\";\\n/// @title IPAccount Storage Operations Library\\n/// @notice Provides utility functions that extend the basic functionalities of IPAccountStorage,\\n/// facilitating enhanced module interaction with IPAccount Namespaced Storage.\\n/// @dev This library enables modules to access and manipulate IPAccount Namespaced Storage\\n/// with additional features such as using `address` type namespaces and `ShortString` keys.\\n/// It serves as an addon to the fundamental IPAccountStorage functions, allowing for more complex and\\n/// flexible interactions with the namespaced storage.\\nlibrary IPAccountStorageOps {\\n    using ShortStrings for *;\\n    using Strings for *;\\n\\n    /// @dev Sets a string value under a given key within the default namespace, determined by `msg.sender`.\\n    /// @param ipStorage The instance of the IPAccountStorage contract.\\n    /// @param key The key under which to store the value.\\n    /// @param value The string value to be stored.\\n    function setString(IIPAccountStorage ipStorage, bytes32 key, string memory value) internal {\\n        ipStorage.setBytes(key, bytes(value));\\n    }\\n\\n    /// @dev Retrieves a string value by a given key from the default namespace.\\n    /// @param ipStorage The instance of the IPAccountStorage contract.\\n    /// @param key The key whose value is to be retrieved.\\n    /// @return The string value stored under the specified key.\\n    function getString(IIPAccountStorage ipStorage, bytes32 key) internal view returns (string memory) {\\n        return string(ipStorage.getBytes(key));\\n    }\\n\\n    /// @dev Retrieves a string value by a given key from a specified namespace.\\n    /// @param ipStorage The instance of the IPAccountStorage contract.\\n    /// @param namespace The namespace from which to retrieve the value.\\n    /// @param key The key whose value is to be retrieved.\\n    /// @return The string value stored under the specified key in the given namespace.\\n    function getString(\\n        IIPAccountStorage ipStorage,\\n        bytes32 namespace,\\n        bytes32 key\\n    ) internal view returns (string memory) {\\n        return string(ipStorage.getBytes(namespace, key));\\n    }\\n\\n    /// @notice Sets a string value in the storage using a `ShortString` key.\\n    /// @dev Converts the `ShortString` key to a `bytes32` representation before storing the value.\\n    /// @param ipStorage The instance of the IPAccountStorage contract.\\n    /// @param key The `ShortString` key under which to store the value.\\n    /// @param value The string value to be stored.\\n    function setString(IIPAccountStorage ipStorage, ShortString key, string memory value) internal {\\n        setString(ipStorage, toBytes32(key), value);\\n    }\\n\\n    /// @notice Retrieves a string value from the storage using a `ShortString` key.\\n    /// @dev Converts the `ShortString` key to a `bytes32` representation before retrieving the value.\\n    /// @param ipStorage The instance of the IPAccountStorage contract.\\n    /// @param key The `ShortString` key whose value is to be retrieved.\\n    /// @return The string value stored under the specified key.\\n    function getString(IIPAccountStorage ipStorage, ShortString key) internal view returns (string memory) {\\n        return getString(ipStorage, toBytes32(key));\\n    }\\n\\n    /// @notice Retrieves a string value from the storage under a specified namespace using a bytes32 key.\\n    /// @dev Retrieves the string value from the specified namespace using the provided key.\\n    /// @param ipStorage The instance of the IPAccountStorage contract.\\n    /// @param namespace The namespace under which to retrieve the value.\\n    /// @param key The bytes32 key whose value is to be retrieved.\\n    function getString(\\n        IIPAccountStorage ipStorage,\\n        address namespace,\\n        bytes32 key\\n    ) internal view returns (string memory) {\\n        return getString(ipStorage, toBytes32(namespace), key);\\n    }\\n\\n    /// @notice Retrieves a string value from the storage under a specified namespace using a `ShortString` key.\\n    /// @dev Retrieves the string value from the specified namespace using the provided `ShortString` key.\\n    /// @param ipStorage The instance of the IPAccountStorage contract.\\n    /// @param namespace The namespace under which to retrieve the value.\\n    /// @param key The `ShortString` key whose value is to be retrieved.\\n    function getString(\\n        IIPAccountStorage ipStorage,\\n        address namespace,\\n        ShortString key\\n    ) internal view returns (string memory) {\\n        return getString(ipStorage, toBytes32(namespace), toBytes32(key));\\n    }\\n\\n    /// @dev Sets an address value under a given key within the default namespace, determined by `msg.sender`.\\n    /// @param ipStorage The instance of the IPAccountStorage contract.\\n    /// @param key The key under which to store the value.\\n    /// @param value The address value to be stored.\\n    function setAddress(IIPAccountStorage ipStorage, bytes32 key, address value) internal {\\n        ipStorage.setBytes32(key, toBytes32(value));\\n    }\\n\\n    /// @dev Retrieves an address value by a given key from the default namespace.\\n    /// @param ipStorage The instance of the IPAccountStorage contract.\\n    /// @param key The key whose value is to be retrieved.\\n    /// @return The address value stored under the specified key.\\n    function getAddress(IIPAccountStorage ipStorage, bytes32 key) internal view returns (address) {\\n        return address(uint160(uint256(ipStorage.getBytes32(key))));\\n    }\\n\\n    /// @dev Retrieves an address value by a given key from a specified namespace.\\n    /// @param ipStorage The instance of the IPAccountStorage contract.\\n    /// @param namespace The namespace from which to retrieve the value.\\n    /// @param key The key whose value is to be retrieved.\\n    /// @return The address value stored under the specified key in the given namespace.\\n    function getAddress(IIPAccountStorage ipStorage, bytes32 namespace, bytes32 key) internal view returns (address) {\\n        return address(uint160(uint256(ipStorage.getBytes32(namespace, key))));\\n    }\\n\\n    /// @notice Sets an address value in the storage using a `ShortString` key.\\n    /// @dev Converts the `ShortString` key to a `bytes32` representation before storing the value,\\n    /// facilitating address storage in a compact format.\\n    /// @param ipStorage The instance of the IPAccountStorage contract.\\n    /// @param key The `ShortString` key under which to store the address value.\\n    /// @param value The address value to be stored.\\n    function setAddress(IIPAccountStorage ipStorage, ShortString key, address value) internal {\\n        setAddress(ipStorage, toBytes32(key), value);\\n    }\\n\\n    /// @notice Retrieves an address value from the storage using a `ShortString` key.\\n    /// @dev Converts the `ShortString` key to a `bytes32` representation before retrieving the value,\\n    /// ensuring the integrity of the address data.\\n    /// @param ipStorage The instance of the IPAccountStorage contract.\\n    /// @param key The `ShortString` key whose address value is to be retrieved.\\n    /// @return The address value stored under the specified key.\\n    function getAddress(IIPAccountStorage ipStorage, ShortString key) internal view returns (address) {\\n        return getAddress(ipStorage, toBytes32(key));\\n    }\\n\\n    /// @notice Retrieves an address value from the storage under a specified namespace using a bytes32 key.\\n    /// @dev Retrieves the address value from the specified namespace using the provided key.\\n    /// @param ipStorage The instance of the IPAccountStorage contract.\\n    /// @param namespace The namespace under which to retrieve the value.\\n    /// @param key The bytes32 key whose address value is to be retrieved.\\n    /// @return The address value stored under the specified key in the given namespace.\\n    function getAddress(IIPAccountStorage ipStorage, address namespace, bytes32 key) internal view returns (address) {\\n        return getAddress(ipStorage, toBytes32(namespace), key);\\n    }\\n\\n    /// @notice Retrieves an address value from the storage under a specified namespace using a `ShortString` key.\\n    /// @dev Retrieves the address value from the specified namespace using the provided `ShortString` key.\\n    /// @param ipStorage The instance of the IPAccountStorage contract.\\n    /// @param namespace The namespace under which to retrieve the value.\\n    /// @param key The `ShortString` key whose address value is to be retrieved.\\n    /// @return The address value stored under the specified key in the given namespace.\\n    function getAddress(\\n        IIPAccountStorage ipStorage,\\n        address namespace,\\n        ShortString key\\n    ) internal view returns (address) {\\n        return getAddress(ipStorage, toBytes32(namespace), toBytes32(key));\\n    }\\n\\n    /// @dev Sets a uint256 value under a given key within the default namespace, determined by `msg.sender`.\\n    /// @param ipStorage The instance of the IPAccountStorage contract.\\n    /// @param key The key under which to store the value.\\n    /// @param value The uint256 value to be stored.\\n    function setUint256(IIPAccountStorage ipStorage, bytes32 key, uint256 value) internal {\\n        ipStorage.setBytes32(key, bytes32(value));\\n    }\\n\\n    /// @dev Retrieves a uint256 value by a given key from the default namespace.\\n    /// @param ipStorage The instance of the IPAccountStorage contract.\\n    /// @param key The key whose value is to be retrieved.\\n    /// @return The uint256 value stored under the specified key.\\n    function getUint256(IIPAccountStorage ipStorage, bytes32 key) internal view returns (uint256) {\\n        return uint256(ipStorage.getBytes32(key));\\n    }\\n\\n    /// @dev Retrieves a uint256 value by a given key from a specified namespace.\\n    /// @param ipStorage The instance of the IPAccountStorage contract.\\n    /// @param namespace The namespace from which to retrieve the value.\\n    /// @param key The key whose value is to be retrieved.\\n    /// @return The uint256 value stored under the specified key in the given namespace.\\n    function getUint256(IIPAccountStorage ipStorage, bytes32 namespace, bytes32 key) internal view returns (uint256) {\\n        return uint256(ipStorage.getBytes32(namespace, key));\\n    }\\n\\n    /// @notice Sets a uint256 value in the storage using a `ShortString` key.\\n    /// @dev Converts the `ShortString` key to a `bytes32` representation before storing the value,\\n    /// facilitating uint256 storage in a compact format.\\n    /// @param ipStorage The instance of the IPAccountStorage contract.\\n    /// @param key The `ShortString` key under which to store the uint256 value.\\n    /// @param value The uint256 value to be stored.\\n    function setUint256(IIPAccountStorage ipStorage, ShortString key, uint256 value) internal {\\n        setUint256(ipStorage, toBytes32(key), value);\\n    }\\n\\n    /// @notice Retrieves a uint256 value from the storage using a `ShortString` key.\\n    /// @dev Converts the `ShortString` key to a `bytes32` representation before retrieving the value,\\n    /// ensuring the integrity of the uint256 data.\\n    /// @param ipStorage The instance of the IPAccountStorage contract.\\n    /// @param key The `ShortString` key whose uint256 value is to be retrieved.\\n    /// @return The uint256 value stored under the specified key.\\n    function getUint256(IIPAccountStorage ipStorage, ShortString key) internal view returns (uint256) {\\n        return getUint256(ipStorage, toBytes32(key));\\n    }\\n\\n    /// @notice Retrieves a uint256 value from the storage under a specified namespace using a bytes32 key.\\n    /// @dev Retrieves the uint256 value from the specified namespace using the provided key.\\n    /// @param ipStorage The instance of the IPAccountStorage contract.\\n    /// @param namespace The namespace under which to retrieve the value.\\n    /// @param key The bytes32 key whose uint256 value is to be retrieved.\\n    /// @return The uint256 value stored under the specified key in the given namespace.\\n    function getUint256(IIPAccountStorage ipStorage, address namespace, bytes32 key) internal view returns (uint256) {\\n        return getUint256(ipStorage, toBytes32(namespace), key);\\n    }\\n\\n    /// @notice Retrieves a uint256 value from the storage under a specified namespace using a `ShortString` key.\\n    /// @dev Retrieves the uint256 value from the specified namespace using the provided `ShortString` key.\\n    /// @param ipStorage The instance of the IPAccountStorage contract.\\n    /// @param namespace The namespace under which to retrieve the value.\\n    /// @param key The `ShortString` key whose uint256 value is to be retrieved.\\n    /// @return The uint256 value stored under the specified key in the given namespace.\\n    function getUint256(\\n        IIPAccountStorage ipStorage,\\n        address namespace,\\n        ShortString key\\n    ) internal view returns (uint256) {\\n        return getUint256(ipStorage, toBytes32(namespace), toBytes32(key));\\n    }\\n\\n    /// @dev Sets a boolean value under a given key within the default namespace, determined by `msg.sender`.\\n    /// @param ipStorage The instance of the IPAccountStorage contract.\\n    /// @param key The key under which to store the value.\\n    /// @param value The boolean value to be stored.\\n    function setBool(IIPAccountStorage ipStorage, bytes32 key, bool value) internal {\\n        ipStorage.setBytes32(key, value ? bytes32(uint256(1)) : bytes32(0));\\n    }\\n\\n    /// @dev Retrieves a boolean value by a given key from the default namespace.\\n    /// @param ipStorage The instance of the IPAccountStorage contract.\\n    /// @param key The key whose value is to be retrieved.\\n    /// @return The boolean value stored under the specified key.\\n    function getBool(IIPAccountStorage ipStorage, bytes32 key) internal view returns (bool) {\\n        return ipStorage.getBytes32(key) != 0;\\n    }\\n\\n    /// @dev Retrieves a boolean value by a given key from a specified namespace.\\n    /// @param ipStorage The instance of the IPAccountStorage contract.\\n    /// @param namespace The namespace from which to retrieve the value.\\n    /// @param key The key whose value is to be retrieved.\\n    /// @return The boolean value stored under the specified key in the given namespace.\\n    function getBool(IIPAccountStorage ipStorage, bytes32 namespace, bytes32 key) internal view returns (bool) {\\n        return ipStorage.getBytes32(namespace, key) != 0;\\n    }\\n\\n    /// @notice Sets a bool value in the storage using a `ShortString` key.\\n    /// @dev Converts the `ShortString` key to a `bytes32` representation before storing the value,\\n    /// facilitating bool storage in a compact format.\\n    /// @param ipStorage The instance of the IPAccountStorage contract.\\n    /// @param key The `ShortString` key under which to store the bool value.\\n    /// @param value The bool value to be stored.\\n    function setBool(IIPAccountStorage ipStorage, ShortString key, bool value) internal {\\n        setBool(ipStorage, toBytes32(key), value);\\n    }\\n\\n    /// @notice Retrieves a bool value from the storage using a `ShortString` key.\\n    /// @dev Converts the `ShortString` key to a `bytes32` representation before retrieving the value,\\n    /// ensuring the integrity of the bool data.\\n    /// @param ipStorage The instance of the IPAccountStorage contract.\\n    /// @param key The `ShortString` key whose bool value is to be retrieved.\\n    /// @return The bool value stored under the specified key.\\n    function getBool(IIPAccountStorage ipStorage, ShortString key) internal view returns (bool) {\\n        return getBool(ipStorage, toBytes32(key));\\n    }\\n\\n    /// @notice Retrieves a bool value from the storage under a specified namespace using a bytes32 key.\\n    /// @dev Retrieves the bool value from the specified namespace using the provided key.\\n    /// @param ipStorage The instance of the IPAccountStorage contract.\\n    /// @param namespace The namespace under which to retrieve the value.\\n    /// @param key The bytes32 key whose bool value is to be retrieved.\\n    /// @return The bool value stored under the specified key in the given namespace.\\n    function getBool(IIPAccountStorage ipStorage, address namespace, bytes32 key) internal view returns (bool) {\\n        return getBool(ipStorage, toBytes32(namespace), key);\\n    }\\n\\n    /// @notice Retrieves a bool value from the storage under a specified namespace using a `ShortString` key.\\n    /// @dev Retrieves the bool value from the specified namespace using the provided `ShortString` key.\\n    /// @param ipStorage The instance of the IPAccountStorage contract.\\n    /// @param namespace The namespace under which to retrieve the value.\\n    /// @param key The `ShortString` key whose bool value is to be retrieved.\\n    /// @return The bool value stored under the specified key in the given namespace.\\n    function getBool(IIPAccountStorage ipStorage, address namespace, ShortString key) internal view returns (bool) {\\n        return getBool(ipStorage, toBytes32(namespace), toBytes32(key));\\n    }\\n\\n    /// @notice Sets a bytes value in the storage using a `ShortString` key.\\n    /// @dev Converts the `ShortString` key to a `bytes32` representation before storing the value,\\n    /// facilitating bytes storage in a compact format.\\n    /// @param ipStorage The instance of the IPAccountStorage contract.\\n    /// @param key The `ShortString` key under which to store the bytes value.\\n    /// @param value The bytes value to be stored.\\n    function setBytes(IIPAccountStorage ipStorage, ShortString key, bytes memory value) internal {\\n        ipStorage.setBytes(toBytes32(key), value);\\n    }\\n\\n    /// @notice Sets a bytes value in the storage using two `ShortString` keys.\\n    /// @param ipStorage The instance of the IPAccountStorage contract.\\n    function setBytes(IIPAccountStorage ipStorage, ShortString key1, ShortString key2, bytes memory value) internal {\\n        ipStorage.setBytes(toBytes32(string(abi.encodePacked(key1.toString(), key2.toString()))), value);\\n    }\\n\\n    /// @notice Retrieves a bytes value from the storage using a `ShortString` key.\\n    /// @dev Converts the `ShortString` key to a `bytes32` representation before retrieving the value,\\n    /// ensuring the integrity of the bytes data.\\n    /// @param ipStorage The instance of the IPAccountStorage contract.\\n    /// @param key The `ShortString` key whose bytes value is to be retrieved.\\n    /// @return The bytes value stored under the specified key.\\n    function getBytes(IIPAccountStorage ipStorage, ShortString key) internal view returns (bytes memory) {\\n        return ipStorage.getBytes(toBytes32(key));\\n    }\\n\\n    /// @notice Retrieves a bytes value from the storage under a specified namespace using a bytes32 key.\\n    /// @dev Retrieves the bytes value from the specified namespace using the provided key.\\n    /// @param ipStorage The instance of the IPAccountStorage contract.\\n    /// @param namespace The namespace under which to retrieve the value.\\n    /// @param key The bytes32 key whose bytes value is to be retrieved.\\n    /// @return The bytes value stored under the specified key in the given namespace.\\n    function getBytes(\\n        IIPAccountStorage ipStorage,\\n        address namespace,\\n        bytes32 key\\n    ) internal view returns (bytes memory) {\\n        return ipStorage.getBytes(toBytes32(namespace), key);\\n    }\\n\\n    /// @notice Retrieves a bytes value from the storage under a specified namespace using a `ShortString` key.\\n    /// @dev Retrieves the bytes value from the specified namespace using the provided `ShortString` key.\\n    /// @param ipStorage The instance of the IPAccountStorage contract.\\n    /// @param namespace The namespace under which to retrieve the value.\\n    /// @param key The `ShortString` key whose bytes value is to be retrieved.\\n    /// @return The bytes value stored under the specified key in the given namespace.\\n    function getBytes(\\n        IIPAccountStorage ipStorage,\\n        address namespace,\\n        ShortString key\\n    ) internal view returns (bytes memory) {\\n        return ipStorage.getBytes(toBytes32(namespace), toBytes32(key));\\n    }\\n\\n    /// @notice Retrieves a bytes value from the storage using two `ShortString` keys.\\n    /// @param ipStorage The instance of the IPAccountStorage contract.\\n    /// @return The bytes value stored under the combination of two keys.\\n    function getBytes(\\n        IIPAccountStorage ipStorage,\\n        ShortString key1,\\n        ShortString key2\\n    ) internal view returns (bytes memory) {\\n        return ipStorage.getBytes(toBytes32(string(abi.encodePacked(key1.toString(), key2.toString()))));\\n    }\\n\\n    /// @notice Retrieves a bytes value from the storage under a specified namespace using two `ShortString` keys.\\n    /// @param ipStorage The instance of the IPAccountStorage contract.\\n    /// @param namespace The namespace under which to retrieve the value.\\n    /// @return The bytes value stored under the combination of two keys.\\n    function getBytes(\\n        IIPAccountStorage ipStorage,\\n        address namespace,\\n        ShortString key1,\\n        ShortString key2\\n    ) internal view returns (bytes memory) {\\n        return\\n            ipStorage.getBytes(\\n                toBytes32(namespace),\\n                toBytes32(string(abi.encodePacked(key1.toString(), key2.toString())))\\n            );\\n    }\\n\\n    /// @notice Sets a bytes32 value in the storage using a `ShortString` key.\\n    /// @dev Converts the `ShortString` key to a `bytes32` representation before storing the value,\\n    /// facilitating bytes32 storage in a compact format.\\n    /// @param ipStorage The instance of the IPAccountStorage contract.\\n    /// @param key The `ShortString` key under which to store the bytes32 value.\\n    /// @param value The bytes32 value to be stored.\\n    function setBytes32(IIPAccountStorage ipStorage, ShortString key, bytes32 value) internal {\\n        ipStorage.setBytes32(toBytes32(key), value);\\n    }\\n\\n    /// @notice Retrieves a bytes32 value from the storage using a `ShortString` key.\\n    /// @dev Converts the `ShortString` key to a `bytes32` representation before retrieving the value,\\n    /// ensuring the integrity of the bytes32 data.\\n    /// @param ipStorage The instance of the IPAccountStorage contract.\\n    /// @param key The `ShortString` key whose bytes32 value is to be retrieved.\\n    /// @return The bytes32 value stored under the specified key.\\n    function getBytes32(IIPAccountStorage ipStorage, ShortString key) internal view returns (bytes32) {\\n        return ipStorage.getBytes32(toBytes32(key));\\n    }\\n\\n    /// @notice Retrieves a bytes32 value from the storage under a specified namespace using a bytes32 key.\\n    /// @dev Retrieves the bytes32 value from the specified namespace using the provided key.\\n    /// @param ipStorage The instance of the IPAccountStorage contract.\\n    /// @param namespace The namespace under which to retrieve the value.\\n    /// @param key The bytes32 key whose bytes32 value is to be retrieved.\\n    /// @return The bytes32 value stored under the specified key in the given namespace.\\n    function getBytes32(IIPAccountStorage ipStorage, address namespace, bytes32 key) internal view returns (bytes32) {\\n        return ipStorage.getBytes32(toBytes32(namespace), key);\\n    }\\n\\n    /// @notice Retrieves a bytes32 value from the storage under a specified namespace using a `ShortString` key.\\n    /// @dev Retrieves the bytes32 value from the specified namespace using the provided `ShortString` key.\\n    /// @param ipStorage The instance of the IPAccountStorage contract.\\n    /// @param namespace The namespace under which to retrieve the value.\\n    /// @param key The `ShortString` key whose bytes32 value is to be retrieved.\\n    /// @return The bytes32 value stored under the specified key in the given namespace.\\n    function getBytes32(\\n        IIPAccountStorage ipStorage,\\n        address namespace,\\n        ShortString key\\n    ) internal view returns (bytes32) {\\n        return ipStorage.getBytes32(toBytes32(namespace), toBytes32(key));\\n    }\\n\\n    function toBytes32(string memory s) internal pure returns (bytes32) {\\n        return ShortString.unwrap(s.toShortString());\\n    }\\n\\n    function toBytes32(address a) internal pure returns (bytes32) {\\n        return bytes32(uint256(uint160(a)));\\n    }\\n\\n    function toBytes32(ShortString sstr) internal pure returns (bytes32) {\\n        // remove the length byte from the ShortString\\n        // so that bytes32 result is identical with converting string to bytes32 directly\\n        return ShortString.unwrap(sstr) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00;\\n    }\\n}\\n\",\"keccak256\":\"0xa40b7affdb0fde9625b1499d1e8bb9c59969efa471dabd03df398ab7bd13811e\",\"license\":\"UNLICENSED\"},\"@story-protocol/protocol-core/contracts/pause/ProtocolPausableUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.23;\\n\\n// solhint-disable-next-line max-line-length\\nimport { AccessManagedUpgradeable } from \\\"@openzeppelin/contracts-upgradeable/access/manager/AccessManagedUpgradeable.sol\\\";\\nimport { PausableUpgradeable } from \\\"@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol\\\";\\n\\n/// @title ProtocolPausable\\n/// @notice Contract that allows the pausing and unpausing of the a contract\\nabstract contract ProtocolPausableUpgradeable is PausableUpgradeable, AccessManagedUpgradeable {\\n    /// @notice Initializes the ProtocolPausable contract\\n    /// @param accessManager The address of the access manager\\n    function __ProtocolPausable_init(address accessManager) public initializer {\\n        __AccessManaged_init(accessManager);\\n        __Pausable_init();\\n    }\\n\\n    /// @notice sets paused state\\n    function pause() external restricted {\\n        _pause();\\n    }\\n\\n    /// @notice unsets unpaused state\\n    function unpause() external restricted {\\n        _unpause();\\n    }\\n\\n    function paused() public view override returns (bool) {\\n        return super.paused();\\n    }\\n}\\n\",\"keccak256\":\"0xe64a943bb675099a400a4dc5fde76a982e1c14b46fe00c0ea55f8b325a24f7af\",\"license\":\"BUSL-1.1\"},\"@story-protocol/protocol-core/contracts/registries/IPAccountRegistry.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.23;\\n\\nimport { IERC6551Registry } from \\\"erc6551/interfaces/IERC6551Registry.sol\\\";\\n\\nimport { IIPAccountRegistry } from \\\"../interfaces/registries/IIPAccountRegistry.sol\\\";\\nimport { Errors } from \\\"../lib/Errors.sol\\\";\\n\\n/// @title IPAccountRegistry\\n/// @notice This contract is responsible for managing the registration and tracking of IP Accounts.\\n/// It leverages a public ERC6551 registry to deploy IPAccount contracts.\\nabstract contract IPAccountRegistry is IIPAccountRegistry {\\n    /// @notice Returns the IPAccount implementation address\\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\\n    address public immutable IP_ACCOUNT_IMPL;\\n\\n    /// @notice Returns the IPAccount salt\\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\\n    bytes32 public immutable IP_ACCOUNT_SALT;\\n\\n    /// @notice Returns the public ERC6551 registry address\\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\\n    address public immutable ERC6551_PUBLIC_REGISTRY;\\n\\n    /// @custom:oz-upgrades-unsafe-allow constructor\\n    constructor(address erc6551Registry, address ipAccountImpl) {\\n        if (ipAccountImpl == address(0)) revert Errors.IPAccountRegistry_ZeroIpAccountImpl();\\n        IP_ACCOUNT_IMPL = ipAccountImpl;\\n        IP_ACCOUNT_SALT = bytes32(0);\\n        ERC6551_PUBLIC_REGISTRY = erc6551Registry;\\n    }\\n\\n    /// @notice Deploys an IPAccount contract with the IPAccount implementation and returns the address of the new IP\\n    /// @dev The IPAccount deployment deltegates to public ERC6551 Registry\\n    /// @param chainId The chain ID where the IP Account will be created\\n    /// @param tokenContract The address of the token contract to be associated with the IP Account\\n    /// @param tokenId The ID of the token to be associated with the IP Account\\n    /// @return ipAccountAddress The address of the newly created IP Account\\n    function registerIpAccount(\\n        uint256 chainId,\\n        address tokenContract,\\n        uint256 tokenId\\n    ) public returns (address ipAccountAddress) {\\n        ipAccountAddress = IERC6551Registry(ERC6551_PUBLIC_REGISTRY).createAccount(\\n            IP_ACCOUNT_IMPL,\\n            IP_ACCOUNT_SALT,\\n            chainId,\\n            tokenContract,\\n            tokenId\\n        );\\n        emit IPAccountRegistered(ipAccountAddress, IP_ACCOUNT_IMPL, chainId, tokenContract, tokenId);\\n    }\\n\\n    /// @notice Returns the IPAccount address for the given NFT token.\\n    /// @param chainId The chain ID where the IP Account is located\\n    /// @param tokenContract The address of the token contract associated with the IP Account\\n    /// @param tokenId The ID of the token associated with the IP Account\\n    /// @return ipAccountAddress The address of the IP Account associated with the given NFT token\\n    function ipAccount(uint256 chainId, address tokenContract, uint256 tokenId) public view returns (address) {\\n        return _get6551AccountAddress(chainId, tokenContract, tokenId);\\n    }\\n\\n    /// @notice Returns the IPAccount implementation address.\\n    /// @return The address of the IPAccount implementation\\n    function getIPAccountImpl() external view override returns (address) {\\n        return IP_ACCOUNT_IMPL;\\n    }\\n\\n    /// @dev Helper function to get the IPAccount address from the ERC6551 registry.\\n    function _get6551AccountAddress(\\n        uint256 chainId,\\n        address tokenContract,\\n        uint256 tokenId\\n    ) internal view returns (address) {\\n        return\\n            IERC6551Registry(ERC6551_PUBLIC_REGISTRY).account(\\n                IP_ACCOUNT_IMPL,\\n                IP_ACCOUNT_SALT,\\n                chainId,\\n                tokenContract,\\n                tokenId\\n            );\\n    }\\n}\\n\",\"keccak256\":\"0x3209e4d1f64f4c9172a17137321db796665d6345223b972ac25f7412e11b3eae\",\"license\":\"BUSL-1.1\"},\"@story-protocol/protocol-core/contracts/registries/IPAssetRegistry.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.23;\\n\\nimport { IERC721 } from \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\nimport { IERC721Metadata } from \\\"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\\\";\\nimport { ERC165Checker } from \\\"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\\\";\\nimport { Strings } from \\\"@openzeppelin/contracts/utils/Strings.sol\\\";\\nimport { UUPSUpgradeable } from \\\"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\\\";\\n\\nimport { IIPAccount } from \\\"../interfaces/IIPAccount.sol\\\";\\nimport { IIPAssetRegistry } from \\\"../interfaces/registries/IIPAssetRegistry.sol\\\";\\nimport { ProtocolPausableUpgradeable } from \\\"../pause/ProtocolPausableUpgradeable.sol\\\";\\nimport { IPAccountRegistry } from \\\"../registries/IPAccountRegistry.sol\\\";\\nimport { Errors } from \\\"../lib/Errors.sol\\\";\\nimport { IPAccountStorageOps } from \\\"../lib/IPAccountStorageOps.sol\\\";\\n\\n/// @title IP Asset Registry\\n/// @notice This contract acts as the source of truth for all IP registered in\\n///         Story Protocol. An IP is identified by its contract address, token\\n///         id, and coin type, meaning any NFT may be conceptualized as an IP.\\n///         Once an IP is registered into the protocol, a corresponding IP\\n///         asset is generated, which references an IP resolver for metadata\\n///         attribution and an IP account for protocol authorization.\\n///         IMPORTANT: The IP account address, besides being used for protocol\\n///                    auth, is also the canonical IP identifier for the IP NFT.\\ncontract IPAssetRegistry is IIPAssetRegistry, IPAccountRegistry, ProtocolPausableUpgradeable, UUPSUpgradeable {\\n    using ERC165Checker for address;\\n    using Strings for *;\\n    using IPAccountStorageOps for IIPAccount;\\n\\n    /// @dev Storage structure for the IPAssetRegistry\\n    /// @notice Tracks the total number of IP assets in existence.\\n    /// @custom:storage-location erc7201:story-protocol.IPAssetRegistry\\n    struct IPAssetRegistryStorage {\\n        uint256 totalSupply;\\n    }\\n\\n    // keccak256(abi.encode(uint256(keccak256(\\\"story-protocol.IPAssetRegistry\\\")) - 1)) & ~bytes32(uint256(0xff));\\n    bytes32 private constant IPAssetRegistryStorageLocation =\\n        0x987c61809af5a42943abd137c7acff8426aab6f7a1f5c967a03d1d718ba5cf00;\\n\\n    /// @custom:oz-upgrades-unsafe-allow constructor\\n    constructor(address erc6551Registry, address ipAccountImpl) IPAccountRegistry(erc6551Registry, ipAccountImpl) {\\n        _disableInitializers();\\n    }\\n\\n    /// @notice Initializes the IPAssetRegistry contract.\\n    /// @param accessManager The address of the access manager.\\n    function initialize(address accessManager) public initializer {\\n        if (accessManager == address(0)) {\\n            revert Errors.IPAssetRegistry__ZeroAccessManager();\\n        }\\n        __ProtocolPausable_init(accessManager);\\n        __UUPSUpgradeable_init();\\n    }\\n\\n    /// @notice Registers an NFT as an IP asset.\\n    /// @dev The IP required metadata name and URI are derived from the NFT's metadata.\\n    /// @param chainid The chain identifier of where the IP NFT resides.\\n    /// @param tokenContract The address of the NFT.\\n    /// @param tokenId The token identifier of the NFT.\\n    /// @return id The address of the newly registered IP.\\n    function register(\\n        uint256 chainid,\\n        address tokenContract,\\n        uint256 tokenId\\n    ) external whenNotPaused returns (address id) {\\n        id = registerIpAccount(chainid, tokenContract, tokenId);\\n        IIPAccount ipAccount = IIPAccount(payable(id));\\n\\n        if (bytes(ipAccount.getString(\\\"NAME\\\")).length != 0) {\\n            revert Errors.IPAssetRegistry__AlreadyRegistered();\\n        }\\n\\n        (string memory name, string memory uri) = _getNameAndUri(chainid, tokenContract, tokenId);\\n        uint256 registrationDate = block.timestamp;\\n        ipAccount.setString(\\\"NAME\\\", name);\\n        ipAccount.setString(\\\"URI\\\", uri);\\n        ipAccount.setUint256(\\\"REGISTRATION_DATE\\\", registrationDate);\\n\\n        _getIPAssetRegistryStorage().totalSupply++;\\n\\n        emit IPRegistered(id, chainid, tokenContract, tokenId, name, uri, registrationDate);\\n    }\\n\\n    /// @notice Gets the canonical IP identifier associated with an IP NFT.\\n    /// @dev This is equivalent to the address of its bound IP account.\\n    /// @param chainId The chain identifier of where the IP resides.\\n    /// @param tokenContract The address of the IP.\\n    /// @param tokenId The token identifier of the IP.\\n    /// @return ipId The IP's canonical address identifier.\\n    function ipId(uint256 chainId, address tokenContract, uint256 tokenId) public view returns (address) {\\n        return super.ipAccount(chainId, tokenContract, tokenId);\\n    }\\n\\n    /// @notice Checks whether an IP was registered based on its ID.\\n    /// @param id The canonical identifier for the IP.\\n    /// @return isRegistered Whether the IP was registered into the protocol.\\n    function isRegistered(address id) external view returns (bool) {\\n        if (id == address(0)) return false;\\n        if (id.code.length == 0) return false;\\n        if (!ERC165Checker.supportsInterface(id, type(IIPAccount).interfaceId)) return false;\\n        (uint chainId, address tokenContract, uint tokenId) = IIPAccount(payable(id)).token();\\n        if (id != ipAccount(chainId, tokenContract, tokenId)) return false;\\n        return bytes(IIPAccount(payable(id)).getString(\\\"NAME\\\")).length != 0;\\n    }\\n\\n    /// @notice Gets the total number of IP assets registered in the protocol.\\n    function totalSupply() external view returns (uint256) {\\n        return _getIPAssetRegistryStorage().totalSupply;\\n    }\\n\\n    /// @dev Retrieves the name and URI of from IP NFT.\\n    function _getNameAndUri(\\n        uint256 chainid,\\n        address tokenContract,\\n        uint256 tokenId\\n    ) internal view returns (string memory name, string memory uri) {\\n        if (chainid != block.chainid) {\\n            name = string.concat(chainid.toString(), \\\": \\\", tokenContract.toHexString(), \\\" #\\\", tokenId.toString());\\n            uri = \\\"\\\";\\n            return (name, uri);\\n        }\\n        // Handle NFT on the same chain\\n        if (!tokenContract.supportsInterface(type(IERC721).interfaceId)) {\\n            revert Errors.IPAssetRegistry__UnsupportedIERC721(tokenContract);\\n        }\\n\\n        if (IERC721(tokenContract).ownerOf(tokenId) == address(0)) {\\n            revert Errors.IPAssetRegistry__InvalidToken(tokenContract, tokenId);\\n        }\\n\\n        if (!tokenContract.supportsInterface(type(IERC721Metadata).interfaceId)) {\\n            revert Errors.IPAssetRegistry__UnsupportedIERC721Metadata(tokenContract);\\n        }\\n\\n        name = string.concat(\\n            block.chainid.toString(),\\n            \\\": \\\",\\n            IERC721Metadata(tokenContract).name(),\\n            \\\" #\\\",\\n            tokenId.toString()\\n        );\\n        uri = IERC721Metadata(tokenContract).tokenURI(tokenId);\\n    }\\n\\n    /// @dev Hook to authorize the upgrade according to UUPSUpgradeable\\n    /// @param newImplementation The address of the new implementation\\n    function _authorizeUpgrade(address newImplementation) internal override restricted {}\\n\\n    /// @dev Returns the storage struct of IPAssetRegistry.\\n    function _getIPAssetRegistryStorage() private pure returns (IPAssetRegistryStorage storage $) {\\n        assembly {\\n            $.slot := IPAssetRegistryStorageLocation\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x0fce7ee6028cc9e750cd2c3eda20676c2aa564a3c281ffa583cfcabc45eea2b7\",\"license\":\"BUSL-1.1\"},\"contracts/creader-io/ChapterNFT.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\n//TODO: ChapterNFT\\n// createChapter -> mint a new 721 IPA and create a bonding curve for it\\n\\npragma solidity ^0.8.23;\\n\\nimport {ERC721} from \\\"solmate/src/tokens/ERC721.sol\\\";\\nimport \\\"@story-protocol/protocol-core/contracts/registries/IPAssetRegistry.sol\\\";\\nimport {IBodhi} from \\\"../shares/interface/IBodhi.sol\\\";\\n\\ncontract ChapterNFT is ERC721 {\\n    uint256 private _tokenIds;\\n\\n    struct Chapter {\\n        string title;\\n        address owner;\\n    }\\n\\n    mapping(uint256 => Chapter) public chapters;\\n\\n    IPAssetRegistry public immutable REGISTRY;\\n    IBodhi public immutable BODHI;\\n\\n    constructor(\\n        IPAssetRegistry _registry,\\n        IBodhi _bodhi\\n    ) ERC721(\\\"ChapterNFT\\\", \\\"CNFT\\\") {\\n        REGISTRY = _registry;\\n        BODHI = IBodhi(_bodhi);\\n    }\\n\\n    function createChapter(\\n        string memory _title,\\n        string calldata arTxId\\n    ) public {\\n        uint256 tokenId = _tokenIds;\\n        address id = REGISTRY.register(block.chainid, address(this), _tokenIds);\\n        chapters[tokenId] = Chapter(_title, id);\\n        _mint(msg.sender, tokenId);\\n        BODHI.create(arTxId);\\n        _tokenIds++;\\n    }\\n\\n    function updateChapter(uint256 _tokenId, string memory _title) public {\\n        require(\\n            ownerOf(_tokenId) == msg.sender,\\n            \\\"Only owner can update chapter\\\"\\n        );\\n        chapters[_tokenId].title = _title;\\n    }\\n\\n    function tokenURI(\\n        uint256 id\\n    ) public view virtual override returns (string memory) {\\n        // TODO: Implement token URI logic\\n        return string(abi.encodePacked(\\\"https://ipfs.io/ipfs/\\\", id));\\n    }\\n}\\n\",\"keccak256\":\"0x5c3bddaf28284e3633f80b0b1a1ef202195880685a4451510759146fa41e9f83\",\"license\":\"MIT\"},\"contracts/shares/interface/IBodhi.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title IBodhi\\n * @dev Interface for the Bodhi contract.\\n */\\ninterface IBodhi {\\n    /**\\n     * @notice Creates a new asset.\\n     * @param arTxId The Arweave transaction ID associated with the asset.\\n     */\\n    function create(string calldata arTxId) external;\\n\\n    /**\\n     * @notice Removes an existing asset.\\n     * @param assetId The ID of the asset to be removed.\\n     */\\n    function remove(uint256 assetId) external;\\n\\n    /**\\n     * @notice Gets the asset IDs associated with an address.\\n     * @param addr The address to query for asset IDs.\\n     * @return An array of asset IDs associated with the address.\\n     */\\n    function getAssetIdsByAddress(\\n        address addr\\n    ) external view returns (uint256[] memory);\\n\\n    /**\\n     * @notice Gets the price for buying a certain amount of an asset.\\n     * @param assetId The ID of the asset.\\n     * @param amount The amount of the asset to buy.\\n     * @return The price for buying the specified amount of the asset.\\n     */\\n    function getBuyPrice(\\n        uint256 assetId,\\n        uint256 amount\\n    ) external view returns (uint256);\\n\\n    /**\\n     * @notice Gets the price for selling a certain amount of an asset.\\n     * @param assetId The ID of the asset.\\n     * @param amount The amount of the asset to sell.\\n     * @return The price for selling the specified amount of the asset.\\n     */\\n    function getSellPrice(\\n        uint256 assetId,\\n        uint256 amount\\n    ) external view returns (uint256);\\n\\n    /**\\n     * @notice Gets the buy price after adding the creator fee.\\n     * @param assetId The ID of the asset.\\n     * @param amount The amount of the asset to buy.\\n     * @return The price for buying the specified amount of the asset after adding the creator fee.\\n     */\\n    function getBuyPriceAfterFee(\\n        uint256 assetId,\\n        uint256 amount\\n    ) external view returns (uint256);\\n\\n    /**\\n     * @notice Gets the sell price after subtracting the creator fee.\\n     * @param assetId The ID of the asset.\\n     * @param amount The amount of the asset to sell.\\n     * @return The price for selling the specified amount of the asset after subtracting the creator fee.\\n     */\\n    function getSellPriceAfterFee(\\n        uint256 assetId,\\n        uint256 amount\\n    ) external view returns (uint256);\\n\\n    /**\\n     * @notice Buys a certain amount of an asset.\\n     * @param assetId The ID of the asset to buy.\\n     * @param amount The amount of the asset to buy.\\n     */\\n    function buy(uint256 assetId, uint256 amount) external payable;\\n\\n    /**\\n     * @notice Sells a certain amount of an asset.\\n     * @param assetId The ID of the asset to sell.\\n     * @param amount The amount of the asset to sell.\\n     */\\n    function sell(uint256 assetId, uint256 amount) external;\\n\\n    /**\\n     * @notice Gets the URI associated with an asset ID.\\n     * @param id The asset ID.\\n     * @return The URI associated with the asset ID.\\n     */\\n    function uri(uint256 id) external view returns (string memory);\\n\\n    /**\\n     * @notice Checks if a user has shares in an asset.\\n     * @param user The address of the user.\\n     * @param assetId The ID of the asset.\\n     * @return True if the user has shares in the asset, false otherwise.\\n     */\\n    function hasShares(\\n        address user,\\n        uint256 assetId\\n    ) external view returns (bool);\\n\\n    function checkIfUserHasShares(\\n        address user,\\n        uint256 assetId\\n    ) external view returns (bool);\\n\\n    /// @dev Event emitted when an asset is created.\\n    event Create(\\n        uint256 indexed assetId,\\n        address indexed sender,\\n        string arTxId\\n    );\\n\\n    /// @dev Event emitted when an asset is removed.\\n    event Remove(uint256 indexed assetId, address indexed sender);\\n\\n    /// @dev Event emitted when a trade occurs.\\n    event Trade(\\n        TradeType indexed tradeType,\\n        uint256 indexed assetId,\\n        address indexed sender,\\n        uint256 tokenAmount,\\n        uint256 ethAmount,\\n        uint256 creatorFee\\n    );\\n\\n    /// @dev Custom error for unauthorized access.\\n    error Unauthorized();\\n\\n    /// @dev Enumeration of trade types.\\n    enum TradeType {\\n        Mint,\\n        Buy,\\n        Sell\\n    }\\n}\\n\",\"keccak256\":\"0xfa15cb4a33b1df9fde03193c17ee9429a35443da621f85213d16f242296b6617\",\"license\":\"MIT\"},\"erc6551/interfaces/IERC6551Account.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/// @dev the ERC-165 identifier for this interface is `0x6faff5f1`\\ninterface IERC6551Account {\\n    /**\\n     * @dev Allows the account to receive Ether.\\n     *\\n     * Accounts MUST implement a `receive` function.\\n     *\\n     * Accounts MAY perform arbitrary logic to restrict conditions\\n     * under which Ether can be received.\\n     */\\n    receive() external payable;\\n\\n    /**\\n     * @dev Returns the identifier of the non-fungible token which owns the account.\\n     *\\n     * The return value of this function MUST be constant - it MUST NOT change over time.\\n     *\\n     * @return chainId       The EIP-155 ID of the chain the token exists on\\n     * @return tokenContract The contract address of the token\\n     * @return tokenId       The ID of the token\\n     */\\n    function token()\\n        external\\n        view\\n        returns (uint256 chainId, address tokenContract, uint256 tokenId);\\n\\n    /**\\n     * @dev Returns a value that SHOULD be modified each time the account changes state.\\n     *\\n     * @return The current account state\\n     */\\n    function state() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns a magic value indicating whether a given signer is authorized to act on behalf\\n     * of the account.\\n     *\\n     * MUST return the bytes4 magic value 0x523e3260 if the given signer is valid.\\n     *\\n     * By default, the holder of the non-fungible token the account is bound to MUST be considered\\n     * a valid signer.\\n     *\\n     * Accounts MAY implement additional authorization logic which invalidates the holder as a\\n     * signer or grants signing permissions to other non-holder accounts.\\n     *\\n     * @param  signer     The address to check signing authorization for\\n     * @param  context    Additional data used to determine whether the signer is valid\\n     * @return magicValue Magic value indicating whether the signer is valid\\n     */\\n    function isValidSigner(address signer, bytes calldata context)\\n        external\\n        view\\n        returns (bytes4 magicValue);\\n}\\n\",\"keccak256\":\"0xda097894cc052f451ad669c5a07a9eda3f53a948f8080714850dc68cc1040b42\",\"license\":\"MIT\"},\"erc6551/interfaces/IERC6551Registry.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IERC6551Registry {\\n    /**\\n     * @dev The registry MUST emit the ERC6551AccountCreated event upon successful account creation.\\n     */\\n    event ERC6551AccountCreated(\\n        address account,\\n        address indexed implementation,\\n        bytes32 salt,\\n        uint256 chainId,\\n        address indexed tokenContract,\\n        uint256 indexed tokenId\\n    );\\n\\n    /**\\n     * @dev The registry MUST revert with AccountCreationFailed error if the create2 operation fails.\\n     */\\n    error AccountCreationFailed();\\n\\n    /**\\n     * @dev Creates a token bound account for a non-fungible token.\\n     *\\n     * If account has already been created, returns the account address without calling create2.\\n     *\\n     * Emits ERC6551AccountCreated event.\\n     *\\n     * @return account The address of the token bound account\\n     */\\n    function createAccount(\\n        address implementation,\\n        bytes32 salt,\\n        uint256 chainId,\\n        address tokenContract,\\n        uint256 tokenId\\n    ) external returns (address account);\\n\\n    /**\\n     * @dev Returns the computed token bound account address for a non-fungible token.\\n     *\\n     * @return account The address of the token bound account\\n     */\\n    function account(\\n        address implementation,\\n        bytes32 salt,\\n        uint256 chainId,\\n        address tokenContract,\\n        uint256 tokenId\\n    ) external view returns (address account);\\n}\\n\",\"keccak256\":\"0x871be5b51883d915c0b871cb0baf7bbddd41a2b2e42ae109b922c6418ee7141b\",\"license\":\"MIT\"},\"solmate/src/tokens/ERC721.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Modern, minimalist, and gas efficient ERC-721 implementation.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC721.sol)\\nabstract contract ERC721 {\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 indexed id);\\n\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                         METADATA STORAGE/LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    string public name;\\n\\n    string public symbol;\\n\\n    function tokenURI(uint256 id) public view virtual returns (string memory);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                      ERC721 BALANCE/OWNER STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    mapping(uint256 => address) internal _ownerOf;\\n\\n    mapping(address => uint256) internal _balanceOf;\\n\\n    function ownerOf(uint256 id) public view virtual returns (address owner) {\\n        require((owner = _ownerOf[id]) != address(0), \\\"NOT_MINTED\\\");\\n    }\\n\\n    function balanceOf(address owner) public view virtual returns (uint256) {\\n        require(owner != address(0), \\\"ZERO_ADDRESS\\\");\\n\\n        return _balanceOf[owner];\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                         ERC721 APPROVAL STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    mapping(uint256 => address) public getApproved;\\n\\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(string memory _name, string memory _symbol) {\\n        name = _name;\\n        symbol = _symbol;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC721 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function approve(address spender, uint256 id) public virtual {\\n        address owner = _ownerOf[id];\\n\\n        require(msg.sender == owner || isApprovedForAll[owner][msg.sender], \\\"NOT_AUTHORIZED\\\");\\n\\n        getApproved[id] = spender;\\n\\n        emit Approval(owner, spender, id);\\n    }\\n\\n    function setApprovalForAll(address operator, bool approved) public virtual {\\n        isApprovedForAll[msg.sender][operator] = approved;\\n\\n        emit ApprovalForAll(msg.sender, operator, approved);\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 id\\n    ) public virtual {\\n        require(from == _ownerOf[id], \\\"WRONG_FROM\\\");\\n\\n        require(to != address(0), \\\"INVALID_RECIPIENT\\\");\\n\\n        require(\\n            msg.sender == from || isApprovedForAll[from][msg.sender] || msg.sender == getApproved[id],\\n            \\\"NOT_AUTHORIZED\\\"\\n        );\\n\\n        // Underflow of the sender's balance is impossible because we check for\\n        // ownership above and the recipient's balance can't realistically overflow.\\n        unchecked {\\n            _balanceOf[from]--;\\n\\n            _balanceOf[to]++;\\n        }\\n\\n        _ownerOf[id] = to;\\n\\n        delete getApproved[id];\\n\\n        emit Transfer(from, to, id);\\n    }\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id\\n    ) public virtual {\\n        transferFrom(from, to, id);\\n\\n        require(\\n            to.code.length == 0 ||\\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, \\\"\\\") ==\\n                ERC721TokenReceiver.onERC721Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        bytes calldata data\\n    ) public virtual {\\n        transferFrom(from, to, id);\\n\\n        require(\\n            to.code.length == 0 ||\\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) ==\\n                ERC721TokenReceiver.onERC721Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC165 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\\n        return\\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\\n            interfaceId == 0x80ac58cd || // ERC165 Interface ID for ERC721\\n            interfaceId == 0x5b5e139f; // ERC165 Interface ID for ERC721Metadata\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(address to, uint256 id) internal virtual {\\n        require(to != address(0), \\\"INVALID_RECIPIENT\\\");\\n\\n        require(_ownerOf[id] == address(0), \\\"ALREADY_MINTED\\\");\\n\\n        // Counter overflow is incredibly unrealistic.\\n        unchecked {\\n            _balanceOf[to]++;\\n        }\\n\\n        _ownerOf[id] = to;\\n\\n        emit Transfer(address(0), to, id);\\n    }\\n\\n    function _burn(uint256 id) internal virtual {\\n        address owner = _ownerOf[id];\\n\\n        require(owner != address(0), \\\"NOT_MINTED\\\");\\n\\n        // Ownership check above ensures no underflow.\\n        unchecked {\\n            _balanceOf[owner]--;\\n        }\\n\\n        delete _ownerOf[id];\\n\\n        delete getApproved[id];\\n\\n        emit Transfer(owner, address(0), id);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL SAFE MINT LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _safeMint(address to, uint256 id) internal virtual {\\n        _mint(to, id);\\n\\n        require(\\n            to.code.length == 0 ||\\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, \\\"\\\") ==\\n                ERC721TokenReceiver.onERC721Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    function _safeMint(\\n        address to,\\n        uint256 id,\\n        bytes memory data\\n    ) internal virtual {\\n        _mint(to, id);\\n\\n        require(\\n            to.code.length == 0 ||\\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data) ==\\n                ERC721TokenReceiver.onERC721Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n}\\n\\n/// @notice A generic interface for a contract which properly accepts ERC721 tokens.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC721.sol)\\nabstract contract ERC721TokenReceiver {\\n    function onERC721Received(\\n        address,\\n        address,\\n        uint256,\\n        bytes calldata\\n    ) external virtual returns (bytes4) {\\n        return ERC721TokenReceiver.onERC721Received.selector;\\n    }\\n}\\n\",\"keccak256\":\"0x04af19f16f00ba65ae168d6d10da5210dc18da6bcec6974dccf984ba388aa22d\",\"license\":\"AGPL-3.0-only\"}},\"version\":1}",
  "bytecode": "0x60c06040523480156200001157600080fd5b50604051620016c9380380620016c98339810160408190526200003491620000c8565b6040518060400160405280600a81526020016910da185c1d195c93919560b21b8152506040518060400160405280600481526020016310d3919560e21b8152508160009081620000859190620001ae565b506001620000948282620001ae565b5050506001600160a01b039182166080521660a0526200027a565b6001600160a01b0381168114620000c557600080fd5b50565b60008060408385031215620000dc57600080fd5b8251620000e981620000af565b6020840151909250620000fc81620000af565b809150509250929050565b634e487b7160e01b600052604160045260246000fd5b600181811c908216806200013257607f821691505b6020821081036200015357634e487b7160e01b600052602260045260246000fd5b50919050565b601f821115620001a9576000816000526020600020601f850160051c81016020861015620001845750805b601f850160051c820191505b81811015620001a55782815560010162000190565b5050505b505050565b81516001600160401b03811115620001ca57620001ca62000107565b620001e281620001db84546200011d565b8462000159565b602080601f8311600181146200021a5760008415620002015750858301515b600019600386901b1c1916600185901b178555620001a5565b600085815260208120601f198616915b828110156200024b578886015182559484019460019091019084016200022a565b50858210156200026a5787850151600019600388901b60f8161c191681555b5050505050600190811b01905550565b60805160a05161141b620002ae600039600081816102130152610b850152600081816101480152610a85015261141b6000f3fe608060405234801561001057600080fd5b50600436106101165760003560e01c806370a08231116100a2578063b88d4fde11610071578063b88d4fde14610284578063c87b56dd14610297578063e985e9c5146102e2578063ea6ca8b514610310578063f40adb121461032357600080fd5b806370a0823114610235578063893fd3c01461025657806395d89b4114610269578063a22cb4651461027157600080fd5b8063095ea7b3116100e9578063095ea7b3146101c057806323b872dd146101d557806342842e0e146101e85780636352211e146101fb5780636680e4bd1461020e57600080fd5b806301ffc9a71461011b57806306433b1b1461014357806306fdde0314610182578063081812fc14610197575b600080fd5b61012e610129366004610ddc565b610344565b60405190151581526020015b60405180910390f35b61016a7f000000000000000000000000000000000000000000000000000000000000000081565b6040516001600160a01b03909116815260200161013a565b61018a610396565b60405161013a9190610e46565b61016a6101a5366004610e59565b6004602052600090815260409020546001600160a01b031681565b6101d36101ce366004610e87565b610424565b005b6101d36101e3366004610eb3565b61050b565b6101d36101f6366004610eb3565b6106d2565b61016a610209366004610e59565b6107ca565b61016a7f000000000000000000000000000000000000000000000000000000000000000081565b610248610243366004610ef4565b610821565b60405190815260200161013a565b6101d3610264366004610fb4565b610884565b61018a6108fc565b6101d361027f366004610ffb565b610909565b6101d3610292366004611082565b610975565b61018a6102a5366004610e59565b604080517468747470733a2f2f697066732e696f2f697066732f60581b602082015260358082019390935281518082039093018352605501905290565b61012e6102f03660046110f5565b600560209081526000928352604080842090915290825290205460ff1681565b6101d361031e366004611123565b610a5d565b610336610331366004610e59565b610c0b565b60405161013a92919061118c565b60006301ffc9a760e01b6001600160e01b03198316148061037557506380ac58cd60e01b6001600160e01b03198316145b806103905750635b5e139f60e01b6001600160e01b03198316145b92915050565b600080546103a3906111b6565b80601f01602080910402602001604051908101604052809291908181526020018280546103cf906111b6565b801561041c5780601f106103f15761010080835404028352916020019161041c565b820191906000526020600020905b8154815290600101906020018083116103ff57829003601f168201915b505050505081565b6000818152600260205260409020546001600160a01b03163381148061046d57506001600160a01b038116600090815260056020908152604080832033845290915290205460ff165b6104af5760405162461bcd60e51b815260206004820152600e60248201526d1393d517d055551213d49256915160921b60448201526064015b60405180910390fd5b60008281526004602052604080822080546001600160a01b0319166001600160a01b0387811691821790925591518593918516917f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b92591a4505050565b6000818152600260205260409020546001600160a01b038481169116146105615760405162461bcd60e51b815260206004820152600a60248201526957524f4e475f46524f4d60b01b60448201526064016104a6565b6001600160a01b0382166105ab5760405162461bcd60e51b81526020600482015260116024820152701253959053125117d49150d25412515395607a1b60448201526064016104a6565b336001600160a01b03841614806105e557506001600160a01b038316600090815260056020908152604080832033845290915290205460ff165b8061060657506000818152600460205260409020546001600160a01b031633145b6106435760405162461bcd60e51b815260206004820152600e60248201526d1393d517d055551213d49256915160921b60448201526064016104a6565b6001600160a01b0380841660008181526003602090815260408083208054600019019055938616808352848320805460010190558583526002825284832080546001600160a01b03199081168317909155600490925284832080549092169091559251849392917fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef91a4505050565b6106dd83838361050b565b6001600160a01b0382163b15806107865750604051630a85bd0160e11b8082523360048301526001600160a01b03858116602484015260448301849052608060648401526000608484015290919084169063150b7a029060a4016020604051808303816000875af1158015610756573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061077a91906111f0565b6001600160e01b031916145b6107c55760405162461bcd60e51b815260206004820152601060248201526f155394d0519157d49150d2541251539560821b60448201526064016104a6565b505050565b6000818152600260205260409020546001600160a01b03168061081c5760405162461bcd60e51b815260206004820152600a6024820152691393d517d3525395115160b21b60448201526064016104a6565b919050565b60006001600160a01b0382166108685760405162461bcd60e51b815260206004820152600c60248201526b5a45524f5f4144445245535360a01b60448201526064016104a6565b506001600160a01b031660009081526003602052604090205490565b3361088e836107ca565b6001600160a01b0316146108e45760405162461bcd60e51b815260206004820152601d60248201527f4f6e6c79206f776e65722063616e20757064617465206368617074657200000060448201526064016104a6565b60008281526007602052604090206107c5828261125d565b600180546103a3906111b6565b3360008181526005602090815260408083206001600160a01b03871680855290835292819020805460ff191686151590811790915590519081529192917f17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31910160405180910390a35050565b61098085858561050b565b6001600160a01b0384163b1580610a175750604051630a85bd0160e11b808252906001600160a01b0386169063150b7a02906109c89033908a90899089908990600401611346565b6020604051808303816000875af11580156109e7573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610a0b91906111f0565b6001600160e01b031916145b610a565760405162461bcd60e51b815260206004820152601060248201526f155394d0519157d49150d2541251539560821b60448201526064016104a6565b5050505050565b600654604051633f2891eb60e21b8152466004820152306024820152604481018290526000907f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03169063fca247ac906064016020604051808303816000875af1158015610ad6573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610afa9190611385565b6040805180820182528781526001600160a01b0383166020808301919091526000868152600790915291909120815192935090918190610b3a908261125d565b5060209190910151600190910180546001600160a01b0319166001600160a01b03909216919091179055610b6e3383610cb8565b60405163b6a46b3b60e01b81526001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000169063b6a46b3b90610bbc90879087906004016113a2565b600060405180830381600087803b158015610bd657600080fd5b505af1158015610bea573d6000803e3d6000fd5b505060068054925090506000610bff836113be565b91905055505050505050565b600760205260009081526040902080548190610c26906111b6565b80601f0160208091040260200160405190810160405280929190818152602001828054610c52906111b6565b8015610c9f5780601f10610c7457610100808354040283529160200191610c9f565b820191906000526020600020905b815481529060010190602001808311610c8257829003601f168201915b505050600190930154919250506001600160a01b031682565b6001600160a01b038216610d025760405162461bcd60e51b81526020600482015260116024820152701253959053125117d49150d25412515395607a1b60448201526064016104a6565b6000818152600260205260409020546001600160a01b031615610d585760405162461bcd60e51b815260206004820152600e60248201526d1053149150511657d3525395115160921b60448201526064016104a6565b6001600160a01b038216600081815260036020908152604080832080546001019055848352600290915280822080546001600160a01b0319168417905551839291907fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef908290a45050565b6001600160e01b031981168114610dd957600080fd5b50565b600060208284031215610dee57600080fd5b8135610df981610dc3565b9392505050565b6000815180845260005b81811015610e2657602081850181015186830182015201610e0a565b506000602082860101526020601f19601f83011685010191505092915050565b602081526000610df96020830184610e00565b600060208284031215610e6b57600080fd5b5035919050565b6001600160a01b0381168114610dd957600080fd5b60008060408385031215610e9a57600080fd5b8235610ea581610e72565b946020939093013593505050565b600080600060608486031215610ec857600080fd5b8335610ed381610e72565b92506020840135610ee381610e72565b929592945050506040919091013590565b600060208284031215610f0657600080fd5b8135610df981610e72565b634e487b7160e01b600052604160045260246000fd5b600082601f830112610f3857600080fd5b813567ffffffffffffffff80821115610f5357610f53610f11565b604051601f8301601f19908116603f01168101908282118183101715610f7b57610f7b610f11565b81604052838152866020858801011115610f9457600080fd5b836020870160208301376000602085830101528094505050505092915050565b60008060408385031215610fc757600080fd5b82359150602083013567ffffffffffffffff811115610fe557600080fd5b610ff185828601610f27565b9150509250929050565b6000806040838503121561100e57600080fd5b823561101981610e72565b91506020830135801515811461102e57600080fd5b809150509250929050565b60008083601f84011261104b57600080fd5b50813567ffffffffffffffff81111561106357600080fd5b60208301915083602082850101111561107b57600080fd5b9250929050565b60008060008060006080868803121561109a57600080fd5b85356110a581610e72565b945060208601356110b581610e72565b935060408601359250606086013567ffffffffffffffff8111156110d857600080fd5b6110e488828901611039565b969995985093965092949392505050565b6000806040838503121561110857600080fd5b823561111381610e72565b9150602083013561102e81610e72565b60008060006040848603121561113857600080fd5b833567ffffffffffffffff8082111561115057600080fd5b61115c87838801610f27565b9450602086013591508082111561117257600080fd5b5061117f86828701611039565b9497909650939450505050565b60408152600061119f6040830185610e00565b905060018060a01b03831660208301529392505050565b600181811c908216806111ca57607f821691505b6020821081036111ea57634e487b7160e01b600052602260045260246000fd5b50919050565b60006020828403121561120257600080fd5b8151610df981610dc3565b601f8211156107c5576000816000526020600020601f850160051c810160208610156112365750805b601f850160051c820191505b8181101561125557828155600101611242565b505050505050565b815167ffffffffffffffff81111561127757611277610f11565b61128b8161128584546111b6565b8461120d565b602080601f8311600181146112c057600084156112a85750858301515b600019600386901b1c1916600185901b178555611255565b600085815260208120601f198616915b828110156112ef578886015182559484019460019091019084016112d0565b508582101561130d5787850151600019600388901b60f8161c191681555b5050505050600190811b01905550565b81835281816020850137506000828201602090810191909152601f909101601f19169091010190565b6001600160a01b038681168252851660208201526040810184905260806060820181905260009061137a908301848661131d565b979650505050505050565b60006020828403121561139757600080fd5b8151610df981610e72565b6020815260006113b660208301848661131d565b949350505050565b6000600182016113de57634e487b7160e01b600052601160045260246000fd5b506001019056fea2646970667358221220fc7f93f8bdaeb4854797b57cee138d4d44107af559f7bfdf9f0dde3d105877c564736f6c63430008170033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106101165760003560e01c806370a08231116100a2578063b88d4fde11610071578063b88d4fde14610284578063c87b56dd14610297578063e985e9c5146102e2578063ea6ca8b514610310578063f40adb121461032357600080fd5b806370a0823114610235578063893fd3c01461025657806395d89b4114610269578063a22cb4651461027157600080fd5b8063095ea7b3116100e9578063095ea7b3146101c057806323b872dd146101d557806342842e0e146101e85780636352211e146101fb5780636680e4bd1461020e57600080fd5b806301ffc9a71461011b57806306433b1b1461014357806306fdde0314610182578063081812fc14610197575b600080fd5b61012e610129366004610ddc565b610344565b60405190151581526020015b60405180910390f35b61016a7f000000000000000000000000000000000000000000000000000000000000000081565b6040516001600160a01b03909116815260200161013a565b61018a610396565b60405161013a9190610e46565b61016a6101a5366004610e59565b6004602052600090815260409020546001600160a01b031681565b6101d36101ce366004610e87565b610424565b005b6101d36101e3366004610eb3565b61050b565b6101d36101f6366004610eb3565b6106d2565b61016a610209366004610e59565b6107ca565b61016a7f000000000000000000000000000000000000000000000000000000000000000081565b610248610243366004610ef4565b610821565b60405190815260200161013a565b6101d3610264366004610fb4565b610884565b61018a6108fc565b6101d361027f366004610ffb565b610909565b6101d3610292366004611082565b610975565b61018a6102a5366004610e59565b604080517468747470733a2f2f697066732e696f2f697066732f60581b602082015260358082019390935281518082039093018352605501905290565b61012e6102f03660046110f5565b600560209081526000928352604080842090915290825290205460ff1681565b6101d361031e366004611123565b610a5d565b610336610331366004610e59565b610c0b565b60405161013a92919061118c565b60006301ffc9a760e01b6001600160e01b03198316148061037557506380ac58cd60e01b6001600160e01b03198316145b806103905750635b5e139f60e01b6001600160e01b03198316145b92915050565b600080546103a3906111b6565b80601f01602080910402602001604051908101604052809291908181526020018280546103cf906111b6565b801561041c5780601f106103f15761010080835404028352916020019161041c565b820191906000526020600020905b8154815290600101906020018083116103ff57829003601f168201915b505050505081565b6000818152600260205260409020546001600160a01b03163381148061046d57506001600160a01b038116600090815260056020908152604080832033845290915290205460ff165b6104af5760405162461bcd60e51b815260206004820152600e60248201526d1393d517d055551213d49256915160921b60448201526064015b60405180910390fd5b60008281526004602052604080822080546001600160a01b0319166001600160a01b0387811691821790925591518593918516917f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b92591a4505050565b6000818152600260205260409020546001600160a01b038481169116146105615760405162461bcd60e51b815260206004820152600a60248201526957524f4e475f46524f4d60b01b60448201526064016104a6565b6001600160a01b0382166105ab5760405162461bcd60e51b81526020600482015260116024820152701253959053125117d49150d25412515395607a1b60448201526064016104a6565b336001600160a01b03841614806105e557506001600160a01b038316600090815260056020908152604080832033845290915290205460ff165b8061060657506000818152600460205260409020546001600160a01b031633145b6106435760405162461bcd60e51b815260206004820152600e60248201526d1393d517d055551213d49256915160921b60448201526064016104a6565b6001600160a01b0380841660008181526003602090815260408083208054600019019055938616808352848320805460010190558583526002825284832080546001600160a01b03199081168317909155600490925284832080549092169091559251849392917fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef91a4505050565b6106dd83838361050b565b6001600160a01b0382163b15806107865750604051630a85bd0160e11b8082523360048301526001600160a01b03858116602484015260448301849052608060648401526000608484015290919084169063150b7a029060a4016020604051808303816000875af1158015610756573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061077a91906111f0565b6001600160e01b031916145b6107c55760405162461bcd60e51b815260206004820152601060248201526f155394d0519157d49150d2541251539560821b60448201526064016104a6565b505050565b6000818152600260205260409020546001600160a01b03168061081c5760405162461bcd60e51b815260206004820152600a6024820152691393d517d3525395115160b21b60448201526064016104a6565b919050565b60006001600160a01b0382166108685760405162461bcd60e51b815260206004820152600c60248201526b5a45524f5f4144445245535360a01b60448201526064016104a6565b506001600160a01b031660009081526003602052604090205490565b3361088e836107ca565b6001600160a01b0316146108e45760405162461bcd60e51b815260206004820152601d60248201527f4f6e6c79206f776e65722063616e20757064617465206368617074657200000060448201526064016104a6565b60008281526007602052604090206107c5828261125d565b600180546103a3906111b6565b3360008181526005602090815260408083206001600160a01b03871680855290835292819020805460ff191686151590811790915590519081529192917f17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31910160405180910390a35050565b61098085858561050b565b6001600160a01b0384163b1580610a175750604051630a85bd0160e11b808252906001600160a01b0386169063150b7a02906109c89033908a90899089908990600401611346565b6020604051808303816000875af11580156109e7573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610a0b91906111f0565b6001600160e01b031916145b610a565760405162461bcd60e51b815260206004820152601060248201526f155394d0519157d49150d2541251539560821b60448201526064016104a6565b5050505050565b600654604051633f2891eb60e21b8152466004820152306024820152604481018290526000907f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03169063fca247ac906064016020604051808303816000875af1158015610ad6573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610afa9190611385565b6040805180820182528781526001600160a01b0383166020808301919091526000868152600790915291909120815192935090918190610b3a908261125d565b5060209190910151600190910180546001600160a01b0319166001600160a01b03909216919091179055610b6e3383610cb8565b60405163b6a46b3b60e01b81526001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000169063b6a46b3b90610bbc90879087906004016113a2565b600060405180830381600087803b158015610bd657600080fd5b505af1158015610bea573d6000803e3d6000fd5b505060068054925090506000610bff836113be565b91905055505050505050565b600760205260009081526040902080548190610c26906111b6565b80601f0160208091040260200160405190810160405280929190818152602001828054610c52906111b6565b8015610c9f5780601f10610c7457610100808354040283529160200191610c9f565b820191906000526020600020905b815481529060010190602001808311610c8257829003601f168201915b505050600190930154919250506001600160a01b031682565b6001600160a01b038216610d025760405162461bcd60e51b81526020600482015260116024820152701253959053125117d49150d25412515395607a1b60448201526064016104a6565b6000818152600260205260409020546001600160a01b031615610d585760405162461bcd60e51b815260206004820152600e60248201526d1053149150511657d3525395115160921b60448201526064016104a6565b6001600160a01b038216600081815260036020908152604080832080546001019055848352600290915280822080546001600160a01b0319168417905551839291907fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef908290a45050565b6001600160e01b031981168114610dd957600080fd5b50565b600060208284031215610dee57600080fd5b8135610df981610dc3565b9392505050565b6000815180845260005b81811015610e2657602081850181015186830182015201610e0a565b506000602082860101526020601f19601f83011685010191505092915050565b602081526000610df96020830184610e00565b600060208284031215610e6b57600080fd5b5035919050565b6001600160a01b0381168114610dd957600080fd5b60008060408385031215610e9a57600080fd5b8235610ea581610e72565b946020939093013593505050565b600080600060608486031215610ec857600080fd5b8335610ed381610e72565b92506020840135610ee381610e72565b929592945050506040919091013590565b600060208284031215610f0657600080fd5b8135610df981610e72565b634e487b7160e01b600052604160045260246000fd5b600082601f830112610f3857600080fd5b813567ffffffffffffffff80821115610f5357610f53610f11565b604051601f8301601f19908116603f01168101908282118183101715610f7b57610f7b610f11565b81604052838152866020858801011115610f9457600080fd5b836020870160208301376000602085830101528094505050505092915050565b60008060408385031215610fc757600080fd5b82359150602083013567ffffffffffffffff811115610fe557600080fd5b610ff185828601610f27565b9150509250929050565b6000806040838503121561100e57600080fd5b823561101981610e72565b91506020830135801515811461102e57600080fd5b809150509250929050565b60008083601f84011261104b57600080fd5b50813567ffffffffffffffff81111561106357600080fd5b60208301915083602082850101111561107b57600080fd5b9250929050565b60008060008060006080868803121561109a57600080fd5b85356110a581610e72565b945060208601356110b581610e72565b935060408601359250606086013567ffffffffffffffff8111156110d857600080fd5b6110e488828901611039565b969995985093965092949392505050565b6000806040838503121561110857600080fd5b823561111381610e72565b9150602083013561102e81610e72565b60008060006040848603121561113857600080fd5b833567ffffffffffffffff8082111561115057600080fd5b61115c87838801610f27565b9450602086013591508082111561117257600080fd5b5061117f86828701611039565b9497909650939450505050565b60408152600061119f6040830185610e00565b905060018060a01b03831660208301529392505050565b600181811c908216806111ca57607f821691505b6020821081036111ea57634e487b7160e01b600052602260045260246000fd5b50919050565b60006020828403121561120257600080fd5b8151610df981610dc3565b601f8211156107c5576000816000526020600020601f850160051c810160208610156112365750805b601f850160051c820191505b8181101561125557828155600101611242565b505050505050565b815167ffffffffffffffff81111561127757611277610f11565b61128b8161128584546111b6565b8461120d565b602080601f8311600181146112c057600084156112a85750858301515b600019600386901b1c1916600185901b178555611255565b600085815260208120601f198616915b828110156112ef578886015182559484019460019091019084016112d0565b508582101561130d5787850151600019600388901b60f8161c191681555b5050505050600190811b01905550565b81835281816020850137506000828201602090810191909152601f909101601f19169091010190565b6001600160a01b038681168252851660208201526040810184905260806060820181905260009061137a908301848661131d565b979650505050505050565b60006020828403121561139757600080fd5b8151610df981610e72565b6020815260006113b660208301848661131d565b949350505050565b6000600182016113de57634e487b7160e01b600052601160045260246000fd5b506001019056fea2646970667358221220fc7f93f8bdaeb4854797b57cee138d4d44107af559f7bfdf9f0dde3d105877c564736f6c63430008170033",
  "devdoc": {
    "kind": "dev",
    "methods": {},
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 20588,
        "contract": "contracts/creader-io/ChapterNFT.sol:ChapterNFT",
        "label": "name",
        "offset": 0,
        "slot": "0",
        "type": "t_string_storage"
      },
      {
        "astId": 20590,
        "contract": "contracts/creader-io/ChapterNFT.sol:ChapterNFT",
        "label": "symbol",
        "offset": 0,
        "slot": "1",
        "type": "t_string_storage"
      },
      {
        "astId": 20601,
        "contract": "contracts/creader-io/ChapterNFT.sol:ChapterNFT",
        "label": "_ownerOf",
        "offset": 0,
        "slot": "2",
        "type": "t_mapping(t_uint256,t_address)"
      },
      {
        "astId": 20605,
        "contract": "contracts/creader-io/ChapterNFT.sol:ChapterNFT",
        "label": "_balanceOf",
        "offset": 0,
        "slot": "3",
        "type": "t_mapping(t_address,t_uint256)"
      },
      {
        "astId": 20654,
        "contract": "contracts/creader-io/ChapterNFT.sol:ChapterNFT",
        "label": "getApproved",
        "offset": 0,
        "slot": "4",
        "type": "t_mapping(t_uint256,t_address)"
      },
      {
        "astId": 20660,
        "contract": "contracts/creader-io/ChapterNFT.sol:ChapterNFT",
        "label": "isApprovedForAll",
        "offset": 0,
        "slot": "5",
        "type": "t_mapping(t_address,t_mapping(t_address,t_bool))"
      },
      {
        "astId": 10231,
        "contract": "contracts/creader-io/ChapterNFT.sol:ChapterNFT",
        "label": "_tokenIds",
        "offset": 0,
        "slot": "6",
        "type": "t_uint256"
      },
      {
        "astId": 10241,
        "contract": "contracts/creader-io/ChapterNFT.sol:ChapterNFT",
        "label": "chapters",
        "offset": 0,
        "slot": "7",
        "type": "t_mapping(t_uint256,t_struct(Chapter)10236_storage)"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_bool": {
        "encoding": "inplace",
        "label": "bool",
        "numberOfBytes": "1"
      },
      "t_mapping(t_address,t_bool)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => bool)",
        "numberOfBytes": "32",
        "value": "t_bool"
      },
      "t_mapping(t_address,t_mapping(t_address,t_bool))": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => mapping(address => bool))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_address,t_bool)"
      },
      "t_mapping(t_address,t_uint256)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => uint256)",
        "numberOfBytes": "32",
        "value": "t_uint256"
      },
      "t_mapping(t_uint256,t_address)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => address)",
        "numberOfBytes": "32",
        "value": "t_address"
      },
      "t_mapping(t_uint256,t_struct(Chapter)10236_storage)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => struct ChapterNFT.Chapter)",
        "numberOfBytes": "32",
        "value": "t_struct(Chapter)10236_storage"
      },
      "t_string_storage": {
        "encoding": "bytes",
        "label": "string",
        "numberOfBytes": "32"
      },
      "t_struct(Chapter)10236_storage": {
        "encoding": "inplace",
        "label": "struct ChapterNFT.Chapter",
        "members": [
          {
            "astId": 10233,
            "contract": "contracts/creader-io/ChapterNFT.sol:ChapterNFT",
            "label": "title",
            "offset": 0,
            "slot": "0",
            "type": "t_string_storage"
          },
          {
            "astId": 10235,
            "contract": "contracts/creader-io/ChapterNFT.sol:ChapterNFT",
            "label": "owner",
            "offset": 0,
            "slot": "1",
            "type": "t_address"
          }
        ],
        "numberOfBytes": "64"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      }
    }
  }
}