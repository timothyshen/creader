{
  "address": "0xCC7FFa72227f9D3E055dB92c90e99181B125c130",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_registry",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [],
      "name": "Unauthorized",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "owner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "operator",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "bool",
          "name": "approved",
          "type": "bool"
        }
      ],
      "name": "ApprovalForAll",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "sender",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "ipId",
          "type": "address"
        }
      ],
      "name": "ChapterCreated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "assetId",
          "type": "uint256"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "sender",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "string",
          "name": "arTxId",
          "type": "string"
        }
      ],
      "name": "Create",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "assetId",
          "type": "uint256"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "sender",
          "type": "address"
        }
      ],
      "name": "Remove",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "enum Bodhi.TradeType",
          "name": "tradeType",
          "type": "uint8"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "assetId",
          "type": "uint256"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "sender",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "tokenAmount",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "ethAmount",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "creatorFee",
          "type": "uint256"
        }
      ],
      "name": "Trade",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "operator",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "from",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256[]",
          "name": "ids",
          "type": "uint256[]"
        },
        {
          "indexed": false,
          "internalType": "uint256[]",
          "name": "amounts",
          "type": "uint256[]"
        }
      ],
      "name": "TransferBatch",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "operator",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "from",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "id",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "TransferSingle",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "string",
          "name": "value",
          "type": "string"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "id",
          "type": "uint256"
        }
      ],
      "name": "URI",
      "type": "event"
    },
    {
      "inputs": [],
      "name": "CREATOR_FEE_PERCENT",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "CREATOR_PREMINT",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "REGISTRY_MODULE",
      "outputs": [
        {
          "internalType": "contract IPAssetRegistry",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "assetIndex",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "assets",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "id",
          "type": "uint256"
        },
        {
          "internalType": "string",
          "name": "arTxId",
          "type": "string"
        },
        {
          "internalType": "address",
          "name": "creator",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "balanceOf",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address[]",
          "name": "owners",
          "type": "address[]"
        },
        {
          "internalType": "uint256[]",
          "name": "ids",
          "type": "uint256[]"
        }
      ],
      "name": "balanceOfBatch",
      "outputs": [
        {
          "internalType": "uint256[]",
          "name": "balances",
          "type": "uint256[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "assetId",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "buy",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "user",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "assetId",
          "type": "uint256"
        }
      ],
      "name": "checkIfUserHasShares",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "string",
          "name": "arTxId",
          "type": "string"
        }
      ],
      "name": "createChapter",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "addr",
          "type": "address"
        }
      ],
      "name": "getAssetIdsByAddress",
      "outputs": [
        {
          "internalType": "uint256[]",
          "name": "",
          "type": "uint256[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "assetId",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "getBuyPrice",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "assetId",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "getBuyPriceAfterFee",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "supply",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "getPrice",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "assetId",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "getSellPrice",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "assetId",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "getSellPriceAfterFee",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "name": "isApprovedForAll",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "pool",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "assetId",
          "type": "uint256"
        }
      ],
      "name": "remove",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "from",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "internalType": "uint256[]",
          "name": "ids",
          "type": "uint256[]"
        },
        {
          "internalType": "uint256[]",
          "name": "amounts",
          "type": "uint256[]"
        },
        {
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        }
      ],
      "name": "safeBatchTransferFrom",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "from",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "id",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        },
        {
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        }
      ],
      "name": "safeTransferFrom",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "assetId",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "sell",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "operator",
          "type": "address"
        },
        {
          "internalType": "bool",
          "name": "approved",
          "type": "bool"
        }
      ],
      "name": "setApprovalForAll",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes4",
          "name": "interfaceId",
          "type": "bytes4"
        }
      ],
      "name": "supportsInterface",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "totalSupply",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "name": "txToAssetId",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "id",
          "type": "uint256"
        }
      ],
      "name": "uri",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "userAssets",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0x18062a8e28b55bf83bdaecf2c175dcbfe925d107b8657a40d9e260ad6f853f1a",
  "receipt": {
    "to": null,
    "from": "0xcC2042a7c7997a04e26389B9689f2AE766342732",
    "contractAddress": "0xCC7FFa72227f9D3E055dB92c90e99181B125c130",
    "transactionIndex": 48,
    "gasUsed": "2089346",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0xbe284522087a5bba3ac2ef193a9d8e5ac0958282a51baa6a4ffa327e3b8ab2e2",
    "transactionHash": "0x18062a8e28b55bf83bdaecf2c175dcbfe925d107b8657a40d9e260ad6f853f1a",
    "logs": [],
    "blockNumber": 6528088,
    "cumulativeGasUsed": "11704915",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0xd43fE0d865cb5C26b1351d3eAf2E3064BE3276F6"
  ],
  "numDeployments": 3,
  "solcInputHash": "25bbaf6148c07614d09ac293878fc6b2",
  "metadata": "{\"compiler\":{\"version\":\"0.8.23+commit.f704f362\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_registry\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"Unauthorized\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"ipId\",\"type\":\"address\"}],\"name\":\"ChapterCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"assetId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"arTxId\",\"type\":\"string\"}],\"name\":\"Create\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"assetId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"Remove\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"enum Bodhi.TradeType\",\"name\":\"tradeType\",\"type\":\"uint8\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"assetId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ethAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"creatorFee\",\"type\":\"uint256\"}],\"name\":\"Trade\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"TransferBatch\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TransferSingle\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"value\",\"type\":\"string\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"URI\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"CREATOR_FEE_PERCENT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CREATOR_PREMINT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"REGISTRY_MODULE\",\"outputs\":[{\"internalType\":\"contract IPAssetRegistry\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"assetIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"assets\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"arTxId\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"owners\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"}],\"name\":\"balanceOfBatch\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"balances\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"assetId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"buy\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"assetId\",\"type\":\"uint256\"}],\"name\":\"checkIfUserHasShares\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"arTxId\",\"type\":\"string\"}],\"name\":\"createChapter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"getAssetIdsByAddress\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"assetId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"getBuyPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"assetId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"getBuyPriceAfterFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"supply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"getPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"assetId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"getSellPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"assetId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"getSellPriceAfterFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"pool\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"assetId\",\"type\":\"uint256\"}],\"name\":\"remove\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeBatchTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"assetId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"sell\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"txToAssetId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"uri\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"userAssets\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/shares/bodhi.sol\":\"Bodhi\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts-upgradeable/access/manager/AccessManagedUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (access/manager/AccessManaged.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IAuthority} from \\\"@openzeppelin/contracts/access/manager/IAuthority.sol\\\";\\nimport {AuthorityUtils} from \\\"@openzeppelin/contracts/access/manager/AuthorityUtils.sol\\\";\\nimport {IAccessManager} from \\\"@openzeppelin/contracts/access/manager/IAccessManager.sol\\\";\\nimport {IAccessManaged} from \\\"@openzeppelin/contracts/access/manager/IAccessManaged.sol\\\";\\nimport {ContextUpgradeable} from \\\"../../utils/ContextUpgradeable.sol\\\";\\nimport {Initializable} from \\\"../../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev This contract module makes available a {restricted} modifier. Functions decorated with this modifier will be\\n * permissioned according to an \\\"authority\\\": a contract like {AccessManager} that follows the {IAuthority} interface,\\n * implementing a policy that allows certain callers to access certain functions.\\n *\\n * IMPORTANT: The `restricted` modifier should never be used on `internal` functions, judiciously used in `public`\\n * functions, and ideally only used in `external` functions. See {restricted}.\\n */\\nabstract contract AccessManagedUpgradeable is Initializable, ContextUpgradeable, IAccessManaged {\\n    /// @custom:storage-location erc7201:openzeppelin.storage.AccessManaged\\n    struct AccessManagedStorage {\\n        address _authority;\\n\\n        bool _consumingSchedule;\\n    }\\n\\n    // keccak256(abi.encode(uint256(keccak256(\\\"openzeppelin.storage.AccessManaged\\\")) - 1)) & ~bytes32(uint256(0xff))\\n    bytes32 private constant AccessManagedStorageLocation = 0xf3177357ab46d8af007ab3fdb9af81da189e1068fefdc0073dca88a2cab40a00;\\n\\n    function _getAccessManagedStorage() private pure returns (AccessManagedStorage storage $) {\\n        assembly {\\n            $.slot := AccessManagedStorageLocation\\n        }\\n    }\\n\\n    /**\\n     * @dev Initializes the contract connected to an initial authority.\\n     */\\n    function __AccessManaged_init(address initialAuthority) internal onlyInitializing {\\n        __AccessManaged_init_unchained(initialAuthority);\\n    }\\n\\n    function __AccessManaged_init_unchained(address initialAuthority) internal onlyInitializing {\\n        _setAuthority(initialAuthority);\\n    }\\n\\n    /**\\n     * @dev Restricts access to a function as defined by the connected Authority for this contract and the\\n     * caller and selector of the function that entered the contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * In general, this modifier should only be used on `external` functions. It is okay to use it on `public`\\n     * functions that are used as external entry points and are not called internally. Unless you know what you're\\n     * doing, it should never be used on `internal` functions. Failure to follow these rules can have critical security\\n     * implications! This is because the permissions are determined by the function that entered the contract, i.e. the\\n     * function at the bottom of the call stack, and not the function where the modifier is visible in the source code.\\n     * ====\\n     *\\n     * [WARNING]\\n     * ====\\n     * Avoid adding this modifier to the https://docs.soliditylang.org/en/v0.8.20/contracts.html#receive-ether-function[`receive()`]\\n     * function or the https://docs.soliditylang.org/en/v0.8.20/contracts.html#fallback-function[`fallback()`]. These\\n     * functions are the only execution paths where a function selector cannot be unambiguosly determined from the calldata\\n     * since the selector defaults to `0x00000000` in the `receive()` function and similarly in the `fallback()` function\\n     * if no calldata is provided. (See {_checkCanCall}).\\n     *\\n     * The `receive()` function will always panic whereas the `fallback()` may panic depending on the calldata length.\\n     * ====\\n     */\\n    modifier restricted() {\\n        _checkCanCall(_msgSender(), _msgData());\\n        _;\\n    }\\n\\n    /// @inheritdoc IAccessManaged\\n    function authority() public view virtual returns (address) {\\n        AccessManagedStorage storage $ = _getAccessManagedStorage();\\n        return $._authority;\\n    }\\n\\n    /// @inheritdoc IAccessManaged\\n    function setAuthority(address newAuthority) public virtual {\\n        address caller = _msgSender();\\n        if (caller != authority()) {\\n            revert AccessManagedUnauthorized(caller);\\n        }\\n        if (newAuthority.code.length == 0) {\\n            revert AccessManagedInvalidAuthority(newAuthority);\\n        }\\n        _setAuthority(newAuthority);\\n    }\\n\\n    /// @inheritdoc IAccessManaged\\n    function isConsumingScheduledOp() public view returns (bytes4) {\\n        AccessManagedStorage storage $ = _getAccessManagedStorage();\\n        return $._consumingSchedule ? this.isConsumingScheduledOp.selector : bytes4(0);\\n    }\\n\\n    /**\\n     * @dev Transfers control to a new authority. Internal function with no access restriction. Allows bypassing the\\n     * permissions set by the current authority.\\n     */\\n    function _setAuthority(address newAuthority) internal virtual {\\n        AccessManagedStorage storage $ = _getAccessManagedStorage();\\n        $._authority = newAuthority;\\n        emit AuthorityUpdated(newAuthority);\\n    }\\n\\n    /**\\n     * @dev Reverts if the caller is not allowed to call the function identified by a selector. Panics if the calldata\\n     * is less than 4 bytes long.\\n     */\\n    function _checkCanCall(address caller, bytes calldata data) internal virtual {\\n        AccessManagedStorage storage $ = _getAccessManagedStorage();\\n        (bool immediate, uint32 delay) = AuthorityUtils.canCallWithDelay(\\n            authority(),\\n            caller,\\n            address(this),\\n            bytes4(data[0:4])\\n        );\\n        if (!immediate) {\\n            if (delay > 0) {\\n                $._consumingSchedule = true;\\n                IAccessManager(authority()).consumeScheduledOp(caller, data);\\n                $._consumingSchedule = false;\\n            } else {\\n                revert AccessManagedUnauthorized(caller);\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xd7e800ed57cb2dc4ce3d38fc310cf6c4918c0a67f9071ef8fb3e0cff24be6446\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\\n * reused. This mechanism prevents re-execution of each \\\"step\\\" but allows the creation of new initialization steps in\\n * case an upgrade adds a module that needs to be initialized.\\n *\\n * For example:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```solidity\\n * contract MyToken is ERC20Upgradeable {\\n *     function initialize() initializer public {\\n *         __ERC20_init(\\\"MyToken\\\", \\\"MTK\\\");\\n *     }\\n * }\\n *\\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\\n *     function initializeV2() reinitializer(2) public {\\n *         __ERC20Permit_init(\\\"MyToken\\\");\\n *     }\\n * }\\n * ```\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() {\\n *     _disableInitializers();\\n * }\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Storage of the initializable contract.\\n     *\\n     * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\\n     * when using with upgradeable contracts.\\n     *\\n     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\\n     */\\n    struct InitializableStorage {\\n        /**\\n         * @dev Indicates that the contract has been initialized.\\n         */\\n        uint64 _initialized;\\n        /**\\n         * @dev Indicates that the contract is in the process of being initialized.\\n         */\\n        bool _initializing;\\n    }\\n\\n    // keccak256(abi.encode(uint256(keccak256(\\\"openzeppelin.storage.Initializable\\\")) - 1)) & ~bytes32(uint256(0xff))\\n    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\\n\\n    /**\\n     * @dev The contract is already initialized.\\n     */\\n    error InvalidInitialization();\\n\\n    /**\\n     * @dev The contract is not initializing.\\n     */\\n    error NotInitializing();\\n\\n    /**\\n     * @dev Triggered when the contract has been initialized or reinitialized.\\n     */\\n    event Initialized(uint64 version);\\n\\n    /**\\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\\n     * `onlyInitializing` functions can be used to initialize parent contracts.\\n     *\\n     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\\n     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\\n     * production.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier initializer() {\\n        // solhint-disable-next-line var-name-mixedcase\\n        InitializableStorage storage $ = _getInitializableStorage();\\n\\n        // Cache values to avoid duplicated sloads\\n        bool isTopLevelCall = !$._initializing;\\n        uint64 initialized = $._initialized;\\n\\n        // Allowed calls:\\n        // - initialSetup: the contract is not in the initializing state and no previous version was\\n        //                 initialized\\n        // - construction: the contract is initialized at version 1 (no reininitialization) and the\\n        //                 current contract is just being deployed\\n        bool initialSetup = initialized == 0 && isTopLevelCall;\\n        bool construction = initialized == 1 && address(this).code.length == 0;\\n\\n        if (!initialSetup && !construction) {\\n            revert InvalidInitialization();\\n        }\\n        $._initialized = 1;\\n        if (isTopLevelCall) {\\n            $._initializing = true;\\n        }\\n        _;\\n        if (isTopLevelCall) {\\n            $._initializing = false;\\n            emit Initialized(1);\\n        }\\n    }\\n\\n    /**\\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\\n     * used to initialize parent contracts.\\n     *\\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\\n     * are added through upgrades and that require initialization.\\n     *\\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\\n     *\\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\\n     * a contract, executing them in the right order is up to the developer or operator.\\n     *\\n     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier reinitializer(uint64 version) {\\n        // solhint-disable-next-line var-name-mixedcase\\n        InitializableStorage storage $ = _getInitializableStorage();\\n\\n        if ($._initializing || $._initialized >= version) {\\n            revert InvalidInitialization();\\n        }\\n        $._initialized = version;\\n        $._initializing = true;\\n        _;\\n        $._initializing = false;\\n        emit Initialized(version);\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\\n     */\\n    modifier onlyInitializing() {\\n        _checkInitializing();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\\n     */\\n    function _checkInitializing() internal view virtual {\\n        if (!_isInitializing()) {\\n            revert NotInitializing();\\n        }\\n    }\\n\\n    /**\\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\\n     * through proxies.\\n     *\\n     * Emits an {Initialized} event the first time it is successfully executed.\\n     */\\n    function _disableInitializers() internal virtual {\\n        // solhint-disable-next-line var-name-mixedcase\\n        InitializableStorage storage $ = _getInitializableStorage();\\n\\n        if ($._initializing) {\\n            revert InvalidInitialization();\\n        }\\n        if ($._initialized != type(uint64).max) {\\n            $._initialized = type(uint64).max;\\n            emit Initialized(type(uint64).max);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\\n     */\\n    function _getInitializedVersion() internal view returns (uint64) {\\n        return _getInitializableStorage()._initialized;\\n    }\\n\\n    /**\\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\\n     */\\n    function _isInitializing() internal view returns (bool) {\\n        return _getInitializableStorage()._initializing;\\n    }\\n\\n    /**\\n     * @dev Returns a pointer to the storage namespace.\\n     */\\n    // solhint-disable-next-line var-name-mixedcase\\n    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\\n        assembly {\\n            $.slot := INITIALIZABLE_STORAGE\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x631188737069917d2f909d29ce62c4d48611d326686ba6683e26b72a23bfac0b\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/utils/UUPSUpgradeable.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC1822Proxiable} from \\\"@openzeppelin/contracts/interfaces/draft-IERC1822.sol\\\";\\nimport {ERC1967Utils} from \\\"@openzeppelin/contracts/proxy/ERC1967/ERC1967Utils.sol\\\";\\nimport {Initializable} from \\\"./Initializable.sol\\\";\\n\\n/**\\n * @dev An upgradeability mechanism designed for UUPS proxies. The functions included here can perform an upgrade of an\\n * {ERC1967Proxy}, when this contract is set as the implementation behind such a proxy.\\n *\\n * A security mechanism ensures that an upgrade does not turn off upgradeability accidentally, although this risk is\\n * reinstated if the upgrade retains upgradeability but removes the security mechanism, e.g. by replacing\\n * `UUPSUpgradeable` with a custom implementation of upgrades.\\n *\\n * The {_authorizeUpgrade} function must be overridden to include access restriction to the upgrade mechanism.\\n */\\nabstract contract UUPSUpgradeable is Initializable, IERC1822Proxiable {\\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\\n    address private immutable __self = address(this);\\n\\n    /**\\n     * @dev The version of the upgrade interface of the contract. If this getter is missing, both `upgradeTo(address)`\\n     * and `upgradeToAndCall(address,bytes)` are present, and `upgradeTo` must be used if no function should be called,\\n     * while `upgradeToAndCall` will invoke the `receive` function if the second argument is the empty byte string.\\n     * If the getter returns `\\\"5.0.0\\\"`, only `upgradeToAndCall(address,bytes)` is present, and the second argument must\\n     * be the empty byte string if no function should be called, making it impossible to invoke the `receive` function\\n     * during an upgrade.\\n     */\\n    string public constant UPGRADE_INTERFACE_VERSION = \\\"5.0.0\\\";\\n\\n    /**\\n     * @dev The call is from an unauthorized context.\\n     */\\n    error UUPSUnauthorizedCallContext();\\n\\n    /**\\n     * @dev The storage `slot` is unsupported as a UUID.\\n     */\\n    error UUPSUnsupportedProxiableUUID(bytes32 slot);\\n\\n    /**\\n     * @dev Check that the execution is being performed through a delegatecall call and that the execution context is\\n     * a proxy contract with an implementation (as defined in ERC1967) pointing to self. This should only be the case\\n     * for UUPS and transparent proxies that are using the current contract as their implementation. Execution of a\\n     * function through ERC1167 minimal proxies (clones) would not normally pass this test, but is not guaranteed to\\n     * fail.\\n     */\\n    modifier onlyProxy() {\\n        _checkProxy();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Check that the execution is not being performed through a delegate call. This allows a function to be\\n     * callable on the implementing contract but not through proxies.\\n     */\\n    modifier notDelegated() {\\n        _checkNotDelegated();\\n        _;\\n    }\\n\\n    function __UUPSUpgradeable_init() internal onlyInitializing {\\n    }\\n\\n    function __UUPSUpgradeable_init_unchained() internal onlyInitializing {\\n    }\\n    /**\\n     * @dev Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the\\n     * implementation. It is used to validate the implementation's compatibility when performing an upgrade.\\n     *\\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\\n     * function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier.\\n     */\\n    function proxiableUUID() external view virtual notDelegated returns (bytes32) {\\n        return ERC1967Utils.IMPLEMENTATION_SLOT;\\n    }\\n\\n    /**\\n     * @dev Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call\\n     * encoded in `data`.\\n     *\\n     * Calls {_authorizeUpgrade}.\\n     *\\n     * Emits an {Upgraded} event.\\n     *\\n     * @custom:oz-upgrades-unsafe-allow-reachable delegatecall\\n     */\\n    function upgradeToAndCall(address newImplementation, bytes memory data) public payable virtual onlyProxy {\\n        _authorizeUpgrade(newImplementation);\\n        _upgradeToAndCallUUPS(newImplementation, data);\\n    }\\n\\n    /**\\n     * @dev Reverts if the execution is not performed via delegatecall or the execution\\n     * context is not of a proxy with an ERC1967-compliant implementation pointing to self.\\n     * See {_onlyProxy}.\\n     */\\n    function _checkProxy() internal view virtual {\\n        if (\\n            address(this) == __self || // Must be called through delegatecall\\n            ERC1967Utils.getImplementation() != __self // Must be called through an active proxy\\n        ) {\\n            revert UUPSUnauthorizedCallContext();\\n        }\\n    }\\n\\n    /**\\n     * @dev Reverts if the execution is performed via delegatecall.\\n     * See {notDelegated}.\\n     */\\n    function _checkNotDelegated() internal view virtual {\\n        if (address(this) != __self) {\\n            // Must not be called through delegatecall\\n            revert UUPSUnauthorizedCallContext();\\n        }\\n    }\\n\\n    /**\\n     * @dev Function that should revert when `msg.sender` is not authorized to upgrade the contract. Called by\\n     * {upgradeToAndCall}.\\n     *\\n     * Normally, this function will use an xref:access.adoc[access control] modifier such as {Ownable-onlyOwner}.\\n     *\\n     * ```solidity\\n     * function _authorizeUpgrade(address) internal onlyOwner {}\\n     * ```\\n     */\\n    function _authorizeUpgrade(address newImplementation) internal virtual;\\n\\n    /**\\n     * @dev Performs an implementation upgrade with a security check for UUPS proxies, and additional setup call.\\n     *\\n     * As a security check, {proxiableUUID} is invoked in the new implementation, and the return value\\n     * is expected to be the implementation slot in ERC1967.\\n     *\\n     * Emits an {IERC1967-Upgraded} event.\\n     */\\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data) private {\\n        try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\\n            if (slot != ERC1967Utils.IMPLEMENTATION_SLOT) {\\n                revert UUPSUnsupportedProxiableUUID(slot);\\n            }\\n            ERC1967Utils.upgradeToAndCall(newImplementation, data);\\n        } catch {\\n            // The implementation is not UUPS\\n            revert ERC1967Utils.ERC1967InvalidImplementation(newImplementation);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x3f13b947637c4969c0644cab4ef399cdc4b67f101463b8775c5a43b118558e53\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\\n\\npragma solidity ^0.8.20;\\nimport {Initializable} from \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract ContextUpgradeable is Initializable {\\n    function __Context_init() internal onlyInitializing {\\n    }\\n\\n    function __Context_init_unchained() internal onlyInitializing {\\n    }\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    function _contextSuffixLength() internal view virtual returns (uint256) {\\n        return 0;\\n    }\\n}\\n\",\"keccak256\":\"0xdbef5f0c787055227243a7318ef74c8a5a1108ca3a07f2b3a00ef67769e1e397\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Pausable.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {ContextUpgradeable} from \\\"../utils/ContextUpgradeable.sol\\\";\\nimport {Initializable} from \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract PausableUpgradeable is Initializable, ContextUpgradeable {\\n    /// @custom:storage-location erc7201:openzeppelin.storage.Pausable\\n    struct PausableStorage {\\n        bool _paused;\\n    }\\n\\n    // keccak256(abi.encode(uint256(keccak256(\\\"openzeppelin.storage.Pausable\\\")) - 1)) & ~bytes32(uint256(0xff))\\n    bytes32 private constant PausableStorageLocation = 0xcd5ed15c6e187e77e9aee88184c21f4f2182ab5827cb3b7e07fbedcd63f03300;\\n\\n    function _getPausableStorage() private pure returns (PausableStorage storage $) {\\n        assembly {\\n            $.slot := PausableStorageLocation\\n        }\\n    }\\n\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n\\n    /**\\n     * @dev The operation failed because the contract is paused.\\n     */\\n    error EnforcedPause();\\n\\n    /**\\n     * @dev The operation failed because the contract is not paused.\\n     */\\n    error ExpectedPause();\\n\\n    /**\\n     * @dev Initializes the contract in unpaused state.\\n     */\\n    function __Pausable_init() internal onlyInitializing {\\n        __Pausable_init_unchained();\\n    }\\n\\n    function __Pausable_init_unchained() internal onlyInitializing {\\n        PausableStorage storage $ = _getPausableStorage();\\n        $._paused = false;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        _requireNotPaused();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        _requirePaused();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view virtual returns (bool) {\\n        PausableStorage storage $ = _getPausableStorage();\\n        return $._paused;\\n    }\\n\\n    /**\\n     * @dev Throws if the contract is paused.\\n     */\\n    function _requireNotPaused() internal view virtual {\\n        if (paused()) {\\n            revert EnforcedPause();\\n        }\\n    }\\n\\n    /**\\n     * @dev Throws if the contract is not paused.\\n     */\\n    function _requirePaused() internal view virtual {\\n        if (!paused()) {\\n            revert ExpectedPause();\\n        }\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        PausableStorage storage $ = _getPausableStorage();\\n        $._paused = true;\\n        emit Paused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        PausableStorage storage $ = _getPausableStorage();\\n        $._paused = false;\\n        emit Unpaused(_msgSender());\\n    }\\n}\\n\",\"keccak256\":\"0x92915b7f7f642c6be3f65bfd1522feb5d5b6ef25f755f4dbb51df32c868f2f97\",\"license\":\"MIT\"},\"@openzeppelin/contracts/access/manager/AuthorityUtils.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (access/manager/AuthorityUtils.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IAuthority} from \\\"./IAuthority.sol\\\";\\n\\nlibrary AuthorityUtils {\\n    /**\\n     * @dev Since `AccessManager` implements an extended IAuthority interface, invoking `canCall` with backwards compatibility\\n     * for the preexisting `IAuthority` interface requires special care to avoid reverting on insufficient return data.\\n     * This helper function takes care of invoking `canCall` in a backwards compatible way without reverting.\\n     */\\n    function canCallWithDelay(\\n        address authority,\\n        address caller,\\n        address target,\\n        bytes4 selector\\n    ) internal view returns (bool immediate, uint32 delay) {\\n        (bool success, bytes memory data) = authority.staticcall(\\n            abi.encodeCall(IAuthority.canCall, (caller, target, selector))\\n        );\\n        if (success) {\\n            if (data.length >= 0x40) {\\n                (immediate, delay) = abi.decode(data, (bool, uint32));\\n            } else if (data.length >= 0x20) {\\n                immediate = abi.decode(data, (bool));\\n            }\\n        }\\n        return (immediate, delay);\\n    }\\n}\\n\",\"keccak256\":\"0xb3875997b0d8705e29aa20fee88e1dfef93df438794ae1ad8ba2eb016a4dd4e4\",\"license\":\"MIT\"},\"@openzeppelin/contracts/access/manager/IAccessManaged.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (access/manager/IAccessManaged.sol)\\n\\npragma solidity ^0.8.20;\\n\\ninterface IAccessManaged {\\n    /**\\n     * @dev Authority that manages this contract was updated.\\n     */\\n    event AuthorityUpdated(address authority);\\n\\n    error AccessManagedUnauthorized(address caller);\\n    error AccessManagedRequiredDelay(address caller, uint32 delay);\\n    error AccessManagedInvalidAuthority(address authority);\\n\\n    /**\\n     * @dev Returns the current authority.\\n     */\\n    function authority() external view returns (address);\\n\\n    /**\\n     * @dev Transfers control to a new authority. The caller must be the current authority.\\n     */\\n    function setAuthority(address) external;\\n\\n    /**\\n     * @dev Returns true only in the context of a delayed restricted call, at the moment that the scheduled operation is\\n     * being consumed. Prevents denial of service for delayed restricted calls in the case that the contract performs\\n     * attacker controlled calls.\\n     */\\n    function isConsumingScheduledOp() external view returns (bytes4);\\n}\\n\",\"keccak256\":\"0xaba93d42cd70e1418782951132d97b31ddce5f50ad81090884b6d0e41caac9d6\",\"license\":\"MIT\"},\"@openzeppelin/contracts/access/manager/IAccessManager.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (access/manager/IAccessManager.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IAccessManaged} from \\\"./IAccessManaged.sol\\\";\\nimport {Time} from \\\"../../utils/types/Time.sol\\\";\\n\\ninterface IAccessManager {\\n    /**\\n     * @dev A delayed operation was scheduled.\\n     */\\n    event OperationScheduled(\\n        bytes32 indexed operationId,\\n        uint32 indexed nonce,\\n        uint48 schedule,\\n        address caller,\\n        address target,\\n        bytes data\\n    );\\n\\n    /**\\n     * @dev A scheduled operation was executed.\\n     */\\n    event OperationExecuted(bytes32 indexed operationId, uint32 indexed nonce);\\n\\n    /**\\n     * @dev A scheduled operation was canceled.\\n     */\\n    event OperationCanceled(bytes32 indexed operationId, uint32 indexed nonce);\\n\\n    /**\\n     * @dev Informational labelling for a roleId.\\n     */\\n    event RoleLabel(uint64 indexed roleId, string label);\\n\\n    /**\\n     * @dev Emitted when `account` is granted `roleId`.\\n     *\\n     * NOTE: The meaning of the `since` argument depends on the `newMember` argument.\\n     * If the role is granted to a new member, the `since` argument indicates when the account becomes a member of the role,\\n     * otherwise it indicates the execution delay for this account and roleId is updated.\\n     */\\n    event RoleGranted(uint64 indexed roleId, address indexed account, uint32 delay, uint48 since, bool newMember);\\n\\n    /**\\n     * @dev Emitted when `account` membership or `roleId` is revoked. Unlike granting, revoking is instantaneous.\\n     */\\n    event RoleRevoked(uint64 indexed roleId, address indexed account);\\n\\n    /**\\n     * @dev Role acting as admin over a given `roleId` is updated.\\n     */\\n    event RoleAdminChanged(uint64 indexed roleId, uint64 indexed admin);\\n\\n    /**\\n     * @dev Role acting as guardian over a given `roleId` is updated.\\n     */\\n    event RoleGuardianChanged(uint64 indexed roleId, uint64 indexed guardian);\\n\\n    /**\\n     * @dev Grant delay for a given `roleId` will be updated to `delay` when `since` is reached.\\n     */\\n    event RoleGrantDelayChanged(uint64 indexed roleId, uint32 delay, uint48 since);\\n\\n    /**\\n     * @dev Target mode is updated (true = closed, false = open).\\n     */\\n    event TargetClosed(address indexed target, bool closed);\\n\\n    /**\\n     * @dev Role required to invoke `selector` on `target` is updated to `roleId`.\\n     */\\n    event TargetFunctionRoleUpdated(address indexed target, bytes4 selector, uint64 indexed roleId);\\n\\n    /**\\n     * @dev Admin delay for a given `target` will be updated to `delay` when `since` is reached.\\n     */\\n    event TargetAdminDelayUpdated(address indexed target, uint32 delay, uint48 since);\\n\\n    error AccessManagerAlreadyScheduled(bytes32 operationId);\\n    error AccessManagerNotScheduled(bytes32 operationId);\\n    error AccessManagerNotReady(bytes32 operationId);\\n    error AccessManagerExpired(bytes32 operationId);\\n    error AccessManagerLockedAccount(address account);\\n    error AccessManagerLockedRole(uint64 roleId);\\n    error AccessManagerBadConfirmation();\\n    error AccessManagerUnauthorizedAccount(address msgsender, uint64 roleId);\\n    error AccessManagerUnauthorizedCall(address caller, address target, bytes4 selector);\\n    error AccessManagerUnauthorizedConsume(address target);\\n    error AccessManagerUnauthorizedCancel(address msgsender, address caller, address target, bytes4 selector);\\n    error AccessManagerInvalidInitialAdmin(address initialAdmin);\\n\\n    /**\\n     * @dev Check if an address (`caller`) is authorised to call a given function on a given contract directly (with\\n     * no restriction). Additionally, it returns the delay needed to perform the call indirectly through the {schedule}\\n     * & {execute} workflow.\\n     *\\n     * This function is usually called by the targeted contract to control immediate execution of restricted functions.\\n     * Therefore we only return true if the call can be performed without any delay. If the call is subject to a\\n     * previously set delay (not zero), then the function should return false and the caller should schedule the operation\\n     * for future execution.\\n     *\\n     * If `immediate` is true, the delay can be disregarded and the operation can be immediately executed, otherwise\\n     * the operation can be executed if and only if delay is greater than 0.\\n     *\\n     * NOTE: The IAuthority interface does not include the `uint32` delay. This is an extension of that interface that\\n     * is backward compatible. Some contracts may thus ignore the second return argument. In that case they will fail\\n     * to identify the indirect workflow, and will consider calls that require a delay to be forbidden.\\n     *\\n     * NOTE: This function does not report the permissions of this manager itself. These are defined by the\\n     * {_canCallSelf} function instead.\\n     */\\n    function canCall(\\n        address caller,\\n        address target,\\n        bytes4 selector\\n    ) external view returns (bool allowed, uint32 delay);\\n\\n    /**\\n     * @dev Expiration delay for scheduled proposals. Defaults to 1 week.\\n     *\\n     * IMPORTANT: Avoid overriding the expiration with 0. Otherwise every contract proposal will be expired immediately,\\n     * disabling any scheduling usage.\\n     */\\n    function expiration() external view returns (uint32);\\n\\n    /**\\n     * @dev Minimum setback for all delay updates, with the exception of execution delays. It\\n     * can be increased without setback (and reset via {revokeRole} in the case event of an\\n     * accidental increase). Defaults to 5 days.\\n     */\\n    function minSetback() external view returns (uint32);\\n\\n    /**\\n     * @dev Get whether the contract is closed disabling any access. Otherwise role permissions are applied.\\n     */\\n    function isTargetClosed(address target) external view returns (bool);\\n\\n    /**\\n     * @dev Get the role required to call a function.\\n     */\\n    function getTargetFunctionRole(address target, bytes4 selector) external view returns (uint64);\\n\\n    /**\\n     * @dev Get the admin delay for a target contract. Changes to contract configuration are subject to this delay.\\n     */\\n    function getTargetAdminDelay(address target) external view returns (uint32);\\n\\n    /**\\n     * @dev Get the id of the role that acts as an admin for the given role.\\n     *\\n     * The admin permission is required to grant the role, revoke the role and update the execution delay to execute\\n     * an operation that is restricted to this role.\\n     */\\n    function getRoleAdmin(uint64 roleId) external view returns (uint64);\\n\\n    /**\\n     * @dev Get the role that acts as a guardian for a given role.\\n     *\\n     * The guardian permission allows canceling operations that have been scheduled under the role.\\n     */\\n    function getRoleGuardian(uint64 roleId) external view returns (uint64);\\n\\n    /**\\n     * @dev Get the role current grant delay.\\n     *\\n     * Its value may change at any point without an event emitted following a call to {setGrantDelay}.\\n     * Changes to this value, including effect timepoint are notified in advance by the {RoleGrantDelayChanged} event.\\n     */\\n    function getRoleGrantDelay(uint64 roleId) external view returns (uint32);\\n\\n    /**\\n     * @dev Get the access details for a given account for a given role. These details include the timepoint at which\\n     * membership becomes active, and the delay applied to all operation by this user that requires this permission\\n     * level.\\n     *\\n     * Returns:\\n     * [0] Timestamp at which the account membership becomes valid. 0 means role is not granted.\\n     * [1] Current execution delay for the account.\\n     * [2] Pending execution delay for the account.\\n     * [3] Timestamp at which the pending execution delay will become active. 0 means no delay update is scheduled.\\n     */\\n    function getAccess(uint64 roleId, address account) external view returns (uint48, uint32, uint32, uint48);\\n\\n    /**\\n     * @dev Check if a given account currently has the permission level corresponding to a given role. Note that this\\n     * permission might be associated with an execution delay. {getAccess} can provide more details.\\n     */\\n    function hasRole(uint64 roleId, address account) external view returns (bool, uint32);\\n\\n    /**\\n     * @dev Give a label to a role, for improved role discoverability by UIs.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be a global admin\\n     *\\n     * Emits a {RoleLabel} event.\\n     */\\n    function labelRole(uint64 roleId, string calldata label) external;\\n\\n    /**\\n     * @dev Add `account` to `roleId`, or change its execution delay.\\n     *\\n     * This gives the account the authorization to call any function that is restricted to this role. An optional\\n     * execution delay (in seconds) can be set. If that delay is non 0, the user is required to schedule any operation\\n     * that is restricted to members of this role. The user will only be able to execute the operation after the delay has\\n     * passed, before it has expired. During this period, admin and guardians can cancel the operation (see {cancel}).\\n     *\\n     * If the account has already been granted this role, the execution delay will be updated. This update is not\\n     * immediate and follows the delay rules. For example, if a user currently has a delay of 3 hours, and this is\\n     * called to reduce that delay to 1 hour, the new delay will take some time to take effect, enforcing that any\\n     * operation executed in the 3 hours that follows this update was indeed scheduled before this update.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be an admin for the role (see {getRoleAdmin})\\n     * - granted role must not be the `PUBLIC_ROLE`\\n     *\\n     * Emits a {RoleGranted} event.\\n     */\\n    function grantRole(uint64 roleId, address account, uint32 executionDelay) external;\\n\\n    /**\\n     * @dev Remove an account from a role, with immediate effect. If the account does not have the role, this call has\\n     * no effect.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be an admin for the role (see {getRoleAdmin})\\n     * - revoked role must not be the `PUBLIC_ROLE`\\n     *\\n     * Emits a {RoleRevoked} event if the account had the role.\\n     */\\n    function revokeRole(uint64 roleId, address account) external;\\n\\n    /**\\n     * @dev Renounce role permissions for the calling account with immediate effect. If the sender is not in\\n     * the role this call has no effect.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `callerConfirmation`.\\n     *\\n     * Emits a {RoleRevoked} event if the account had the role.\\n     */\\n    function renounceRole(uint64 roleId, address callerConfirmation) external;\\n\\n    /**\\n     * @dev Change admin role for a given role.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be a global admin\\n     *\\n     * Emits a {RoleAdminChanged} event\\n     */\\n    function setRoleAdmin(uint64 roleId, uint64 admin) external;\\n\\n    /**\\n     * @dev Change guardian role for a given role.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be a global admin\\n     *\\n     * Emits a {RoleGuardianChanged} event\\n     */\\n    function setRoleGuardian(uint64 roleId, uint64 guardian) external;\\n\\n    /**\\n     * @dev Update the delay for granting a `roleId`.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be a global admin\\n     *\\n     * Emits a {RoleGrantDelayChanged} event.\\n     */\\n    function setGrantDelay(uint64 roleId, uint32 newDelay) external;\\n\\n    /**\\n     * @dev Set the role required to call functions identified by the `selectors` in the `target` contract.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be a global admin\\n     *\\n     * Emits a {TargetFunctionRoleUpdated} event per selector.\\n     */\\n    function setTargetFunctionRole(address target, bytes4[] calldata selectors, uint64 roleId) external;\\n\\n    /**\\n     * @dev Set the delay for changing the configuration of a given target contract.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be a global admin\\n     *\\n     * Emits a {TargetAdminDelayUpdated} event.\\n     */\\n    function setTargetAdminDelay(address target, uint32 newDelay) external;\\n\\n    /**\\n     * @dev Set the closed flag for a contract.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be a global admin\\n     *\\n     * Emits a {TargetClosed} event.\\n     */\\n    function setTargetClosed(address target, bool closed) external;\\n\\n    /**\\n     * @dev Return the timepoint at which a scheduled operation will be ready for execution. This returns 0 if the\\n     * operation is not yet scheduled, has expired, was executed, or was canceled.\\n     */\\n    function getSchedule(bytes32 id) external view returns (uint48);\\n\\n    /**\\n     * @dev Return the nonce for the latest scheduled operation with a given id. Returns 0 if the operation has never\\n     * been scheduled.\\n     */\\n    function getNonce(bytes32 id) external view returns (uint32);\\n\\n    /**\\n     * @dev Schedule a delayed operation for future execution, and return the operation identifier. It is possible to\\n     * choose the timestamp at which the operation becomes executable as long as it satisfies the execution delays\\n     * required for the caller. The special value zero will automatically set the earliest possible time.\\n     *\\n     * Returns the `operationId` that was scheduled. Since this value is a hash of the parameters, it can reoccur when\\n     * the same parameters are used; if this is relevant, the returned `nonce` can be used to uniquely identify this\\n     * scheduled operation from other occurrences of the same `operationId` in invocations of {execute} and {cancel}.\\n     *\\n     * Emits a {OperationScheduled} event.\\n     *\\n     * NOTE: It is not possible to concurrently schedule more than one operation with the same `target` and `data`. If\\n     * this is necessary, a random byte can be appended to `data` to act as a salt that will be ignored by the target\\n     * contract if it is using standard Solidity ABI encoding.\\n     */\\n    function schedule(address target, bytes calldata data, uint48 when) external returns (bytes32, uint32);\\n\\n    /**\\n     * @dev Execute a function that is delay restricted, provided it was properly scheduled beforehand, or the\\n     * execution delay is 0.\\n     *\\n     * Returns the nonce that identifies the previously scheduled operation that is executed, or 0 if the\\n     * operation wasn't previously scheduled (if the caller doesn't have an execution delay).\\n     *\\n     * Emits an {OperationExecuted} event only if the call was scheduled and delayed.\\n     */\\n    function execute(address target, bytes calldata data) external payable returns (uint32);\\n\\n    /**\\n     * @dev Cancel a scheduled (delayed) operation. Returns the nonce that identifies the previously scheduled\\n     * operation that is cancelled.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be the proposer, a guardian of the targeted function, or a global admin\\n     *\\n     * Emits a {OperationCanceled} event.\\n     */\\n    function cancel(address caller, address target, bytes calldata data) external returns (uint32);\\n\\n    /**\\n     * @dev Consume a scheduled operation targeting the caller. If such an operation exists, mark it as consumed\\n     * (emit an {OperationExecuted} event and clean the state). Otherwise, throw an error.\\n     *\\n     * This is useful for contract that want to enforce that calls targeting them were scheduled on the manager,\\n     * with all the verifications that it implies.\\n     *\\n     * Emit a {OperationExecuted} event.\\n     */\\n    function consumeScheduledOp(address caller, bytes calldata data) external;\\n\\n    /**\\n     * @dev Hashing function for delayed operations.\\n     */\\n    function hashOperation(address caller, address target, bytes calldata data) external view returns (bytes32);\\n\\n    /**\\n     * @dev Changes the authority of a target managed by this manager instance.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be a global admin\\n     */\\n    function updateAuthority(address target, address newAuthority) external;\\n}\\n\",\"keccak256\":\"0xdabf85e3bab52e7cfade4f77e661bcf7a2f9f95097bfd2ca5ddb193a0c21ee8b\",\"license\":\"MIT\"},\"@openzeppelin/contracts/access/manager/IAuthority.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (access/manager/IAuthority.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Standard interface for permissioning originally defined in Dappsys.\\n */\\ninterface IAuthority {\\n    /**\\n     * @dev Returns true if the caller can invoke on a target the function identified by a function selector.\\n     */\\n    function canCall(address caller, address target, bytes4 selector) external view returns (bool allowed);\\n}\\n\",\"keccak256\":\"0x4cc0766bd7fb7b3bafb70afa2a93b6e313a0baec7a35ad1b57505be7861c1030\",\"license\":\"MIT\"},\"@openzeppelin/contracts/interfaces/draft-IERC1822.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/draft-IERC1822.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\\n * proxy whose upgrades are fully controlled by the current implementation.\\n */\\ninterface IERC1822Proxiable {\\n    /**\\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\\n     * address.\\n     *\\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\\n     * function revert if invoked through a proxy.\\n     */\\n    function proxiableUUID() external view returns (bytes32);\\n}\\n\",\"keccak256\":\"0x2a1f9944df2015c081d89cd41ba22ffaf10aa6285969f0dc612b235cc448999c\",\"license\":\"MIT\"},\"@openzeppelin/contracts/proxy/ERC1967/ERC1967Utils.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/ERC1967/ERC1967Utils.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IBeacon} from \\\"../beacon/IBeacon.sol\\\";\\nimport {Address} from \\\"../../utils/Address.sol\\\";\\nimport {StorageSlot} from \\\"../../utils/StorageSlot.sol\\\";\\n\\n/**\\n * @dev This abstract contract provides getters and event emitting update functions for\\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\\n */\\nlibrary ERC1967Utils {\\n    // We re-declare ERC-1967 events here because they can't be used directly from IERC1967.\\n    // This will be fixed in Solidity 0.8.21. At that point we should remove these events.\\n    /**\\n     * @dev Emitted when the implementation is upgraded.\\n     */\\n    event Upgraded(address indexed implementation);\\n\\n    /**\\n     * @dev Emitted when the admin account has changed.\\n     */\\n    event AdminChanged(address previousAdmin, address newAdmin);\\n\\n    /**\\n     * @dev Emitted when the beacon is changed.\\n     */\\n    event BeaconUpgraded(address indexed beacon);\\n\\n    /**\\n     * @dev Storage slot with the address of the current implementation.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.implementation\\\" subtracted by 1.\\n     */\\n    // solhint-disable-next-line private-vars-leading-underscore\\n    bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n\\n    /**\\n     * @dev The `implementation` of the proxy is invalid.\\n     */\\n    error ERC1967InvalidImplementation(address implementation);\\n\\n    /**\\n     * @dev The `admin` of the proxy is invalid.\\n     */\\n    error ERC1967InvalidAdmin(address admin);\\n\\n    /**\\n     * @dev The `beacon` of the proxy is invalid.\\n     */\\n    error ERC1967InvalidBeacon(address beacon);\\n\\n    /**\\n     * @dev An upgrade function sees `msg.value > 0` that may be lost.\\n     */\\n    error ERC1967NonPayable();\\n\\n    /**\\n     * @dev Returns the current implementation address.\\n     */\\n    function getImplementation() internal view returns (address) {\\n        return StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new address in the EIP1967 implementation slot.\\n     */\\n    function _setImplementation(address newImplementation) private {\\n        if (newImplementation.code.length == 0) {\\n            revert ERC1967InvalidImplementation(newImplementation);\\n        }\\n        StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value = newImplementation;\\n    }\\n\\n    /**\\n     * @dev Performs implementation upgrade with additional setup call if data is nonempty.\\n     * This function is payable only if the setup call is performed, otherwise `msg.value` is rejected\\n     * to avoid stuck value in the contract.\\n     *\\n     * Emits an {IERC1967-Upgraded} event.\\n     */\\n    function upgradeToAndCall(address newImplementation, bytes memory data) internal {\\n        _setImplementation(newImplementation);\\n        emit Upgraded(newImplementation);\\n\\n        if (data.length > 0) {\\n            Address.functionDelegateCall(newImplementation, data);\\n        } else {\\n            _checkNonPayable();\\n        }\\n    }\\n\\n    /**\\n     * @dev Storage slot with the admin of the contract.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.admin\\\" subtracted by 1.\\n     */\\n    // solhint-disable-next-line private-vars-leading-underscore\\n    bytes32 internal constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\\n\\n    /**\\n     * @dev Returns the current admin.\\n     *\\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using\\n     * the https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\\n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\\n     */\\n    function getAdmin() internal view returns (address) {\\n        return StorageSlot.getAddressSlot(ADMIN_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new address in the EIP1967 admin slot.\\n     */\\n    function _setAdmin(address newAdmin) private {\\n        if (newAdmin == address(0)) {\\n            revert ERC1967InvalidAdmin(address(0));\\n        }\\n        StorageSlot.getAddressSlot(ADMIN_SLOT).value = newAdmin;\\n    }\\n\\n    /**\\n     * @dev Changes the admin of the proxy.\\n     *\\n     * Emits an {IERC1967-AdminChanged} event.\\n     */\\n    function changeAdmin(address newAdmin) internal {\\n        emit AdminChanged(getAdmin(), newAdmin);\\n        _setAdmin(newAdmin);\\n    }\\n\\n    /**\\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.beacon\\\" subtracted by 1.\\n     */\\n    // solhint-disable-next-line private-vars-leading-underscore\\n    bytes32 internal constant BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\\n\\n    /**\\n     * @dev Returns the current beacon.\\n     */\\n    function getBeacon() internal view returns (address) {\\n        return StorageSlot.getAddressSlot(BEACON_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\\n     */\\n    function _setBeacon(address newBeacon) private {\\n        if (newBeacon.code.length == 0) {\\n            revert ERC1967InvalidBeacon(newBeacon);\\n        }\\n\\n        StorageSlot.getAddressSlot(BEACON_SLOT).value = newBeacon;\\n\\n        address beaconImplementation = IBeacon(newBeacon).implementation();\\n        if (beaconImplementation.code.length == 0) {\\n            revert ERC1967InvalidImplementation(beaconImplementation);\\n        }\\n    }\\n\\n    /**\\n     * @dev Change the beacon and trigger a setup call if data is nonempty.\\n     * This function is payable only if the setup call is performed, otherwise `msg.value` is rejected\\n     * to avoid stuck value in the contract.\\n     *\\n     * Emits an {IERC1967-BeaconUpgraded} event.\\n     *\\n     * CAUTION: Invoking this function has no effect on an instance of {BeaconProxy} since v5, since\\n     * it uses an immutable beacon without looking at the value of the ERC-1967 beacon slot for\\n     * efficiency.\\n     */\\n    function upgradeBeaconToAndCall(address newBeacon, bytes memory data) internal {\\n        _setBeacon(newBeacon);\\n        emit BeaconUpgraded(newBeacon);\\n\\n        if (data.length > 0) {\\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\\n        } else {\\n            _checkNonPayable();\\n        }\\n    }\\n\\n    /**\\n     * @dev Reverts if `msg.value` is not zero. It can be used to avoid `msg.value` stuck in the contract\\n     * if an upgrade doesn't perform an initialization call.\\n     */\\n    function _checkNonPayable() private {\\n        if (msg.value > 0) {\\n            revert ERC1967NonPayable();\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x06a78f9b3ee3e6d0eb4e4cd635ba49960bea34cac1db8c0a27c75f2319f1fd65\",\"license\":\"MIT\"},\"@openzeppelin/contracts/proxy/beacon/IBeacon.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/beacon/IBeacon.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\\n */\\ninterface IBeacon {\\n    /**\\n     * @dev Must return an address that can be used as a delegate call target.\\n     *\\n     * {UpgradeableBeacon} will check that this address is a contract.\\n     */\\n    function implementation() external view returns (address);\\n}\\n\",\"keccak256\":\"0xc59a78b07b44b2cf2e8ab4175fca91e8eca1eee2df7357b8d2a8833e5ea1f64c\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC1155/IERC1155Receiver.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC165} from \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Interface that must be implemented by smart contracts in order to receive\\n * ERC-1155 token transfers.\\n */\\ninterface IERC1155Receiver is IERC165 {\\n    /**\\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\\n     *\\n     * NOTE: To accept the transfer, this must return\\n     * `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))`\\n     * (i.e. 0xf23a6e61, or its own function selector).\\n     *\\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\\n     * @param from The address which previously owned the token\\n     * @param id The ID of the token being transferred\\n     * @param value The amount of tokens being transferred\\n     * @param data Additional data with no specified format\\n     * @return `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))` if transfer is allowed\\n     */\\n    function onERC1155Received(\\n        address operator,\\n        address from,\\n        uint256 id,\\n        uint256 value,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n\\n    /**\\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\\n     * been updated.\\n     *\\n     * NOTE: To accept the transfer(s), this must return\\n     * `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))`\\n     * (i.e. 0xbc197c81, or its own function selector).\\n     *\\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\\n     * @param from The address which previously owned the token\\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\\n     * @param data Additional data with no specified format\\n     * @return `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))` if transfer is allowed\\n     */\\n    function onERC1155BatchReceived(\\n        address operator,\\n        address from,\\n        uint256[] calldata ids,\\n        uint256[] calldata values,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\",\"keccak256\":\"0xb69597a63b202e28401128bed6a6d259e8730191274471af7303eafb247881a3\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC721/IERC721.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC165} from \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\\n     *   a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or\\n     *   {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\\n     *   a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the address zero.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x5ef46daa3b58ef2702279d514780316efaa952915ee1aa3396f041ee2982b0b4\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/IERC721Receiver.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721Receiver {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be\\n     * reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\",\"keccak256\":\"0x7f7a26306c79a65fb8b3b6c757cd74660c532cd8a02e165488e30027dd34ca49\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/extensions/IERC721Metadata.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC721} from \\\"../IERC721.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721Metadata is IERC721 {\\n    /**\\n     * @dev Returns the token collection name.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the token collection symbol.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\\n     */\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n}\\n\",\"keccak256\":\"0x37d1aaaa5a2908a09e9dcf56a26ddf762ecf295afb5964695937344fc6802ce1\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev The ETH balance of the account is not enough to perform the operation.\\n     */\\n    error AddressInsufficientBalance(address account);\\n\\n    /**\\n     * @dev There's no code at `target` (it is not a contract).\\n     */\\n    error AddressEmptyCode(address target);\\n\\n    /**\\n     * @dev A call to an address target failed. The target may have reverted.\\n     */\\n    error FailedInnerCall();\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        if (address(this).balance < amount) {\\n            revert AddressInsufficientBalance(address(this));\\n        }\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        if (!success) {\\n            revert FailedInnerCall();\\n        }\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason or custom error, it is bubbled\\n     * up by this function (like regular Solidity function calls). However, if\\n     * the call reverted with no returned reason, this function reverts with a\\n     * {FailedInnerCall} error.\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        if (address(this).balance < value) {\\n            revert AddressInsufficientBalance(address(this));\\n        }\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\\n     * unsuccessful call.\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata\\n    ) internal view returns (bytes memory) {\\n        if (!success) {\\n            _revert(returndata);\\n        } else {\\n            // only check if target is a contract if the call was successful and the return data is empty\\n            // otherwise we already know that it was a contract\\n            if (returndata.length == 0 && target.code.length == 0) {\\n                revert AddressEmptyCode(target);\\n            }\\n            return returndata;\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\\n     * revert reason or with a default {FailedInnerCall} error.\\n     */\\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\\n        if (!success) {\\n            _revert(returndata);\\n        } else {\\n            return returndata;\\n        }\\n    }\\n\\n    /**\\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\\n     */\\n    function _revert(bytes memory returndata) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert FailedInnerCall();\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xaf28a975a78550e45f65e559a3ad6a5ad43b9b8a37366999abd1b7084eb70721\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/ShortStrings.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/ShortStrings.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {StorageSlot} from \\\"./StorageSlot.sol\\\";\\n\\n// | string  | 0xAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA   |\\n// | length  | 0x                                                              BB |\\ntype ShortString is bytes32;\\n\\n/**\\n * @dev This library provides functions to convert short memory strings\\n * into a `ShortString` type that can be used as an immutable variable.\\n *\\n * Strings of arbitrary length can be optimized using this library if\\n * they are short enough (up to 31 bytes) by packing them with their\\n * length (1 byte) in a single EVM word (32 bytes). Additionally, a\\n * fallback mechanism can be used for every other case.\\n *\\n * Usage example:\\n *\\n * ```solidity\\n * contract Named {\\n *     using ShortStrings for *;\\n *\\n *     ShortString private immutable _name;\\n *     string private _nameFallback;\\n *\\n *     constructor(string memory contractName) {\\n *         _name = contractName.toShortStringWithFallback(_nameFallback);\\n *     }\\n *\\n *     function name() external view returns (string memory) {\\n *         return _name.toStringWithFallback(_nameFallback);\\n *     }\\n * }\\n * ```\\n */\\nlibrary ShortStrings {\\n    // Used as an identifier for strings longer than 31 bytes.\\n    bytes32 private constant FALLBACK_SENTINEL = 0x00000000000000000000000000000000000000000000000000000000000000FF;\\n\\n    error StringTooLong(string str);\\n    error InvalidShortString();\\n\\n    /**\\n     * @dev Encode a string of at most 31 chars into a `ShortString`.\\n     *\\n     * This will trigger a `StringTooLong` error is the input string is too long.\\n     */\\n    function toShortString(string memory str) internal pure returns (ShortString) {\\n        bytes memory bstr = bytes(str);\\n        if (bstr.length > 31) {\\n            revert StringTooLong(str);\\n        }\\n        return ShortString.wrap(bytes32(uint256(bytes32(bstr)) | bstr.length));\\n    }\\n\\n    /**\\n     * @dev Decode a `ShortString` back to a \\\"normal\\\" string.\\n     */\\n    function toString(ShortString sstr) internal pure returns (string memory) {\\n        uint256 len = byteLength(sstr);\\n        // using `new string(len)` would work locally but is not memory safe.\\n        string memory str = new string(32);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(str, len)\\n            mstore(add(str, 0x20), sstr)\\n        }\\n        return str;\\n    }\\n\\n    /**\\n     * @dev Return the length of a `ShortString`.\\n     */\\n    function byteLength(ShortString sstr) internal pure returns (uint256) {\\n        uint256 result = uint256(ShortString.unwrap(sstr)) & 0xFF;\\n        if (result > 31) {\\n            revert InvalidShortString();\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Encode a string into a `ShortString`, or write it to storage if it is too long.\\n     */\\n    function toShortStringWithFallback(string memory value, string storage store) internal returns (ShortString) {\\n        if (bytes(value).length < 32) {\\n            return toShortString(value);\\n        } else {\\n            StorageSlot.getStringSlot(store).value = value;\\n            return ShortString.wrap(FALLBACK_SENTINEL);\\n        }\\n    }\\n\\n    /**\\n     * @dev Decode a string that was encoded to `ShortString` or written to storage using {setWithFallback}.\\n     */\\n    function toStringWithFallback(ShortString value, string storage store) internal pure returns (string memory) {\\n        if (ShortString.unwrap(value) != FALLBACK_SENTINEL) {\\n            return toString(value);\\n        } else {\\n            return store;\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the length of a string that was encoded to `ShortString` or written to storage using\\n     * {setWithFallback}.\\n     *\\n     * WARNING: This will return the \\\"byte length\\\" of the string. This may not reflect the actual length in terms of\\n     * actual characters as the UTF-8 encoding of a single character can span over multiple bytes.\\n     */\\n    function byteLengthWithFallback(ShortString value, string storage store) internal view returns (uint256) {\\n        if (ShortString.unwrap(value) != FALLBACK_SENTINEL) {\\n            return byteLength(value);\\n        } else {\\n            return bytes(store).length;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x18a7171df639a934592915a520ecb97c5bbc9675a1105607aac8a94e72bf62c6\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/StorageSlot.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/StorageSlot.sol)\\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Library for reading and writing primitive types to specific storage slots.\\n *\\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\\n * This library helps with reading and writing to such slots without the need for inline assembly.\\n *\\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\\n *\\n * Example usage to set ERC1967 implementation slot:\\n * ```solidity\\n * contract ERC1967 {\\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n *\\n *     function _getImplementation() internal view returns (address) {\\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\n *     }\\n *\\n *     function _setImplementation(address newImplementation) internal {\\n *         require(newImplementation.code.length > 0);\\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\\n *     }\\n * }\\n * ```\\n */\\nlibrary StorageSlot {\\n    struct AddressSlot {\\n        address value;\\n    }\\n\\n    struct BooleanSlot {\\n        bool value;\\n    }\\n\\n    struct Bytes32Slot {\\n        bytes32 value;\\n    }\\n\\n    struct Uint256Slot {\\n        uint256 value;\\n    }\\n\\n    struct StringSlot {\\n        string value;\\n    }\\n\\n    struct BytesSlot {\\n        bytes value;\\n    }\\n\\n    /**\\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\\n     */\\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\\n     */\\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\\n     */\\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\\n     */\\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\\n     */\\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\\n     */\\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := store.slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\\n     */\\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\\n     */\\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := store.slot\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x32ba59b4b7299237c8ba56319110989d7978a039faf754793064e967e5894418\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Strings.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {Math} from \\\"./math/Math.sol\\\";\\nimport {SignedMath} from \\\"./math/SignedMath.sol\\\";\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant HEX_DIGITS = \\\"0123456789abcdef\\\";\\n    uint8 private constant ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev The `value` string doesn't fit in the specified `length`.\\n     */\\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            uint256 length = Math.log10(value) + 1;\\n            string memory buffer = new string(length);\\n            uint256 ptr;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                ptr := add(buffer, add(32, length))\\n            }\\n            while (true) {\\n                ptr--;\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\\n                }\\n                value /= 10;\\n                if (value == 0) break;\\n            }\\n            return buffer;\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\\n     */\\n    function toStringSigned(int256 value) internal pure returns (string memory) {\\n        return string.concat(value < 0 ? \\\"-\\\" : \\\"\\\", toString(SignedMath.abs(value)));\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            return toHexString(value, Math.log256(value) + 1);\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        uint256 localValue = value;\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = HEX_DIGITS[localValue & 0xf];\\n            localValue >>= 4;\\n        }\\n        if (localValue != 0) {\\n            revert StringsInsufficientHexLength(value, length);\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal\\n     * representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\\n    }\\n\\n    /**\\n     * @dev Returns true if the two strings are equal.\\n     */\\n    function equal(string memory a, string memory b) internal pure returns (bool) {\\n        return bytes(a).length == bytes(b).length && keccak256(bytes(a)) == keccak256(bytes(b));\\n    }\\n}\\n\",\"keccak256\":\"0x55f102ea785d8399c0e58d1108e2d289506dde18abc6db1b7f68c1f9f9bc5792\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/ERC165Checker.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC165} from \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Library used to query support of an interface declared via {IERC165}.\\n *\\n * Note that these functions return the actual result of the query: they do not\\n * `revert` if an interface is not supported. It is up to the caller to decide\\n * what to do in these cases.\\n */\\nlibrary ERC165Checker {\\n    // As per the EIP-165 spec, no interface should ever match 0xffffffff\\n    bytes4 private constant INTERFACE_ID_INVALID = 0xffffffff;\\n\\n    /**\\n     * @dev Returns true if `account` supports the {IERC165} interface.\\n     */\\n    function supportsERC165(address account) internal view returns (bool) {\\n        // Any contract that implements ERC165 must explicitly indicate support of\\n        // InterfaceId_ERC165 and explicitly indicate non-support of InterfaceId_Invalid\\n        return\\n            supportsERC165InterfaceUnchecked(account, type(IERC165).interfaceId) &&\\n            !supportsERC165InterfaceUnchecked(account, INTERFACE_ID_INVALID);\\n    }\\n\\n    /**\\n     * @dev Returns true if `account` supports the interface defined by\\n     * `interfaceId`. Support for {IERC165} itself is queried automatically.\\n     *\\n     * See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(address account, bytes4 interfaceId) internal view returns (bool) {\\n        // query support of both ERC165 as per the spec and support of _interfaceId\\n        return supportsERC165(account) && supportsERC165InterfaceUnchecked(account, interfaceId);\\n    }\\n\\n    /**\\n     * @dev Returns a boolean array where each value corresponds to the\\n     * interfaces passed in and whether they're supported or not. This allows\\n     * you to batch check interfaces for a contract where your expectation\\n     * is that some interfaces may not be supported.\\n     *\\n     * See {IERC165-supportsInterface}.\\n     */\\n    function getSupportedInterfaces(\\n        address account,\\n        bytes4[] memory interfaceIds\\n    ) internal view returns (bool[] memory) {\\n        // an array of booleans corresponding to interfaceIds and whether they're supported or not\\n        bool[] memory interfaceIdsSupported = new bool[](interfaceIds.length);\\n\\n        // query support of ERC165 itself\\n        if (supportsERC165(account)) {\\n            // query support of each interface in interfaceIds\\n            for (uint256 i = 0; i < interfaceIds.length; i++) {\\n                interfaceIdsSupported[i] = supportsERC165InterfaceUnchecked(account, interfaceIds[i]);\\n            }\\n        }\\n\\n        return interfaceIdsSupported;\\n    }\\n\\n    /**\\n     * @dev Returns true if `account` supports all the interfaces defined in\\n     * `interfaceIds`. Support for {IERC165} itself is queried automatically.\\n     *\\n     * Batch-querying can lead to gas savings by skipping repeated checks for\\n     * {IERC165} support.\\n     *\\n     * See {IERC165-supportsInterface}.\\n     */\\n    function supportsAllInterfaces(address account, bytes4[] memory interfaceIds) internal view returns (bool) {\\n        // query support of ERC165 itself\\n        if (!supportsERC165(account)) {\\n            return false;\\n        }\\n\\n        // query support of each interface in interfaceIds\\n        for (uint256 i = 0; i < interfaceIds.length; i++) {\\n            if (!supportsERC165InterfaceUnchecked(account, interfaceIds[i])) {\\n                return false;\\n            }\\n        }\\n\\n        // all interfaces supported\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Query if a contract implements an interface, does not check ERC165 support\\n     * @param account The address of the contract to query for support of an interface\\n     * @param interfaceId The interface identifier, as specified in ERC-165\\n     * @return true if the contract at account indicates support of the interface with\\n     * identifier interfaceId, false otherwise\\n     * @dev Assumes that account contains a contract that supports ERC165, otherwise\\n     * the behavior of this method is undefined. This precondition can be checked\\n     * with {supportsERC165}.\\n     *\\n     * Some precompiled contracts will falsely indicate support for a given interface, so caution\\n     * should be exercised when using this function.\\n     *\\n     * Interface identification is specified in ERC-165.\\n     */\\n    function supportsERC165InterfaceUnchecked(address account, bytes4 interfaceId) internal view returns (bool) {\\n        // prepare call\\n        bytes memory encodedParams = abi.encodeCall(IERC165.supportsInterface, (interfaceId));\\n\\n        // perform static call\\n        bool success;\\n        uint256 returnSize;\\n        uint256 returnValue;\\n        assembly {\\n            success := staticcall(30000, account, add(encodedParams, 0x20), mload(encodedParams), 0x00, 0x20)\\n            returnSize := returndatasize()\\n            returnValue := mload(0x00)\\n        }\\n\\n        return success && returnSize >= 0x20 && returnValue > 0;\\n    }\\n}\\n\",\"keccak256\":\"0xac3d50e321a48a40b4496970ce725900f13aeb2255b7c1203f5adbe98c4a911a\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/introspection/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x4296879f55019b23e135000eb36896057e7101fb7fb859c5ef690cf14643757b\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/math/Math.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    /**\\n     * @dev Muldiv operation overflow.\\n     */\\n    error MathOverflowedMulDiv();\\n\\n    enum Rounding {\\n        Floor, // Toward negative infinity\\n        Ceil, // Toward positive infinity\\n        Trunc, // Toward zero\\n        Expand // Away from zero\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds towards infinity instead\\n     * of rounding towards zero.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (b == 0) {\\n            // Guarantee the same behavior as in a regular Solidity division.\\n            return a / b;\\n        }\\n\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\\n     * denominator == 0.\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\\n     * Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0 = x * y; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\\n                // The surrounding unchecked block does not change this fact.\\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            if (denominator <= prod1) {\\n                revert MathOverflowedMulDiv();\\n            }\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\\n            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\\n\\n            uint256 twos = denominator & (0 - denominator);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\\n            // works in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\\n     * towards zero.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \\u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \\u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10 ** 64) {\\n                value /= 10 ** 64;\\n                result += 64;\\n            }\\n            if (value >= 10 ** 32) {\\n                value /= 10 ** 32;\\n                result += 32;\\n            }\\n            if (value >= 10 ** 16) {\\n                value /= 10 ** 16;\\n                result += 16;\\n            }\\n            if (value >= 10 ** 8) {\\n                value /= 10 ** 8;\\n                result += 8;\\n            }\\n            if (value >= 10 ** 4) {\\n                value /= 10 ** 4;\\n                result += 4;\\n            }\\n            if (value >= 10 ** 2) {\\n                value /= 10 ** 2;\\n                result += 2;\\n            }\\n            if (value >= 10 ** 1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\\n     */\\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\\n        return uint8(rounding) % 2 == 1;\\n    }\\n}\\n\",\"keccak256\":\"0x005ec64c6313f0555d59e278f9a7a5ab2db5bdc72a027f255a37c327af1ec02d\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/math/SafeCast.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SafeCast.sol)\\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\\n * checks.\\n *\\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\\n * easily result in undesired exploitation or bugs, since developers usually\\n * assume that overflows raise errors. `SafeCast` restores this intuition by\\n * reverting the transaction when such an operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeCast {\\n    /**\\n     * @dev Value doesn't fit in an uint of `bits` size.\\n     */\\n    error SafeCastOverflowedUintDowncast(uint8 bits, uint256 value);\\n\\n    /**\\n     * @dev An int value doesn't fit in an uint of `bits` size.\\n     */\\n    error SafeCastOverflowedIntToUint(int256 value);\\n\\n    /**\\n     * @dev Value doesn't fit in an int of `bits` size.\\n     */\\n    error SafeCastOverflowedIntDowncast(uint8 bits, int256 value);\\n\\n    /**\\n     * @dev An uint value doesn't fit in an int of `bits` size.\\n     */\\n    error SafeCastOverflowedUintToInt(uint256 value);\\n\\n    /**\\n     * @dev Returns the downcasted uint248 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint248).\\n     *\\n     * Counterpart to Solidity's `uint248` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 248 bits\\n     */\\n    function toUint248(uint256 value) internal pure returns (uint248) {\\n        if (value > type(uint248).max) {\\n            revert SafeCastOverflowedUintDowncast(248, value);\\n        }\\n        return uint248(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint240 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint240).\\n     *\\n     * Counterpart to Solidity's `uint240` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 240 bits\\n     */\\n    function toUint240(uint256 value) internal pure returns (uint240) {\\n        if (value > type(uint240).max) {\\n            revert SafeCastOverflowedUintDowncast(240, value);\\n        }\\n        return uint240(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint232 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint232).\\n     *\\n     * Counterpart to Solidity's `uint232` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 232 bits\\n     */\\n    function toUint232(uint256 value) internal pure returns (uint232) {\\n        if (value > type(uint232).max) {\\n            revert SafeCastOverflowedUintDowncast(232, value);\\n        }\\n        return uint232(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint224 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint224).\\n     *\\n     * Counterpart to Solidity's `uint224` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 224 bits\\n     */\\n    function toUint224(uint256 value) internal pure returns (uint224) {\\n        if (value > type(uint224).max) {\\n            revert SafeCastOverflowedUintDowncast(224, value);\\n        }\\n        return uint224(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint216 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint216).\\n     *\\n     * Counterpart to Solidity's `uint216` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 216 bits\\n     */\\n    function toUint216(uint256 value) internal pure returns (uint216) {\\n        if (value > type(uint216).max) {\\n            revert SafeCastOverflowedUintDowncast(216, value);\\n        }\\n        return uint216(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint208 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint208).\\n     *\\n     * Counterpart to Solidity's `uint208` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 208 bits\\n     */\\n    function toUint208(uint256 value) internal pure returns (uint208) {\\n        if (value > type(uint208).max) {\\n            revert SafeCastOverflowedUintDowncast(208, value);\\n        }\\n        return uint208(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint200 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint200).\\n     *\\n     * Counterpart to Solidity's `uint200` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 200 bits\\n     */\\n    function toUint200(uint256 value) internal pure returns (uint200) {\\n        if (value > type(uint200).max) {\\n            revert SafeCastOverflowedUintDowncast(200, value);\\n        }\\n        return uint200(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint192 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint192).\\n     *\\n     * Counterpart to Solidity's `uint192` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 192 bits\\n     */\\n    function toUint192(uint256 value) internal pure returns (uint192) {\\n        if (value > type(uint192).max) {\\n            revert SafeCastOverflowedUintDowncast(192, value);\\n        }\\n        return uint192(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint184 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint184).\\n     *\\n     * Counterpart to Solidity's `uint184` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 184 bits\\n     */\\n    function toUint184(uint256 value) internal pure returns (uint184) {\\n        if (value > type(uint184).max) {\\n            revert SafeCastOverflowedUintDowncast(184, value);\\n        }\\n        return uint184(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint176 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint176).\\n     *\\n     * Counterpart to Solidity's `uint176` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 176 bits\\n     */\\n    function toUint176(uint256 value) internal pure returns (uint176) {\\n        if (value > type(uint176).max) {\\n            revert SafeCastOverflowedUintDowncast(176, value);\\n        }\\n        return uint176(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint168 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint168).\\n     *\\n     * Counterpart to Solidity's `uint168` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 168 bits\\n     */\\n    function toUint168(uint256 value) internal pure returns (uint168) {\\n        if (value > type(uint168).max) {\\n            revert SafeCastOverflowedUintDowncast(168, value);\\n        }\\n        return uint168(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint160 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint160).\\n     *\\n     * Counterpart to Solidity's `uint160` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 160 bits\\n     */\\n    function toUint160(uint256 value) internal pure returns (uint160) {\\n        if (value > type(uint160).max) {\\n            revert SafeCastOverflowedUintDowncast(160, value);\\n        }\\n        return uint160(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint152 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint152).\\n     *\\n     * Counterpart to Solidity's `uint152` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 152 bits\\n     */\\n    function toUint152(uint256 value) internal pure returns (uint152) {\\n        if (value > type(uint152).max) {\\n            revert SafeCastOverflowedUintDowncast(152, value);\\n        }\\n        return uint152(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint144 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint144).\\n     *\\n     * Counterpart to Solidity's `uint144` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 144 bits\\n     */\\n    function toUint144(uint256 value) internal pure returns (uint144) {\\n        if (value > type(uint144).max) {\\n            revert SafeCastOverflowedUintDowncast(144, value);\\n        }\\n        return uint144(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint136 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint136).\\n     *\\n     * Counterpart to Solidity's `uint136` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 136 bits\\n     */\\n    function toUint136(uint256 value) internal pure returns (uint136) {\\n        if (value > type(uint136).max) {\\n            revert SafeCastOverflowedUintDowncast(136, value);\\n        }\\n        return uint136(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint128 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint128).\\n     *\\n     * Counterpart to Solidity's `uint128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     */\\n    function toUint128(uint256 value) internal pure returns (uint128) {\\n        if (value > type(uint128).max) {\\n            revert SafeCastOverflowedUintDowncast(128, value);\\n        }\\n        return uint128(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint120 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint120).\\n     *\\n     * Counterpart to Solidity's `uint120` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 120 bits\\n     */\\n    function toUint120(uint256 value) internal pure returns (uint120) {\\n        if (value > type(uint120).max) {\\n            revert SafeCastOverflowedUintDowncast(120, value);\\n        }\\n        return uint120(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint112 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint112).\\n     *\\n     * Counterpart to Solidity's `uint112` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 112 bits\\n     */\\n    function toUint112(uint256 value) internal pure returns (uint112) {\\n        if (value > type(uint112).max) {\\n            revert SafeCastOverflowedUintDowncast(112, value);\\n        }\\n        return uint112(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint104 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint104).\\n     *\\n     * Counterpart to Solidity's `uint104` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 104 bits\\n     */\\n    function toUint104(uint256 value) internal pure returns (uint104) {\\n        if (value > type(uint104).max) {\\n            revert SafeCastOverflowedUintDowncast(104, value);\\n        }\\n        return uint104(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint96 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint96).\\n     *\\n     * Counterpart to Solidity's `uint96` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 96 bits\\n     */\\n    function toUint96(uint256 value) internal pure returns (uint96) {\\n        if (value > type(uint96).max) {\\n            revert SafeCastOverflowedUintDowncast(96, value);\\n        }\\n        return uint96(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint88 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint88).\\n     *\\n     * Counterpart to Solidity's `uint88` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 88 bits\\n     */\\n    function toUint88(uint256 value) internal pure returns (uint88) {\\n        if (value > type(uint88).max) {\\n            revert SafeCastOverflowedUintDowncast(88, value);\\n        }\\n        return uint88(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint80 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint80).\\n     *\\n     * Counterpart to Solidity's `uint80` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 80 bits\\n     */\\n    function toUint80(uint256 value) internal pure returns (uint80) {\\n        if (value > type(uint80).max) {\\n            revert SafeCastOverflowedUintDowncast(80, value);\\n        }\\n        return uint80(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint72 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint72).\\n     *\\n     * Counterpart to Solidity's `uint72` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 72 bits\\n     */\\n    function toUint72(uint256 value) internal pure returns (uint72) {\\n        if (value > type(uint72).max) {\\n            revert SafeCastOverflowedUintDowncast(72, value);\\n        }\\n        return uint72(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint64 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint64).\\n     *\\n     * Counterpart to Solidity's `uint64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     */\\n    function toUint64(uint256 value) internal pure returns (uint64) {\\n        if (value > type(uint64).max) {\\n            revert SafeCastOverflowedUintDowncast(64, value);\\n        }\\n        return uint64(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint56 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint56).\\n     *\\n     * Counterpart to Solidity's `uint56` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 56 bits\\n     */\\n    function toUint56(uint256 value) internal pure returns (uint56) {\\n        if (value > type(uint56).max) {\\n            revert SafeCastOverflowedUintDowncast(56, value);\\n        }\\n        return uint56(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint48 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint48).\\n     *\\n     * Counterpart to Solidity's `uint48` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 48 bits\\n     */\\n    function toUint48(uint256 value) internal pure returns (uint48) {\\n        if (value > type(uint48).max) {\\n            revert SafeCastOverflowedUintDowncast(48, value);\\n        }\\n        return uint48(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint40 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint40).\\n     *\\n     * Counterpart to Solidity's `uint40` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 40 bits\\n     */\\n    function toUint40(uint256 value) internal pure returns (uint40) {\\n        if (value > type(uint40).max) {\\n            revert SafeCastOverflowedUintDowncast(40, value);\\n        }\\n        return uint40(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint32 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint32).\\n     *\\n     * Counterpart to Solidity's `uint32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     */\\n    function toUint32(uint256 value) internal pure returns (uint32) {\\n        if (value > type(uint32).max) {\\n            revert SafeCastOverflowedUintDowncast(32, value);\\n        }\\n        return uint32(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint24 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint24).\\n     *\\n     * Counterpart to Solidity's `uint24` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 24 bits\\n     */\\n    function toUint24(uint256 value) internal pure returns (uint24) {\\n        if (value > type(uint24).max) {\\n            revert SafeCastOverflowedUintDowncast(24, value);\\n        }\\n        return uint24(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint16 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint16).\\n     *\\n     * Counterpart to Solidity's `uint16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     */\\n    function toUint16(uint256 value) internal pure returns (uint16) {\\n        if (value > type(uint16).max) {\\n            revert SafeCastOverflowedUintDowncast(16, value);\\n        }\\n        return uint16(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint8 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint8).\\n     *\\n     * Counterpart to Solidity's `uint8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits\\n     */\\n    function toUint8(uint256 value) internal pure returns (uint8) {\\n        if (value > type(uint8).max) {\\n            revert SafeCastOverflowedUintDowncast(8, value);\\n        }\\n        return uint8(value);\\n    }\\n\\n    /**\\n     * @dev Converts a signed int256 into an unsigned uint256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be greater than or equal to 0.\\n     */\\n    function toUint256(int256 value) internal pure returns (uint256) {\\n        if (value < 0) {\\n            revert SafeCastOverflowedIntToUint(value);\\n        }\\n        return uint256(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int248 from int256, reverting on\\n     * overflow (when the input is less than smallest int248 or\\n     * greater than largest int248).\\n     *\\n     * Counterpart to Solidity's `int248` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 248 bits\\n     */\\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\\n        downcasted = int248(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(248, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int240 from int256, reverting on\\n     * overflow (when the input is less than smallest int240 or\\n     * greater than largest int240).\\n     *\\n     * Counterpart to Solidity's `int240` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 240 bits\\n     */\\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\\n        downcasted = int240(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(240, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int232 from int256, reverting on\\n     * overflow (when the input is less than smallest int232 or\\n     * greater than largest int232).\\n     *\\n     * Counterpart to Solidity's `int232` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 232 bits\\n     */\\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\\n        downcasted = int232(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(232, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int224 from int256, reverting on\\n     * overflow (when the input is less than smallest int224 or\\n     * greater than largest int224).\\n     *\\n     * Counterpart to Solidity's `int224` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 224 bits\\n     */\\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\\n        downcasted = int224(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(224, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int216 from int256, reverting on\\n     * overflow (when the input is less than smallest int216 or\\n     * greater than largest int216).\\n     *\\n     * Counterpart to Solidity's `int216` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 216 bits\\n     */\\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\\n        downcasted = int216(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(216, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int208 from int256, reverting on\\n     * overflow (when the input is less than smallest int208 or\\n     * greater than largest int208).\\n     *\\n     * Counterpart to Solidity's `int208` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 208 bits\\n     */\\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\\n        downcasted = int208(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(208, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int200 from int256, reverting on\\n     * overflow (when the input is less than smallest int200 or\\n     * greater than largest int200).\\n     *\\n     * Counterpart to Solidity's `int200` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 200 bits\\n     */\\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\\n        downcasted = int200(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(200, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int192 from int256, reverting on\\n     * overflow (when the input is less than smallest int192 or\\n     * greater than largest int192).\\n     *\\n     * Counterpart to Solidity's `int192` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 192 bits\\n     */\\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\\n        downcasted = int192(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(192, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int184 from int256, reverting on\\n     * overflow (when the input is less than smallest int184 or\\n     * greater than largest int184).\\n     *\\n     * Counterpart to Solidity's `int184` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 184 bits\\n     */\\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\\n        downcasted = int184(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(184, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int176 from int256, reverting on\\n     * overflow (when the input is less than smallest int176 or\\n     * greater than largest int176).\\n     *\\n     * Counterpart to Solidity's `int176` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 176 bits\\n     */\\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\\n        downcasted = int176(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(176, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int168 from int256, reverting on\\n     * overflow (when the input is less than smallest int168 or\\n     * greater than largest int168).\\n     *\\n     * Counterpart to Solidity's `int168` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 168 bits\\n     */\\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\\n        downcasted = int168(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(168, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int160 from int256, reverting on\\n     * overflow (when the input is less than smallest int160 or\\n     * greater than largest int160).\\n     *\\n     * Counterpart to Solidity's `int160` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 160 bits\\n     */\\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\\n        downcasted = int160(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(160, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int152 from int256, reverting on\\n     * overflow (when the input is less than smallest int152 or\\n     * greater than largest int152).\\n     *\\n     * Counterpart to Solidity's `int152` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 152 bits\\n     */\\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\\n        downcasted = int152(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(152, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int144 from int256, reverting on\\n     * overflow (when the input is less than smallest int144 or\\n     * greater than largest int144).\\n     *\\n     * Counterpart to Solidity's `int144` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 144 bits\\n     */\\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\\n        downcasted = int144(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(144, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int136 from int256, reverting on\\n     * overflow (when the input is less than smallest int136 or\\n     * greater than largest int136).\\n     *\\n     * Counterpart to Solidity's `int136` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 136 bits\\n     */\\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\\n        downcasted = int136(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(136, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int128 from int256, reverting on\\n     * overflow (when the input is less than smallest int128 or\\n     * greater than largest int128).\\n     *\\n     * Counterpart to Solidity's `int128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     */\\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\\n        downcasted = int128(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(128, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int120 from int256, reverting on\\n     * overflow (when the input is less than smallest int120 or\\n     * greater than largest int120).\\n     *\\n     * Counterpart to Solidity's `int120` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 120 bits\\n     */\\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\\n        downcasted = int120(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(120, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int112 from int256, reverting on\\n     * overflow (when the input is less than smallest int112 or\\n     * greater than largest int112).\\n     *\\n     * Counterpart to Solidity's `int112` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 112 bits\\n     */\\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\\n        downcasted = int112(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(112, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int104 from int256, reverting on\\n     * overflow (when the input is less than smallest int104 or\\n     * greater than largest int104).\\n     *\\n     * Counterpart to Solidity's `int104` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 104 bits\\n     */\\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\\n        downcasted = int104(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(104, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int96 from int256, reverting on\\n     * overflow (when the input is less than smallest int96 or\\n     * greater than largest int96).\\n     *\\n     * Counterpart to Solidity's `int96` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 96 bits\\n     */\\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\\n        downcasted = int96(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(96, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int88 from int256, reverting on\\n     * overflow (when the input is less than smallest int88 or\\n     * greater than largest int88).\\n     *\\n     * Counterpart to Solidity's `int88` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 88 bits\\n     */\\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\\n        downcasted = int88(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(88, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int80 from int256, reverting on\\n     * overflow (when the input is less than smallest int80 or\\n     * greater than largest int80).\\n     *\\n     * Counterpart to Solidity's `int80` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 80 bits\\n     */\\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\\n        downcasted = int80(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(80, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int72 from int256, reverting on\\n     * overflow (when the input is less than smallest int72 or\\n     * greater than largest int72).\\n     *\\n     * Counterpart to Solidity's `int72` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 72 bits\\n     */\\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\\n        downcasted = int72(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(72, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int64 from int256, reverting on\\n     * overflow (when the input is less than smallest int64 or\\n     * greater than largest int64).\\n     *\\n     * Counterpart to Solidity's `int64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     */\\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\\n        downcasted = int64(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(64, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int56 from int256, reverting on\\n     * overflow (when the input is less than smallest int56 or\\n     * greater than largest int56).\\n     *\\n     * Counterpart to Solidity's `int56` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 56 bits\\n     */\\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\\n        downcasted = int56(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(56, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int48 from int256, reverting on\\n     * overflow (when the input is less than smallest int48 or\\n     * greater than largest int48).\\n     *\\n     * Counterpart to Solidity's `int48` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 48 bits\\n     */\\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\\n        downcasted = int48(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(48, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int40 from int256, reverting on\\n     * overflow (when the input is less than smallest int40 or\\n     * greater than largest int40).\\n     *\\n     * Counterpart to Solidity's `int40` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 40 bits\\n     */\\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\\n        downcasted = int40(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(40, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int32 from int256, reverting on\\n     * overflow (when the input is less than smallest int32 or\\n     * greater than largest int32).\\n     *\\n     * Counterpart to Solidity's `int32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     */\\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\\n        downcasted = int32(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(32, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int24 from int256, reverting on\\n     * overflow (when the input is less than smallest int24 or\\n     * greater than largest int24).\\n     *\\n     * Counterpart to Solidity's `int24` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 24 bits\\n     */\\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\\n        downcasted = int24(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(24, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int16 from int256, reverting on\\n     * overflow (when the input is less than smallest int16 or\\n     * greater than largest int16).\\n     *\\n     * Counterpart to Solidity's `int16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     */\\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\\n        downcasted = int16(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(16, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int8 from int256, reverting on\\n     * overflow (when the input is less than smallest int8 or\\n     * greater than largest int8).\\n     *\\n     * Counterpart to Solidity's `int8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits\\n     */\\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\\n        downcasted = int8(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(8, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts an unsigned uint256 into a signed int256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be less than or equal to maxInt256.\\n     */\\n    function toInt256(uint256 value) internal pure returns (int256) {\\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\\n        if (value > uint256(type(int256).max)) {\\n            revert SafeCastOverflowedUintToInt(value);\\n        }\\n        return int256(value);\\n    }\\n}\\n\",\"keccak256\":\"0xe19a4d5f31d2861e7344e8e535e2feafb913d806d3e2b5fe7782741a2a7094fe\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/math/SignedMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SignedMath.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Standard signed math utilities missing in the Solidity language.\\n */\\nlibrary SignedMath {\\n    /**\\n     * @dev Returns the largest of two signed numbers.\\n     */\\n    function max(int256 a, int256 b) internal pure returns (int256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two signed numbers.\\n     */\\n    function min(int256 a, int256 b) internal pure returns (int256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two signed numbers without overflow.\\n     * The result is rounded towards zero.\\n     */\\n    function average(int256 a, int256 b) internal pure returns (int256) {\\n        // Formula from the book \\\"Hacker's Delight\\\"\\n        int256 x = (a & b) + ((a ^ b) >> 1);\\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\\n    }\\n\\n    /**\\n     * @dev Returns the absolute unsigned value of a signed value.\\n     */\\n    function abs(int256 n) internal pure returns (uint256) {\\n        unchecked {\\n            // must be unchecked in order to support `n = type(int256).min`\\n            return uint256(n >= 0 ? n : -n);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x5f7e4076e175393767754387c962926577f1660dd9b810187b9002407656be72\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/types/Time.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/types/Time.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {Math} from \\\"../math/Math.sol\\\";\\nimport {SafeCast} from \\\"../math/SafeCast.sol\\\";\\n\\n/**\\n * @dev This library provides helpers for manipulating time-related objects.\\n *\\n * It uses the following types:\\n * - `uint48` for timepoints\\n * - `uint32` for durations\\n *\\n * While the library doesn't provide specific types for timepoints and duration, it does provide:\\n * - a `Delay` type to represent duration that can be programmed to change value automatically at a given point\\n * - additional helper functions\\n */\\nlibrary Time {\\n    using Time for *;\\n\\n    /**\\n     * @dev Get the block timestamp as a Timepoint.\\n     */\\n    function timestamp() internal view returns (uint48) {\\n        return SafeCast.toUint48(block.timestamp);\\n    }\\n\\n    /**\\n     * @dev Get the block number as a Timepoint.\\n     */\\n    function blockNumber() internal view returns (uint48) {\\n        return SafeCast.toUint48(block.number);\\n    }\\n\\n    // ==================================================== Delay =====================================================\\n    /**\\n     * @dev A `Delay` is a uint32 duration that can be programmed to change value automatically at a given point in the\\n     * future. The \\\"effect\\\" timepoint describes when the transitions happens from the \\\"old\\\" value to the \\\"new\\\" value.\\n     * This allows updating the delay applied to some operation while keeping some guarantees.\\n     *\\n     * In particular, the {update} function guarantees that if the delay is reduced, the old delay still applies for\\n     * some time. For example if the delay is currently 7 days to do an upgrade, the admin should not be able to set\\n     * the delay to 0 and upgrade immediately. If the admin wants to reduce the delay, the old delay (7 days) should\\n     * still apply for some time.\\n     *\\n     *\\n     * The `Delay` type is 112 bits long, and packs the following:\\n     *\\n     * ```\\n     *   | [uint48]: effect date (timepoint)\\n     *   |           | [uint32]: value before (duration)\\n     *   \\u2193           \\u2193       \\u2193 [uint32]: value after (duration)\\n     * 0xAAAAAAAAAAAABBBBBBBBCCCCCCCC\\n     * ```\\n     *\\n     * NOTE: The {get} and {withUpdate} functions operate using timestamps. Block number based delays are not currently\\n     * supported.\\n     */\\n    type Delay is uint112;\\n\\n    /**\\n     * @dev Wrap a duration into a Delay to add the one-step \\\"update in the future\\\" feature\\n     */\\n    function toDelay(uint32 duration) internal pure returns (Delay) {\\n        return Delay.wrap(duration);\\n    }\\n\\n    /**\\n     * @dev Get the value at a given timepoint plus the pending value and effect timepoint if there is a scheduled\\n     * change after this timepoint. If the effect timepoint is 0, then the pending value should not be considered.\\n     */\\n    function _getFullAt(Delay self, uint48 timepoint) private pure returns (uint32, uint32, uint48) {\\n        (uint32 valueBefore, uint32 valueAfter, uint48 effect) = self.unpack();\\n        return effect <= timepoint ? (valueAfter, 0, 0) : (valueBefore, valueAfter, effect);\\n    }\\n\\n    /**\\n     * @dev Get the current value plus the pending value and effect timepoint if there is a scheduled change. If the\\n     * effect timepoint is 0, then the pending value should not be considered.\\n     */\\n    function getFull(Delay self) internal view returns (uint32, uint32, uint48) {\\n        return _getFullAt(self, timestamp());\\n    }\\n\\n    /**\\n     * @dev Get the current value.\\n     */\\n    function get(Delay self) internal view returns (uint32) {\\n        (uint32 delay, , ) = self.getFull();\\n        return delay;\\n    }\\n\\n    /**\\n     * @dev Update a Delay object so that it takes a new duration after a timepoint that is automatically computed to\\n     * enforce the old delay at the moment of the update. Returns the updated Delay object and the timestamp when the\\n     * new delay becomes effective.\\n     */\\n    function withUpdate(\\n        Delay self,\\n        uint32 newValue,\\n        uint32 minSetback\\n    ) internal view returns (Delay updatedDelay, uint48 effect) {\\n        uint32 value = self.get();\\n        uint32 setback = uint32(Math.max(minSetback, value > newValue ? value - newValue : 0));\\n        effect = timestamp() + setback;\\n        return (pack(value, newValue, effect), effect);\\n    }\\n\\n    /**\\n     * @dev Split a delay into its components: valueBefore, valueAfter and effect (transition timepoint).\\n     */\\n    function unpack(Delay self) internal pure returns (uint32 valueBefore, uint32 valueAfter, uint48 effect) {\\n        uint112 raw = Delay.unwrap(self);\\n\\n        valueAfter = uint32(raw);\\n        valueBefore = uint32(raw >> 32);\\n        effect = uint48(raw >> 64);\\n\\n        return (valueBefore, valueAfter, effect);\\n    }\\n\\n    /**\\n     * @dev pack the components into a Delay object.\\n     */\\n    function pack(uint32 valueBefore, uint32 valueAfter, uint48 effect) internal pure returns (Delay) {\\n        return Delay.wrap((uint112(effect) << 64) | (uint112(valueBefore) << 32) | uint112(valueAfter));\\n    }\\n}\\n\",\"keccak256\":\"0xc7755af115020049e4140f224f9ee88d7e1799ffb0646f37bf0df24bf6213f58\",\"license\":\"MIT\"},\"@story-protocol/protocol-core/contracts/interfaces/IIPAccount.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.23;\\n\\nimport { IERC721Receiver } from \\\"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\\\";\\nimport { IERC1155Receiver } from \\\"@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\\\";\\nimport { IERC6551Account } from \\\"erc6551/interfaces/IERC6551Account.sol\\\";\\nimport { IIPAccountStorage } from \\\"./IIPAccountStorage.sol\\\";\\n\\n/// @title IIPAccount\\n/// @dev IPAccount is a token-bound account that adopts the EIP-6551 standard.\\n/// These accounts are deployed at deterministic addresses through the official 6551 account registry.\\n/// As a deployed smart contract, IPAccount can store IP-related information,\\n/// like ownership of other NFTs such as license NFT or Royalty NFT.\\n/// IPAccount can interact with modules by making calls as a normal transaction sender.\\n/// This allows for seamless operations on the state and data of IP.\\n/// IPAccount is core identity for all actions.\\ninterface IIPAccount is IERC6551Account, IERC721Receiver, IERC1155Receiver, IIPAccountStorage {\\n    /// @notice Emitted when a transaction is executed.\\n    /// @param to The recipient of the transaction.\\n    /// @param value The amount of Ether sent.\\n    /// @param data The data sent along with the transaction.\\n    /// @param nonce The nonce of the transaction.\\n    event Executed(address indexed to, uint256 value, bytes data, uint256 nonce);\\n\\n    /// @notice Emitted when a transaction is executed on behalf of the signer.\\n    /// @param to The recipient of the transaction.\\n    /// @param value The amount of Ether sent.\\n    /// @param data The data sent along with the transaction.\\n    /// @param nonce The nonce of the transaction.\\n    /// @param deadline The deadline of the transaction signature.\\n    /// @param signer The signer of the transaction.\\n    /// @param signature The signature of the transaction, EIP-712 encoded.\\n    event ExecutedWithSig(\\n        address indexed to,\\n        uint256 value,\\n        bytes data,\\n        uint256 nonce,\\n        uint256 deadline,\\n        address indexed signer,\\n        bytes signature\\n    );\\n\\n    /// @notice Returns the IPAccount's internal nonce for transaction ordering.\\n    function state() external view returns (uint256);\\n\\n    /// @notice Returns the identifier of the non-fungible token which owns the account\\n    /// @return chainId The EIP-155 ID of the chain the token exists on\\n    /// @return tokenContract The contract address of the token\\n    /// @return tokenId The ID of the token\\n    function token() external view returns (uint256, address, uint256);\\n\\n    /// @notice Checks if the signer is valid for the given data\\n    /// @param signer The signer to check\\n    /// @param data The data to check against\\n    /// @return The function selector if the signer is valid, 0 otherwise\\n    function isValidSigner(address signer, bytes calldata data) external view returns (bytes4);\\n\\n    /// @notice Returns the owner of the IP Account.\\n    /// @return owner The address of the owner.\\n    function owner() external view returns (address);\\n\\n    /// @notice Executes a transaction from the IP Account on behalf of the signer.\\n    /// @param to The recipient of the transaction.\\n    /// @param value The amount of Ether to send.\\n    /// @param data The data to send along with the transaction.\\n    /// @param signer The signer of the transaction.\\n    /// @param deadline The deadline of the transaction signature.\\n    /// @param signature The signature of the transaction, EIP-712 encoded.\\n    /// @return result The return data from the transaction.\\n    function executeWithSig(\\n        address to,\\n        uint256 value,\\n        bytes calldata data,\\n        address signer,\\n        uint256 deadline,\\n        bytes calldata signature\\n    ) external payable returns (bytes memory);\\n\\n    /// @notice Executes a transaction from the IP Account.\\n    /// @param to The recipient of the transaction.\\n    /// @param value The amount of Ether to send.\\n    /// @param data The data to send along with the transaction.\\n    /// @return result The return data from the transaction.\\n    function execute(address to, uint256 value, bytes calldata data) external payable returns (bytes memory);\\n}\\n\",\"keccak256\":\"0x6b4b6fbedebe4da10a346aeeb027ed3dc2d4953578ded7bd53d391440fb79926\",\"license\":\"BUSL-1.1\"},\"@story-protocol/protocol-core/contracts/interfaces/IIPAccountStorage.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\n// See https://github.com/storyprotocol/protocol-contracts/blob/main/StoryProtocol-AlphaTestingAgreement-17942166.3.pdf\\npragma solidity ^0.8.23;\\n\\n/// @title IPAccount Namespaced Storage Interface\\n/// @dev Provides a structured way to store IPAccount's state using a namespaced storage pattern.\\n/// This interface facilitates conflict-free data writing by different Modules into the same IPAccount\\n/// by utilizing namespaces.\\n/// The default namespace for write operations is determined by the `msg.sender`, ensuring that only the owning Module\\n/// (i.e., the Module calling the write functions) can write data into its respective namespace.\\n/// However, read operations are unrestricted and can access any namespace.\\n///\\n/// Rules:\\n/// - The default namespace for a Module is its own address.\\n/// - Every Module can read data from any namespace.\\n/// - Only the owning Module (i.e., the Module whose address is used as the namespace) can write data into\\n///   its respective namespace.\\ninterface IIPAccountStorage {\\n    /// @dev Sets a bytes value under a given key within the default namespace, determined by `msg.sender`.\\n    /// @param key The key under which to store the value.\\n    /// @param value The bytes value to be stored.\\n    function setBytes(bytes32 key, bytes calldata value) external;\\n\\n    /// @dev Retrieves a bytes value by a given key from the default namespace.\\n    /// @param key The key whose value is to be retrieved.\\n    /// @return The bytes value stored under the specified key.\\n    function getBytes(bytes32 key) external view returns (bytes memory);\\n\\n    /// @dev Retrieves a bytes value by a given key from a specified namespace.\\n    /// @param namespace The namespace from which to retrieve the value.\\n    /// @param key The key whose value is to be retrieved.\\n    /// @return The bytes value stored under the specified key in the given namespace.\\n    function getBytes(bytes32 namespace, bytes32 key) external view returns (bytes memory);\\n\\n    /// @dev Sets a bytes32 value under a given key within the default namespace, determined by `msg.sender`.\\n    /// @param key The key under which to store the value.\\n    /// @param value The bytes32 value to be stored.\\n    function setBytes32(bytes32 key, bytes32 value) external;\\n\\n    /// @dev Retrieves a bytes32 value by a given key from the default namespace.\\n    /// @param key The key whose value is to be retrieved.\\n    /// @return The bytes32 value stored under the specified key.\\n    function getBytes32(bytes32 key) external view returns (bytes32);\\n\\n    /// @dev Retrieves a bytes32 value by a given key from a specified namespace.\\n    /// @param namespace The namespace from which to retrieve the value.\\n    /// @param key The key whose value is to be retrieved.\\n    /// @return The bytes32 value stored under the specified key in the given namespace.\\n    function getBytes32(bytes32 namespace, bytes32 key) external view returns (bytes32);\\n}\\n\",\"keccak256\":\"0x002356819552d10fda363237ace488b948af1304883d834c0abcaa52dd0ab903\",\"license\":\"UNLICENSED\"},\"@story-protocol/protocol-core/contracts/interfaces/registries/IIPAccountRegistry.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.23;\\n\\n/// @title Interface for IP Account Registry\\n/// @notice This interface manages the registration and tracking of IP Accounts\\ninterface IIPAccountRegistry {\\n    /// @notice Event emitted when a new IP Account is created\\n    /// @param account The address of the new IP Account\\n    /// @param implementation The address of the IP Account implementation\\n    /// @param chainId The chain ID where the token contract was deployed\\n    /// @param tokenContract The address of the token contract associated with the IP Account\\n    /// @param tokenId The ID of the token associated with the IP Account\\n    event IPAccountRegistered(\\n        address indexed account,\\n        address indexed implementation,\\n        uint256 indexed chainId,\\n        address tokenContract,\\n        uint256 tokenId\\n    );\\n\\n    /// @notice Returns the IPAccount implementation address\\n    function IP_ACCOUNT_IMPL() external view returns (address);\\n\\n    /// @notice Returns the IPAccount salt\\n    function IP_ACCOUNT_SALT() external view returns (bytes32);\\n\\n    /// @notice Returns the public ERC6551 registry address\\n    function ERC6551_PUBLIC_REGISTRY() external view returns (address);\\n\\n    /// @notice Deploys an IPAccount contract with the IPAccount implementation and returns the address of the new IP\\n    /// @dev The IPAccount deployment deltegates to public ERC6551 Registry\\n    /// @param chainId The chain ID where the IP Account will be created\\n    /// @param tokenContract The address of the token contract to be associated with the IP Account\\n    /// @param tokenId The ID of the token to be associated with the IP Account\\n    /// @return ipAccountAddress The address of the newly created IP Account\\n    function registerIpAccount(uint256 chainId, address tokenContract, uint256 tokenId) external returns (address);\\n\\n    /// @notice Returns the IPAccount address for the given NFT token.\\n    /// @param chainId The chain ID where the IP Account is located\\n    /// @param tokenContract The address of the token contract associated with the IP Account\\n    /// @param tokenId The ID of the token associated with the IP Account\\n    /// @return ipAccountAddress The address of the IP Account associated with the given NFT token\\n    function ipAccount(uint256 chainId, address tokenContract, uint256 tokenId) external view returns (address);\\n\\n    /// @notice Returns the IPAccount implementation address.\\n    /// @return The address of the IPAccount implementation\\n    function getIPAccountImpl() external view returns (address);\\n}\\n\",\"keccak256\":\"0x68aa5cbaebd58ffc2411222abb47eb57ddd13aba07bff13c6b4e4a737e7c37fe\",\"license\":\"BUSL-1.1\"},\"@story-protocol/protocol-core/contracts/interfaces/registries/IIPAssetRegistry.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.23;\\n\\nimport { IIPAccountRegistry } from \\\"./IIPAccountRegistry.sol\\\";\\n\\n/// @title Interface for IP Account Registry\\n/// @notice This interface manages the registration and tracking of IP Accounts\\ninterface IIPAssetRegistry is IIPAccountRegistry {\\n    /// @notice Emits when an IP is officially registered into the protocol.\\n    /// @param ipId The canonical identifier for the IP.\\n    /// @param chainId The chain identifier of where the IP resides.\\n    /// @param tokenContract The token contract address of the IP NFT.\\n    /// @param tokenId The token identifier of the IP.\\n    /// @param name The name of the IP.\\n    /// @param uri The URI of the IP.\\n    /// @param registrationDate The date and time the IP was registered.\\n    event IPRegistered(\\n        address ipId,\\n        uint256 indexed chainId,\\n        address indexed tokenContract,\\n        uint256 indexed tokenId,\\n        string name,\\n        string uri,\\n        uint256 registrationDate\\n    );\\n\\n    /// @notice Tracks the total number of IP assets in existence.\\n    function totalSupply() external view returns (uint256);\\n\\n    /// @notice Registers an NFT as an IP asset.\\n    /// @param chainid The chain identifier of where the IP NFT resides.\\n    /// @param tokenContract The address of the NFT.\\n    /// @param tokenId The token identifier of the NFT.\\n    /// @return id The address of the newly registered IP.\\n    function register(uint256 chainid, address tokenContract, uint256 tokenId) external returns (address id);\\n\\n    /// @notice Gets the canonical IP identifier associated with an IP NFT.\\n    /// @dev This is equivalent to the address of its bound IP account.\\n    /// @param chainId The chain identifier of where the IP resides.\\n    /// @param tokenContract The address of the IP.\\n    /// @param tokenId The token identifier of the IP.\\n    /// @return ipId The IP's canonical address identifier.\\n    function ipId(uint256 chainId, address tokenContract, uint256 tokenId) external view returns (address);\\n\\n    /// @notice Checks whether an IP was registered based on its ID.\\n    /// @param id The canonical identifier for the IP.\\n    /// @return isRegistered Whether the IP was registered into the protocol.\\n    function isRegistered(address id) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x908667d5f302aa50635cbabe47d04b20054c338a9995529dffb719de43c35e43\",\"license\":\"BUSL-1.1\"},\"@story-protocol/protocol-core/contracts/lib/Errors.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.23;\\n\\n/// @title Errors Library\\n/// @notice Library for all Story Protocol contract errors.\\nlibrary Errors {\\n    ////////////////////////////////////////////////////////////////////////////\\n    //                                IP Account                              //\\n    ////////////////////////////////////////////////////////////////////////////\\n\\n    /// @notice Zero address provided for Access Controller.\\n    error IPAccount__ZeroAccessController();\\n\\n    /// @notice Invalid signer provided.\\n    error IPAccount__InvalidSigner();\\n\\n    /// @notice Invalid signature provided, must be an EIP-712 signature.\\n    error IPAccount__InvalidSignature();\\n\\n    /// @notice Signature is expired.\\n    error IPAccount__ExpiredSignature();\\n\\n    /// @notice Provided calldata is invalid.\\n    error IPAccount__InvalidCalldata();\\n\\n    ////////////////////////////////////////////////////////////////////////////\\n    //                            IP Account Storage                          //\\n    ////////////////////////////////////////////////////////////////////////////\\n\\n    /// @notice Caller writing to IP Account storage is not a registered module.\\n    error IPAccountStorage__NotRegisteredModule(address module);\\n\\n    ////////////////////////////////////////////////////////////////////////////\\n    //                           IP Account Registry                          //\\n    ////////////////////////////////////////////////////////////////////////////\\n\\n    /// @notice Zero address provided for IP Account implementation.\\n    error IPAccountRegistry_ZeroIpAccountImpl();\\n\\n    ////////////////////////////////////////////////////////////////////////////\\n    //                            IP Asset Registry                           //\\n    ////////////////////////////////////////////////////////////////////////////\\n\\n    /// @notice Zero address provided for Access Manager in initializer.\\n    error IPAssetRegistry__ZeroAccessManager();\\n\\n    /// @notice The IP asset has already been registered.\\n    error IPAssetRegistry__AlreadyRegistered();\\n\\n    /// @notice The NFT token contract is not valid ERC721 contract.\\n    error IPAssetRegistry__UnsupportedIERC721(address contractAddress);\\n\\n    /// @notice The NFT token contract does not support ERC721Metadata.\\n    error IPAssetRegistry__UnsupportedIERC721Metadata(address contractAddress);\\n\\n    /// @notice The NFT token id does not exist or invalid.\\n    error IPAssetRegistry__InvalidToken(address contractAddress, uint256 tokenId);\\n\\n    ////////////////////////////////////////////////////////////////////////////\\n    //                            License Registry                            //\\n    ////////////////////////////////////////////////////////////////////////////\\n\\n    /// @notice Zero address provided for Access Manager in initializer.\\n    error LicenseRegistry__ZeroAccessManager();\\n\\n    /// @notice Zero address provided for Licensing Module.\\n    error LicenseRegistry__ZeroLicensingModule();\\n\\n    /// @notice Zero address provided for Dispute Module.\\n    error LicenseRegistry__ZeroDisputeModule();\\n\\n    /// @notice Caller is not the Licensing Module.\\n    error LicenseRegistry__CallerNotLicensingModule();\\n\\n    /// @notice Emitted when trying to transfer a license that is not transferable (by policy)\\n    error LicenseRegistry__NotTransferable();\\n\\n    /// @notice License Template is not registered in the License Registry.\\n    error LicenseRegistry__UnregisteredLicenseTemplate(address licenseTemplate);\\n\\n    /// @notice License Terms or License Template not found.\\n    error LicenseRegistry__LicenseTermsNotExists(address licenseTemplate, uint256 licenseTermsId);\\n\\n    /// @notice Licensor IP does not have the provided license terms attached.\\n    error LicenseRegistry__LicensorIpHasNoLicenseTerms(address ipId, address licenseTemplate, uint256 licenseTermsId);\\n\\n    /// @notice Invalid License Template address provided.\\n    error LicenseRegistry__NotLicenseTemplate(address licenseTemplate);\\n\\n    /// @notice IP is expired.\\n    error LicenseRegistry__IpExpired(address ipId);\\n\\n    /// @notice Parent IP is expired.\\n    error LicenseRegistry__ParentIpExpired(address ipId);\\n\\n    /// @notice Parent IP is dispute tagged.\\n    error LicenseRegistry__ParentIpTagged(address ipId);\\n\\n    /// @notice Parent IP does not have the provided license terms attached.\\n    error LicenseRegistry__ParentIpHasNoLicenseTerms(address ipId, uint256 licenseTermsId);\\n\\n    /// @notice Empty Parent IP list provided.\\n    error LicenseRegistry__NoParentIp();\\n\\n    /// @notice Provided derivative IP already has license terms attached.\\n    error LicenseRegistry__DerivativeIpAlreadyHasLicense(address childIpId);\\n\\n    /// @notice Provided derivative IP is already registered.\\n    error LicenseRegistry__DerivativeAlreadyRegistered(address childIpId);\\n\\n    /// @notice Provided derivative IP is the same as the parent IP.\\n    error LicenseRegistry__DerivativeIsParent(address ipId);\\n\\n    /// @notice Provided license template does not match the parent IP's current license template.\\n    error LicenseRegistry__ParentIpUnmatchedLicenseTemplate(address ipId, address licenseTemplate);\\n\\n    /// @notice Index out of bounds.\\n    error LicenseRegistry__IndexOutOfBounds(address ipId, uint256 index, uint256 length);\\n\\n    /// @notice Provided license template and terms ID is already attached to IP.\\n    error LicenseRegistry__LicenseTermsAlreadyAttached(address ipId, address licenseTemplate, uint256 licenseTermsId);\\n\\n    /// @notice Provided license template does not match the IP's current license template.\\n    error LicenseRegistry__UnmatchedLicenseTemplate(address ipId, address licenseTemplate, address newLicenseTemplate);\\n\\n    /// @notice Provided license template and terms ID is a duplicate.\\n    error LicenseRegistry__DuplicateLicense(address ipId, address licenseTemplate, uint256 licenseTermsId);\\n\\n    ////////////////////////////////////////////////////////////////////////////\\n    //                             License Token                              //\\n    ////////////////////////////////////////////////////////////////////////////\\n\\n    /// @notice Zero address provided for Access Manager in initializer.\\n    error LicenseToken__ZeroAccessManager();\\n\\n    /// @notice Zero address provided for Licensing Module.\\n    error LicenseToken__ZeroLicensingModule();\\n\\n    /// @notice Zero address provided for Dispute Module.\\n    error LicenseToken__ZeroDisputeModule();\\n\\n    /// @notice Caller is not the Licensing Module.\\n    error LicenseToken__CallerNotLicensingModule();\\n\\n    /// @notice License token is revoked.\\n    error LicenseToken__RevokedLicense(uint256 tokenId);\\n\\n    /// @notice License token is not transferable.\\n    error LicenseToken__NotTransferable();\\n\\n    /// @notice License token is expired.\\n    error LicenseToken__LicenseTokenExpired(uint256 tokenId, uint256 expiredAt, uint256 currentTimestamp);\\n\\n    /// @notice License token is not owned by the caller.\\n    error LicenseToken__NotLicenseTokenOwner(uint256 tokenId, address iPowner, address tokenOwner);\\n\\n    /// @notice All license tokens must be from the same license template.\\n    error LicenseToken__AllLicenseTokensMustFromSameLicenseTemplate(\\n        address licenseTemplate,\\n        address anotherLicenseTemplate\\n    );\\n\\n    ////////////////////////////////////////////////////////////////////////////\\n    //                           Licensing Module                             //\\n    ////////////////////////////////////////////////////////////////////////////\\n\\n    /// @notice Zero address provided for Access Manager in initializer.\\n    error LicensingModule__ZeroAccessManager();\\n\\n    /// @notice Receiver is zero address.\\n    error LicensingModule__ReceiverZeroAddress();\\n\\n    /// @notice Mint amount is zero.\\n    error LicensingModule__MintAmountZero();\\n\\n    /// @notice IP is dispute tagged.\\n    error LicensingModule__DisputedIpId();\\n\\n    /// @notice License template and terms ID is not found.\\n    error LicensingModule__LicenseTermsNotFound(address licenseTemplate, uint256 licenseTermsId);\\n\\n    /// @notice Derivative IP cannot add license terms.\\n    error LicensingModule__DerivativesCannotAddLicenseTerms();\\n\\n    /// @notice Receiver check failed.\\n    error LicensingModule__ReceiverCheckFailed(address receiver);\\n\\n    /// @notice IP list and license terms list length mismatch.\\n    error LicensingModule__LicenseTermsLengthMismatch(uint256 ipLength, uint256 licenseTermsLength);\\n\\n    /// @notice Parent IP list is empty.\\n    error LicensingModule__NoParentIp();\\n\\n    /// @notice Incompatible royalty policy.\\n    error LicensingModule__IncompatibleRoyaltyPolicy(address royaltyPolicy, address anotherRoyaltyPolicy);\\n\\n    /// @notice License template and terms are not compatible for the derivative IP.\\n    error LicensingModule__LicenseNotCompatibleForDerivative(address childIpId);\\n\\n    /// @notice License token list is empty.\\n    error LicensingModule__NoLicenseToken();\\n\\n    /// @notice License tokens are not compatible for the derivative IP.\\n    error LicensingModule__LicenseTokenNotCompatibleForDerivative(address childIpId, uint256[] licenseTokenIds);\\n\\n    /// @notice License template denied minting license token during the verification stage.\\n    error LicensingModule__LicenseDenyMintLicenseToken(\\n        address licenseTemplate,\\n        uint256 licenseTermsId,\\n        address licensorIpId\\n    );\\n\\n    ////////////////////////////////////////////////////////////////////////////\\n    //                             Dispute Module                             //\\n    ////////////////////////////////////////////////////////////////////////////\\n\\n    /// @notice Zero address provided for Access Manager in initializer.\\n    error DisputeModule__ZeroAccessManager();\\n\\n    /// @notice Zero address provided for License Registry.\\n    error DisputeModule__ZeroLicenseRegistry();\\n\\n    /// @notice Zero address provided for IP Asset Registry.\\n    error DisputeModule__ZeroIPAssetRegistry();\\n\\n    /// @notice Zero address provided for Access Controller.\\n    error DisputeModule__ZeroAccessController();\\n\\n    /// @notice Zero address provided for Arbitration Policy.\\n    error DisputeModule__ZeroArbitrationPolicy();\\n\\n    /// @notice Zero address provided for Arbitration Relayer.\\n    error DisputeModule__ZeroArbitrationRelayer();\\n\\n    /// @notice Zero bytes provided for Dispute Tag.\\n    error DisputeModule__ZeroDisputeTag();\\n\\n    /// @notice Zero bytes provided for Dispute Evidence.\\n    error DisputeModule__ZeroLinkToDisputeEvidence();\\n\\n    /// @notice Not a whitelisted arbitration policy.\\n    error DisputeModule__NotWhitelistedArbitrationPolicy();\\n\\n    /// @notice Not a whitelisted arbitration relayer.\\n    error DisputeModule__NotWhitelistedArbitrationRelayer();\\n\\n    /// @notice Not a whitelisted dispute tag.\\n    error DisputeModule__NotWhitelistedDisputeTag();\\n\\n    /// @notice Not the dispute initiator.\\n    error DisputeModule__NotDisputeInitiator();\\n\\n    /// @notice Not in dispute state, the dispute is not IN_DISPUTE.\\n    error DisputeModule__NotInDisputeState();\\n\\n    /// @notice Not able to resolve a dispute, either the dispute is IN_DISPUTE or empty.\\n    error DisputeModule__NotAbleToResolve();\\n\\n    /// @notice Not a registered IP.\\n    error DisputeModule__NotRegisteredIpId();\\n\\n    /// @notice Provided parent IP and the parent dispute's target IP is different.\\n    error DisputeModule__ParentIpIdMismatch();\\n\\n    /// @notice Provided parent dispute's target IP is not dispute tagged.\\n    error DisputeModule__ParentNotTagged();\\n\\n    /// @notice Provided parent dispute's target IP is not the derivative IP's parent.\\n    error DisputeModule__NotDerivative();\\n\\n    /// @notice Provided parent dispute has not been resolved.\\n    error DisputeModule__ParentDisputeNotResolved();\\n\\n    ////////////////////////////////////////////////////////////////////////////\\n    //                         ArbitrationPolicy SP                          //\\n    ////////////////////////////////////////////////////////////////////////////\\n\\n    /// @notice Zero address provided for Access Manager in initializer.\\n    error ArbitrationPolicySP__ZeroAccessManager();\\n\\n    /// @notice Zero address provided for Dispute Module.\\n    error ArbitrationPolicySP__ZeroDisputeModule();\\n\\n    /// @notice Zero address provided for Payment Token.\\n    error ArbitrationPolicySP__ZeroPaymentToken();\\n\\n    /// @notice Caller is not the Dispute Module.\\n    error ArbitrationPolicySP__NotDisputeModule();\\n\\n    ////////////////////////////////////////////////////////////////////////////\\n    //                            Royalty Module                              //\\n    ////////////////////////////////////////////////////////////////////////////\\n\\n    /// @notice Zero address provided for Access Manager in initializer.\\n    error RoyaltyModule__ZeroAccessManager();\\n\\n    /// @notice Zero address provided for Dispute Module.\\n    error RoyaltyModule__ZeroDisputeModule();\\n\\n    /// @notice Zero address provided for License Registry.\\n    error RoyaltyModule__ZeroLicenseRegistry();\\n\\n    /// @notice Zero address provided for Licensing Module.\\n    error RoyaltyModule__ZeroLicensingModule();\\n\\n    /// @notice Zero address provided for Royalty Policy.\\n    error RoyaltyModule__ZeroRoyaltyPolicy();\\n\\n    /// @notice Zero address provided for Royalty Token.\\n    error RoyaltyModule__ZeroRoyaltyToken();\\n\\n    /// @notice Not a whitelisted royalty policy.\\n    error RoyaltyModule__NotWhitelistedRoyaltyPolicy();\\n\\n    /// @notice Not a whitelisted royalty token.\\n    error RoyaltyModule__NotWhitelistedRoyaltyToken();\\n\\n    /// @notice Royalty policy for IP is unset.\\n    error RoyaltyModule__NoRoyaltyPolicySet();\\n\\n    /// @notice Royalty policy between IPs are incompatible (different).\\n    error RoyaltyModule__IncompatibleRoyaltyPolicy();\\n\\n    /// @notice Caller is unauthorized.\\n    error RoyaltyModule__NotAllowedCaller();\\n\\n    /// @notice IP can only mint licenses of selected royalty policy.\\n    error RoyaltyModule__CanOnlyMintSelectedPolicy();\\n\\n    /// @notice Parent IP list for linking is empty.\\n    error RoyaltyModule__NoParentsOnLinking();\\n\\n    /// @notice IP is expired.\\n    error RoyaltyModule__IpIsExpired();\\n\\n    /// @notice IP is dipute tagged.\\n    error RoyaltyModule__IpIsTagged();\\n\\n    ////////////////////////////////////////////////////////////////////////////\\n    //                            Royalty Policy LAP                          //\\n    ////////////////////////////////////////////////////////////////////////////\\n\\n    /// @notice Zero address provided for Access Manager in initializer.\\n    error RoyaltyPolicyLAP__ZeroAccessManager();\\n\\n    /// @notice Zero address provided for IP Royalty Vault Beacon.\\n    error RoyaltyPolicyLAP__ZeroIpRoyaltyVaultBeacon();\\n\\n    /// @notice Zero address provided for Royalty Module.\\n    error RoyaltyPolicyLAP__ZeroRoyaltyModule();\\n\\n    /// @notice Zero address provided for Licensing Module.\\n    error RoyaltyPolicyLAP__ZeroLicensingModule();\\n\\n    /// @notice Caller is not the Royalty Module.\\n    error RoyaltyPolicyLAP__NotRoyaltyModule();\\n\\n    /// @notice Size of parent IP list is above the LAP royalty policy limit.\\n    error RoyaltyPolicyLAP__AboveParentLimit();\\n\\n    /// @notice Amount of ancestors for derivative IP is above the LAP royalty policy limit.\\n    error RoyaltyPolicyLAP__AboveAncestorsLimit();\\n\\n    /// @notice Total royalty stack exceeds the protocol limit.\\n    error RoyaltyPolicyLAP__AboveRoyaltyStackLimit();\\n\\n    /// @notice Size of parent royalties list and parent IP list mismatch.\\n    error RoyaltyPolicyLAP__InvalidParentRoyaltiesLength();\\n\\n    /// @notice IP cannot be linked to a parent, because it is either already linked to parents or derivatives (root).\\n    error RoyaltyPolicyLAP__UnlinkableToParents();\\n\\n    /// @notice Policy is already initialized and IP is at the ancestors limit, so it can't mint more licenses.\\n    error RoyaltyPolicyLAP__LastPositionNotAbleToMintLicense();\\n\\n    ////////////////////////////////////////////////////////////////////////////\\n    //                             IP Royalty Vault                           //\\n    ////////////////////////////////////////////////////////////////////////////\\n\\n    /// @notice Zero address provided for Royalty Policy LAP.\\n    error IpRoyaltyVault__ZeroRoyaltyPolicyLAP();\\n\\n    /// @notice Zero address provided for Dispute Module.\\n    error IpRoyaltyVault__ZeroDisputeModule();\\n\\n    /// @notice Caller is not the Royalty Policy LAP.\\n    error IpRoyaltyVault__NotRoyaltyPolicyLAP();\\n\\n    /// @notice Snapshot interval is too short, wait for the interval to pass for the next snapshot.\\n    error IpRoyaltyVault__SnapshotIntervalTooShort();\\n\\n    /// @notice Royalty Tokens is already claimed.\\n    error IpRoyaltyVault__AlreadyClaimed();\\n\\n    /// @notice Royalty Tokens claimer is not an ancestor of derivative IP.\\n    error IpRoyaltyVault__ClaimerNotAnAncestor();\\n\\n    /// @notice IP is dispute tagged.\\n    error IpRoyaltyVault__IpTagged();\\n\\n    /// @notice IP Royalty Vault is paused.\\n    error IpRoyaltyVault__EnforcedPause();\\n\\n    ////////////////////////////////////////////////////////////////////////////\\n    //                             Module Registry                            //\\n    ////////////////////////////////////////////////////////////////////////////\\n\\n    /// @notice Zero address provided for Access Manager in initializer.\\n    error ModuleRegistry__ZeroAccessManager();\\n\\n    /// @notice Module is zero address.\\n    error ModuleRegistry__ModuleAddressZeroAddress();\\n\\n    /// @notice Provided module address is not a contract.\\n    error ModuleRegistry__ModuleAddressNotContract();\\n\\n    /// @notice Module is already registered.\\n    error ModuleRegistry__ModuleAlreadyRegistered();\\n\\n    /// @notice Provided module name is empty string.\\n    error ModuleRegistry__NameEmptyString();\\n\\n    /// @notice Provided module name is already regsitered.\\n    error ModuleRegistry__NameAlreadyRegistered();\\n\\n    /// @notice Module name does not match the given name.\\n    error ModuleRegistry__NameDoesNotMatch();\\n\\n    /// @notice Module is not registered\\n    error ModuleRegistry__ModuleNotRegistered();\\n\\n    /// @notice Provided interface ID is zero bytes4.\\n    error ModuleRegistry__InterfaceIdZero();\\n\\n    /// @notice Module type is already registered.\\n    error ModuleRegistry__ModuleTypeAlreadyRegistered();\\n\\n    /// @notice Module type is not registered.\\n    error ModuleRegistry__ModuleTypeNotRegistered();\\n\\n    /// @notice Module address does not support the interface ID (module type).\\n    error ModuleRegistry__ModuleNotSupportExpectedModuleTypeInterfaceId();\\n\\n    /// @notice Module type is empty string.\\n    error ModuleRegistry__ModuleTypeEmptyString();\\n\\n    ////////////////////////////////////////////////////////////////////////////\\n    //                            Access Controller                           //\\n    ////////////////////////////////////////////////////////////////////////////\\n\\n    /// @notice Zero address provided for Access Manager in initializer.\\n    error AccessController__ZeroAccessManager();\\n\\n    /// @notice IP Account is zero address.\\n    error AccessController__IPAccountIsZeroAddress();\\n\\n    /// @notice IP Account is not a valid SP IP Account address.\\n    error AccessController__IPAccountIsNotValid(address ipAccount);\\n\\n    /// @notice Signer is zero address.\\n    error AccessController__SignerIsZeroAddress();\\n\\n    /// @notice Caller is not the IP Account or its owner.\\n    error AccessController__CallerIsNotIPAccountOrOwner();\\n\\n    /// @notice Invalid permission value, must be 0 (ABSTAIN), 1 (ALLOW) or 2 (DENY).\\n    error AccessController__PermissionIsNotValid();\\n\\n    /// @notice Both the caller and recipient (to) are not registered modules.\\n    error AccessController__BothCallerAndRecipientAreNotRegisteredModule(address signer, address to);\\n\\n    /// @notice Permission denied.\\n    error AccessController__PermissionDenied(address ipAccount, address signer, address to, bytes4 func);\\n\\n    ////////////////////////////////////////////////////////////////////////////\\n    //                            Access Controlled                           //\\n    ////////////////////////////////////////////////////////////////////////////\\n\\n    /// @notice Zero address passed.\\n    error AccessControlled__ZeroAddress();\\n\\n    /// @notice IP Account is not a valid SP IP Account address.\\n    error AccessControlled__NotIpAccount(address ipAccount);\\n\\n    /// @notice Caller is not the IP Account.\\n    error AccessControlled__CallerIsNotIpAccount(address caller);\\n\\n    ////////////////////////////////////////////////////////////////////////////\\n    //                          Core Metadata Module                          //\\n    ////////////////////////////////////////////////////////////////////////////\\n\\n    /// @notice Core metadata is already frozen (immutable).\\n    error CoreMetadataModule__MetadataAlreadyFrozen();\\n\\n    ////////////////////////////////////////////////////////////////////////////\\n    //                          Protocol Pause Admin                          //\\n    ////////////////////////////////////////////////////////////////////////////\\n\\n    /// @notice Zero address passed.\\n    error ProtocolPauseAdmin__ZeroAddress();\\n\\n    /// @notice Adding a contract that is paused.\\n    error ProtocolPauseAdmin__AddingPausedContract();\\n\\n    /// @notice Contract is already added to the pausable list.\\n    error ProtocolPauseAdmin__PausableAlreadyAdded();\\n\\n    /// @notice Removing a contract that is not in the pausable list.\\n    error ProtocolPauseAdmin__PausableNotFound();\\n}\\n\",\"keccak256\":\"0xe97d2675aa56e46281e81c5556b0b9f0d40b4abf369e103480582bf5c8403e5a\",\"license\":\"BUSL-1.1\"},\"@story-protocol/protocol-core/contracts/lib/IPAccountStorageOps.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\n// See https://github.com/storyprotocol/protocol-contracts/blob/main/StoryProtocol-AlphaTestingAgreement-17942166.3.pdf\\npragma solidity ^0.8.23;\\n\\nimport { IIPAccountStorage } from \\\"../interfaces/IIPAccountStorage.sol\\\";\\nimport { ShortString, ShortStrings } from \\\"@openzeppelin/contracts/utils/ShortStrings.sol\\\";\\nimport { Strings } from \\\"@openzeppelin/contracts/utils/Strings.sol\\\";\\n/// @title IPAccount Storage Operations Library\\n/// @notice Provides utility functions that extend the basic functionalities of IPAccountStorage,\\n/// facilitating enhanced module interaction with IPAccount Namespaced Storage.\\n/// @dev This library enables modules to access and manipulate IPAccount Namespaced Storage\\n/// with additional features such as using `address` type namespaces and `ShortString` keys.\\n/// It serves as an addon to the fundamental IPAccountStorage functions, allowing for more complex and\\n/// flexible interactions with the namespaced storage.\\nlibrary IPAccountStorageOps {\\n    using ShortStrings for *;\\n    using Strings for *;\\n\\n    /// @dev Sets a string value under a given key within the default namespace, determined by `msg.sender`.\\n    /// @param ipStorage The instance of the IPAccountStorage contract.\\n    /// @param key The key under which to store the value.\\n    /// @param value The string value to be stored.\\n    function setString(IIPAccountStorage ipStorage, bytes32 key, string memory value) internal {\\n        ipStorage.setBytes(key, bytes(value));\\n    }\\n\\n    /// @dev Retrieves a string value by a given key from the default namespace.\\n    /// @param ipStorage The instance of the IPAccountStorage contract.\\n    /// @param key The key whose value is to be retrieved.\\n    /// @return The string value stored under the specified key.\\n    function getString(IIPAccountStorage ipStorage, bytes32 key) internal view returns (string memory) {\\n        return string(ipStorage.getBytes(key));\\n    }\\n\\n    /// @dev Retrieves a string value by a given key from a specified namespace.\\n    /// @param ipStorage The instance of the IPAccountStorage contract.\\n    /// @param namespace The namespace from which to retrieve the value.\\n    /// @param key The key whose value is to be retrieved.\\n    /// @return The string value stored under the specified key in the given namespace.\\n    function getString(\\n        IIPAccountStorage ipStorage,\\n        bytes32 namespace,\\n        bytes32 key\\n    ) internal view returns (string memory) {\\n        return string(ipStorage.getBytes(namespace, key));\\n    }\\n\\n    /// @notice Sets a string value in the storage using a `ShortString` key.\\n    /// @dev Converts the `ShortString` key to a `bytes32` representation before storing the value.\\n    /// @param ipStorage The instance of the IPAccountStorage contract.\\n    /// @param key The `ShortString` key under which to store the value.\\n    /// @param value The string value to be stored.\\n    function setString(IIPAccountStorage ipStorage, ShortString key, string memory value) internal {\\n        setString(ipStorage, toBytes32(key), value);\\n    }\\n\\n    /// @notice Retrieves a string value from the storage using a `ShortString` key.\\n    /// @dev Converts the `ShortString` key to a `bytes32` representation before retrieving the value.\\n    /// @param ipStorage The instance of the IPAccountStorage contract.\\n    /// @param key The `ShortString` key whose value is to be retrieved.\\n    /// @return The string value stored under the specified key.\\n    function getString(IIPAccountStorage ipStorage, ShortString key) internal view returns (string memory) {\\n        return getString(ipStorage, toBytes32(key));\\n    }\\n\\n    /// @notice Retrieves a string value from the storage under a specified namespace using a bytes32 key.\\n    /// @dev Retrieves the string value from the specified namespace using the provided key.\\n    /// @param ipStorage The instance of the IPAccountStorage contract.\\n    /// @param namespace The namespace under which to retrieve the value.\\n    /// @param key The bytes32 key whose value is to be retrieved.\\n    function getString(\\n        IIPAccountStorage ipStorage,\\n        address namespace,\\n        bytes32 key\\n    ) internal view returns (string memory) {\\n        return getString(ipStorage, toBytes32(namespace), key);\\n    }\\n\\n    /// @notice Retrieves a string value from the storage under a specified namespace using a `ShortString` key.\\n    /// @dev Retrieves the string value from the specified namespace using the provided `ShortString` key.\\n    /// @param ipStorage The instance of the IPAccountStorage contract.\\n    /// @param namespace The namespace under which to retrieve the value.\\n    /// @param key The `ShortString` key whose value is to be retrieved.\\n    function getString(\\n        IIPAccountStorage ipStorage,\\n        address namespace,\\n        ShortString key\\n    ) internal view returns (string memory) {\\n        return getString(ipStorage, toBytes32(namespace), toBytes32(key));\\n    }\\n\\n    /// @dev Sets an address value under a given key within the default namespace, determined by `msg.sender`.\\n    /// @param ipStorage The instance of the IPAccountStorage contract.\\n    /// @param key The key under which to store the value.\\n    /// @param value The address value to be stored.\\n    function setAddress(IIPAccountStorage ipStorage, bytes32 key, address value) internal {\\n        ipStorage.setBytes32(key, toBytes32(value));\\n    }\\n\\n    /// @dev Retrieves an address value by a given key from the default namespace.\\n    /// @param ipStorage The instance of the IPAccountStorage contract.\\n    /// @param key The key whose value is to be retrieved.\\n    /// @return The address value stored under the specified key.\\n    function getAddress(IIPAccountStorage ipStorage, bytes32 key) internal view returns (address) {\\n        return address(uint160(uint256(ipStorage.getBytes32(key))));\\n    }\\n\\n    /// @dev Retrieves an address value by a given key from a specified namespace.\\n    /// @param ipStorage The instance of the IPAccountStorage contract.\\n    /// @param namespace The namespace from which to retrieve the value.\\n    /// @param key The key whose value is to be retrieved.\\n    /// @return The address value stored under the specified key in the given namespace.\\n    function getAddress(IIPAccountStorage ipStorage, bytes32 namespace, bytes32 key) internal view returns (address) {\\n        return address(uint160(uint256(ipStorage.getBytes32(namespace, key))));\\n    }\\n\\n    /// @notice Sets an address value in the storage using a `ShortString` key.\\n    /// @dev Converts the `ShortString` key to a `bytes32` representation before storing the value,\\n    /// facilitating address storage in a compact format.\\n    /// @param ipStorage The instance of the IPAccountStorage contract.\\n    /// @param key The `ShortString` key under which to store the address value.\\n    /// @param value The address value to be stored.\\n    function setAddress(IIPAccountStorage ipStorage, ShortString key, address value) internal {\\n        setAddress(ipStorage, toBytes32(key), value);\\n    }\\n\\n    /// @notice Retrieves an address value from the storage using a `ShortString` key.\\n    /// @dev Converts the `ShortString` key to a `bytes32` representation before retrieving the value,\\n    /// ensuring the integrity of the address data.\\n    /// @param ipStorage The instance of the IPAccountStorage contract.\\n    /// @param key The `ShortString` key whose address value is to be retrieved.\\n    /// @return The address value stored under the specified key.\\n    function getAddress(IIPAccountStorage ipStorage, ShortString key) internal view returns (address) {\\n        return getAddress(ipStorage, toBytes32(key));\\n    }\\n\\n    /// @notice Retrieves an address value from the storage under a specified namespace using a bytes32 key.\\n    /// @dev Retrieves the address value from the specified namespace using the provided key.\\n    /// @param ipStorage The instance of the IPAccountStorage contract.\\n    /// @param namespace The namespace under which to retrieve the value.\\n    /// @param key The bytes32 key whose address value is to be retrieved.\\n    /// @return The address value stored under the specified key in the given namespace.\\n    function getAddress(IIPAccountStorage ipStorage, address namespace, bytes32 key) internal view returns (address) {\\n        return getAddress(ipStorage, toBytes32(namespace), key);\\n    }\\n\\n    /// @notice Retrieves an address value from the storage under a specified namespace using a `ShortString` key.\\n    /// @dev Retrieves the address value from the specified namespace using the provided `ShortString` key.\\n    /// @param ipStorage The instance of the IPAccountStorage contract.\\n    /// @param namespace The namespace under which to retrieve the value.\\n    /// @param key The `ShortString` key whose address value is to be retrieved.\\n    /// @return The address value stored under the specified key in the given namespace.\\n    function getAddress(\\n        IIPAccountStorage ipStorage,\\n        address namespace,\\n        ShortString key\\n    ) internal view returns (address) {\\n        return getAddress(ipStorage, toBytes32(namespace), toBytes32(key));\\n    }\\n\\n    /// @dev Sets a uint256 value under a given key within the default namespace, determined by `msg.sender`.\\n    /// @param ipStorage The instance of the IPAccountStorage contract.\\n    /// @param key The key under which to store the value.\\n    /// @param value The uint256 value to be stored.\\n    function setUint256(IIPAccountStorage ipStorage, bytes32 key, uint256 value) internal {\\n        ipStorage.setBytes32(key, bytes32(value));\\n    }\\n\\n    /// @dev Retrieves a uint256 value by a given key from the default namespace.\\n    /// @param ipStorage The instance of the IPAccountStorage contract.\\n    /// @param key The key whose value is to be retrieved.\\n    /// @return The uint256 value stored under the specified key.\\n    function getUint256(IIPAccountStorage ipStorage, bytes32 key) internal view returns (uint256) {\\n        return uint256(ipStorage.getBytes32(key));\\n    }\\n\\n    /// @dev Retrieves a uint256 value by a given key from a specified namespace.\\n    /// @param ipStorage The instance of the IPAccountStorage contract.\\n    /// @param namespace The namespace from which to retrieve the value.\\n    /// @param key The key whose value is to be retrieved.\\n    /// @return The uint256 value stored under the specified key in the given namespace.\\n    function getUint256(IIPAccountStorage ipStorage, bytes32 namespace, bytes32 key) internal view returns (uint256) {\\n        return uint256(ipStorage.getBytes32(namespace, key));\\n    }\\n\\n    /// @notice Sets a uint256 value in the storage using a `ShortString` key.\\n    /// @dev Converts the `ShortString` key to a `bytes32` representation before storing the value,\\n    /// facilitating uint256 storage in a compact format.\\n    /// @param ipStorage The instance of the IPAccountStorage contract.\\n    /// @param key The `ShortString` key under which to store the uint256 value.\\n    /// @param value The uint256 value to be stored.\\n    function setUint256(IIPAccountStorage ipStorage, ShortString key, uint256 value) internal {\\n        setUint256(ipStorage, toBytes32(key), value);\\n    }\\n\\n    /// @notice Retrieves a uint256 value from the storage using a `ShortString` key.\\n    /// @dev Converts the `ShortString` key to a `bytes32` representation before retrieving the value,\\n    /// ensuring the integrity of the uint256 data.\\n    /// @param ipStorage The instance of the IPAccountStorage contract.\\n    /// @param key The `ShortString` key whose uint256 value is to be retrieved.\\n    /// @return The uint256 value stored under the specified key.\\n    function getUint256(IIPAccountStorage ipStorage, ShortString key) internal view returns (uint256) {\\n        return getUint256(ipStorage, toBytes32(key));\\n    }\\n\\n    /// @notice Retrieves a uint256 value from the storage under a specified namespace using a bytes32 key.\\n    /// @dev Retrieves the uint256 value from the specified namespace using the provided key.\\n    /// @param ipStorage The instance of the IPAccountStorage contract.\\n    /// @param namespace The namespace under which to retrieve the value.\\n    /// @param key The bytes32 key whose uint256 value is to be retrieved.\\n    /// @return The uint256 value stored under the specified key in the given namespace.\\n    function getUint256(IIPAccountStorage ipStorage, address namespace, bytes32 key) internal view returns (uint256) {\\n        return getUint256(ipStorage, toBytes32(namespace), key);\\n    }\\n\\n    /// @notice Retrieves a uint256 value from the storage under a specified namespace using a `ShortString` key.\\n    /// @dev Retrieves the uint256 value from the specified namespace using the provided `ShortString` key.\\n    /// @param ipStorage The instance of the IPAccountStorage contract.\\n    /// @param namespace The namespace under which to retrieve the value.\\n    /// @param key The `ShortString` key whose uint256 value is to be retrieved.\\n    /// @return The uint256 value stored under the specified key in the given namespace.\\n    function getUint256(\\n        IIPAccountStorage ipStorage,\\n        address namespace,\\n        ShortString key\\n    ) internal view returns (uint256) {\\n        return getUint256(ipStorage, toBytes32(namespace), toBytes32(key));\\n    }\\n\\n    /// @dev Sets a boolean value under a given key within the default namespace, determined by `msg.sender`.\\n    /// @param ipStorage The instance of the IPAccountStorage contract.\\n    /// @param key The key under which to store the value.\\n    /// @param value The boolean value to be stored.\\n    function setBool(IIPAccountStorage ipStorage, bytes32 key, bool value) internal {\\n        ipStorage.setBytes32(key, value ? bytes32(uint256(1)) : bytes32(0));\\n    }\\n\\n    /// @dev Retrieves a boolean value by a given key from the default namespace.\\n    /// @param ipStorage The instance of the IPAccountStorage contract.\\n    /// @param key The key whose value is to be retrieved.\\n    /// @return The boolean value stored under the specified key.\\n    function getBool(IIPAccountStorage ipStorage, bytes32 key) internal view returns (bool) {\\n        return ipStorage.getBytes32(key) != 0;\\n    }\\n\\n    /// @dev Retrieves a boolean value by a given key from a specified namespace.\\n    /// @param ipStorage The instance of the IPAccountStorage contract.\\n    /// @param namespace The namespace from which to retrieve the value.\\n    /// @param key The key whose value is to be retrieved.\\n    /// @return The boolean value stored under the specified key in the given namespace.\\n    function getBool(IIPAccountStorage ipStorage, bytes32 namespace, bytes32 key) internal view returns (bool) {\\n        return ipStorage.getBytes32(namespace, key) != 0;\\n    }\\n\\n    /// @notice Sets a bool value in the storage using a `ShortString` key.\\n    /// @dev Converts the `ShortString` key to a `bytes32` representation before storing the value,\\n    /// facilitating bool storage in a compact format.\\n    /// @param ipStorage The instance of the IPAccountStorage contract.\\n    /// @param key The `ShortString` key under which to store the bool value.\\n    /// @param value The bool value to be stored.\\n    function setBool(IIPAccountStorage ipStorage, ShortString key, bool value) internal {\\n        setBool(ipStorage, toBytes32(key), value);\\n    }\\n\\n    /// @notice Retrieves a bool value from the storage using a `ShortString` key.\\n    /// @dev Converts the `ShortString` key to a `bytes32` representation before retrieving the value,\\n    /// ensuring the integrity of the bool data.\\n    /// @param ipStorage The instance of the IPAccountStorage contract.\\n    /// @param key The `ShortString` key whose bool value is to be retrieved.\\n    /// @return The bool value stored under the specified key.\\n    function getBool(IIPAccountStorage ipStorage, ShortString key) internal view returns (bool) {\\n        return getBool(ipStorage, toBytes32(key));\\n    }\\n\\n    /// @notice Retrieves a bool value from the storage under a specified namespace using a bytes32 key.\\n    /// @dev Retrieves the bool value from the specified namespace using the provided key.\\n    /// @param ipStorage The instance of the IPAccountStorage contract.\\n    /// @param namespace The namespace under which to retrieve the value.\\n    /// @param key The bytes32 key whose bool value is to be retrieved.\\n    /// @return The bool value stored under the specified key in the given namespace.\\n    function getBool(IIPAccountStorage ipStorage, address namespace, bytes32 key) internal view returns (bool) {\\n        return getBool(ipStorage, toBytes32(namespace), key);\\n    }\\n\\n    /// @notice Retrieves a bool value from the storage under a specified namespace using a `ShortString` key.\\n    /// @dev Retrieves the bool value from the specified namespace using the provided `ShortString` key.\\n    /// @param ipStorage The instance of the IPAccountStorage contract.\\n    /// @param namespace The namespace under which to retrieve the value.\\n    /// @param key The `ShortString` key whose bool value is to be retrieved.\\n    /// @return The bool value stored under the specified key in the given namespace.\\n    function getBool(IIPAccountStorage ipStorage, address namespace, ShortString key) internal view returns (bool) {\\n        return getBool(ipStorage, toBytes32(namespace), toBytes32(key));\\n    }\\n\\n    /// @notice Sets a bytes value in the storage using a `ShortString` key.\\n    /// @dev Converts the `ShortString` key to a `bytes32` representation before storing the value,\\n    /// facilitating bytes storage in a compact format.\\n    /// @param ipStorage The instance of the IPAccountStorage contract.\\n    /// @param key The `ShortString` key under which to store the bytes value.\\n    /// @param value The bytes value to be stored.\\n    function setBytes(IIPAccountStorage ipStorage, ShortString key, bytes memory value) internal {\\n        ipStorage.setBytes(toBytes32(key), value);\\n    }\\n\\n    /// @notice Sets a bytes value in the storage using two `ShortString` keys.\\n    /// @param ipStorage The instance of the IPAccountStorage contract.\\n    function setBytes(IIPAccountStorage ipStorage, ShortString key1, ShortString key2, bytes memory value) internal {\\n        ipStorage.setBytes(toBytes32(string(abi.encodePacked(key1.toString(), key2.toString()))), value);\\n    }\\n\\n    /// @notice Retrieves a bytes value from the storage using a `ShortString` key.\\n    /// @dev Converts the `ShortString` key to a `bytes32` representation before retrieving the value,\\n    /// ensuring the integrity of the bytes data.\\n    /// @param ipStorage The instance of the IPAccountStorage contract.\\n    /// @param key The `ShortString` key whose bytes value is to be retrieved.\\n    /// @return The bytes value stored under the specified key.\\n    function getBytes(IIPAccountStorage ipStorage, ShortString key) internal view returns (bytes memory) {\\n        return ipStorage.getBytes(toBytes32(key));\\n    }\\n\\n    /// @notice Retrieves a bytes value from the storage under a specified namespace using a bytes32 key.\\n    /// @dev Retrieves the bytes value from the specified namespace using the provided key.\\n    /// @param ipStorage The instance of the IPAccountStorage contract.\\n    /// @param namespace The namespace under which to retrieve the value.\\n    /// @param key The bytes32 key whose bytes value is to be retrieved.\\n    /// @return The bytes value stored under the specified key in the given namespace.\\n    function getBytes(\\n        IIPAccountStorage ipStorage,\\n        address namespace,\\n        bytes32 key\\n    ) internal view returns (bytes memory) {\\n        return ipStorage.getBytes(toBytes32(namespace), key);\\n    }\\n\\n    /// @notice Retrieves a bytes value from the storage under a specified namespace using a `ShortString` key.\\n    /// @dev Retrieves the bytes value from the specified namespace using the provided `ShortString` key.\\n    /// @param ipStorage The instance of the IPAccountStorage contract.\\n    /// @param namespace The namespace under which to retrieve the value.\\n    /// @param key The `ShortString` key whose bytes value is to be retrieved.\\n    /// @return The bytes value stored under the specified key in the given namespace.\\n    function getBytes(\\n        IIPAccountStorage ipStorage,\\n        address namespace,\\n        ShortString key\\n    ) internal view returns (bytes memory) {\\n        return ipStorage.getBytes(toBytes32(namespace), toBytes32(key));\\n    }\\n\\n    /// @notice Retrieves a bytes value from the storage using two `ShortString` keys.\\n    /// @param ipStorage The instance of the IPAccountStorage contract.\\n    /// @return The bytes value stored under the combination of two keys.\\n    function getBytes(\\n        IIPAccountStorage ipStorage,\\n        ShortString key1,\\n        ShortString key2\\n    ) internal view returns (bytes memory) {\\n        return ipStorage.getBytes(toBytes32(string(abi.encodePacked(key1.toString(), key2.toString()))));\\n    }\\n\\n    /// @notice Retrieves a bytes value from the storage under a specified namespace using two `ShortString` keys.\\n    /// @param ipStorage The instance of the IPAccountStorage contract.\\n    /// @param namespace The namespace under which to retrieve the value.\\n    /// @return The bytes value stored under the combination of two keys.\\n    function getBytes(\\n        IIPAccountStorage ipStorage,\\n        address namespace,\\n        ShortString key1,\\n        ShortString key2\\n    ) internal view returns (bytes memory) {\\n        return\\n            ipStorage.getBytes(\\n                toBytes32(namespace),\\n                toBytes32(string(abi.encodePacked(key1.toString(), key2.toString())))\\n            );\\n    }\\n\\n    /// @notice Sets a bytes32 value in the storage using a `ShortString` key.\\n    /// @dev Converts the `ShortString` key to a `bytes32` representation before storing the value,\\n    /// facilitating bytes32 storage in a compact format.\\n    /// @param ipStorage The instance of the IPAccountStorage contract.\\n    /// @param key The `ShortString` key under which to store the bytes32 value.\\n    /// @param value The bytes32 value to be stored.\\n    function setBytes32(IIPAccountStorage ipStorage, ShortString key, bytes32 value) internal {\\n        ipStorage.setBytes32(toBytes32(key), value);\\n    }\\n\\n    /// @notice Retrieves a bytes32 value from the storage using a `ShortString` key.\\n    /// @dev Converts the `ShortString` key to a `bytes32` representation before retrieving the value,\\n    /// ensuring the integrity of the bytes32 data.\\n    /// @param ipStorage The instance of the IPAccountStorage contract.\\n    /// @param key The `ShortString` key whose bytes32 value is to be retrieved.\\n    /// @return The bytes32 value stored under the specified key.\\n    function getBytes32(IIPAccountStorage ipStorage, ShortString key) internal view returns (bytes32) {\\n        return ipStorage.getBytes32(toBytes32(key));\\n    }\\n\\n    /// @notice Retrieves a bytes32 value from the storage under a specified namespace using a bytes32 key.\\n    /// @dev Retrieves the bytes32 value from the specified namespace using the provided key.\\n    /// @param ipStorage The instance of the IPAccountStorage contract.\\n    /// @param namespace The namespace under which to retrieve the value.\\n    /// @param key The bytes32 key whose bytes32 value is to be retrieved.\\n    /// @return The bytes32 value stored under the specified key in the given namespace.\\n    function getBytes32(IIPAccountStorage ipStorage, address namespace, bytes32 key) internal view returns (bytes32) {\\n        return ipStorage.getBytes32(toBytes32(namespace), key);\\n    }\\n\\n    /// @notice Retrieves a bytes32 value from the storage under a specified namespace using a `ShortString` key.\\n    /// @dev Retrieves the bytes32 value from the specified namespace using the provided `ShortString` key.\\n    /// @param ipStorage The instance of the IPAccountStorage contract.\\n    /// @param namespace The namespace under which to retrieve the value.\\n    /// @param key The `ShortString` key whose bytes32 value is to be retrieved.\\n    /// @return The bytes32 value stored under the specified key in the given namespace.\\n    function getBytes32(\\n        IIPAccountStorage ipStorage,\\n        address namespace,\\n        ShortString key\\n    ) internal view returns (bytes32) {\\n        return ipStorage.getBytes32(toBytes32(namespace), toBytes32(key));\\n    }\\n\\n    function toBytes32(string memory s) internal pure returns (bytes32) {\\n        return ShortString.unwrap(s.toShortString());\\n    }\\n\\n    function toBytes32(address a) internal pure returns (bytes32) {\\n        return bytes32(uint256(uint160(a)));\\n    }\\n\\n    function toBytes32(ShortString sstr) internal pure returns (bytes32) {\\n        // remove the length byte from the ShortString\\n        // so that bytes32 result is identical with converting string to bytes32 directly\\n        return ShortString.unwrap(sstr) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00;\\n    }\\n}\\n\",\"keccak256\":\"0xa40b7affdb0fde9625b1499d1e8bb9c59969efa471dabd03df398ab7bd13811e\",\"license\":\"UNLICENSED\"},\"@story-protocol/protocol-core/contracts/pause/ProtocolPausableUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.23;\\n\\n// solhint-disable-next-line max-line-length\\nimport { AccessManagedUpgradeable } from \\\"@openzeppelin/contracts-upgradeable/access/manager/AccessManagedUpgradeable.sol\\\";\\nimport { PausableUpgradeable } from \\\"@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol\\\";\\n\\n/// @title ProtocolPausable\\n/// @notice Contract that allows the pausing and unpausing of the a contract\\nabstract contract ProtocolPausableUpgradeable is PausableUpgradeable, AccessManagedUpgradeable {\\n    /// @notice Initializes the ProtocolPausable contract\\n    /// @param accessManager The address of the access manager\\n    function __ProtocolPausable_init(address accessManager) public initializer {\\n        __AccessManaged_init(accessManager);\\n        __Pausable_init();\\n    }\\n\\n    /// @notice sets paused state\\n    function pause() external restricted {\\n        _pause();\\n    }\\n\\n    /// @notice unsets unpaused state\\n    function unpause() external restricted {\\n        _unpause();\\n    }\\n\\n    function paused() public view override returns (bool) {\\n        return super.paused();\\n    }\\n}\\n\",\"keccak256\":\"0xe64a943bb675099a400a4dc5fde76a982e1c14b46fe00c0ea55f8b325a24f7af\",\"license\":\"BUSL-1.1\"},\"@story-protocol/protocol-core/contracts/registries/IPAccountRegistry.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.23;\\n\\nimport { IERC6551Registry } from \\\"erc6551/interfaces/IERC6551Registry.sol\\\";\\n\\nimport { IIPAccountRegistry } from \\\"../interfaces/registries/IIPAccountRegistry.sol\\\";\\nimport { Errors } from \\\"../lib/Errors.sol\\\";\\n\\n/// @title IPAccountRegistry\\n/// @notice This contract is responsible for managing the registration and tracking of IP Accounts.\\n/// It leverages a public ERC6551 registry to deploy IPAccount contracts.\\nabstract contract IPAccountRegistry is IIPAccountRegistry {\\n    /// @notice Returns the IPAccount implementation address\\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\\n    address public immutable IP_ACCOUNT_IMPL;\\n\\n    /// @notice Returns the IPAccount salt\\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\\n    bytes32 public immutable IP_ACCOUNT_SALT;\\n\\n    /// @notice Returns the public ERC6551 registry address\\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\\n    address public immutable ERC6551_PUBLIC_REGISTRY;\\n\\n    /// @custom:oz-upgrades-unsafe-allow constructor\\n    constructor(address erc6551Registry, address ipAccountImpl) {\\n        if (ipAccountImpl == address(0)) revert Errors.IPAccountRegistry_ZeroIpAccountImpl();\\n        IP_ACCOUNT_IMPL = ipAccountImpl;\\n        IP_ACCOUNT_SALT = bytes32(0);\\n        ERC6551_PUBLIC_REGISTRY = erc6551Registry;\\n    }\\n\\n    /// @notice Deploys an IPAccount contract with the IPAccount implementation and returns the address of the new IP\\n    /// @dev The IPAccount deployment deltegates to public ERC6551 Registry\\n    /// @param chainId The chain ID where the IP Account will be created\\n    /// @param tokenContract The address of the token contract to be associated with the IP Account\\n    /// @param tokenId The ID of the token to be associated with the IP Account\\n    /// @return ipAccountAddress The address of the newly created IP Account\\n    function registerIpAccount(\\n        uint256 chainId,\\n        address tokenContract,\\n        uint256 tokenId\\n    ) public returns (address ipAccountAddress) {\\n        ipAccountAddress = IERC6551Registry(ERC6551_PUBLIC_REGISTRY).createAccount(\\n            IP_ACCOUNT_IMPL,\\n            IP_ACCOUNT_SALT,\\n            chainId,\\n            tokenContract,\\n            tokenId\\n        );\\n        emit IPAccountRegistered(ipAccountAddress, IP_ACCOUNT_IMPL, chainId, tokenContract, tokenId);\\n    }\\n\\n    /// @notice Returns the IPAccount address for the given NFT token.\\n    /// @param chainId The chain ID where the IP Account is located\\n    /// @param tokenContract The address of the token contract associated with the IP Account\\n    /// @param tokenId The ID of the token associated with the IP Account\\n    /// @return ipAccountAddress The address of the IP Account associated with the given NFT token\\n    function ipAccount(uint256 chainId, address tokenContract, uint256 tokenId) public view returns (address) {\\n        return _get6551AccountAddress(chainId, tokenContract, tokenId);\\n    }\\n\\n    /// @notice Returns the IPAccount implementation address.\\n    /// @return The address of the IPAccount implementation\\n    function getIPAccountImpl() external view override returns (address) {\\n        return IP_ACCOUNT_IMPL;\\n    }\\n\\n    /// @dev Helper function to get the IPAccount address from the ERC6551 registry.\\n    function _get6551AccountAddress(\\n        uint256 chainId,\\n        address tokenContract,\\n        uint256 tokenId\\n    ) internal view returns (address) {\\n        return\\n            IERC6551Registry(ERC6551_PUBLIC_REGISTRY).account(\\n                IP_ACCOUNT_IMPL,\\n                IP_ACCOUNT_SALT,\\n                chainId,\\n                tokenContract,\\n                tokenId\\n            );\\n    }\\n}\\n\",\"keccak256\":\"0x3209e4d1f64f4c9172a17137321db796665d6345223b972ac25f7412e11b3eae\",\"license\":\"BUSL-1.1\"},\"@story-protocol/protocol-core/contracts/registries/IPAssetRegistry.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.23;\\n\\nimport { IERC721 } from \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\nimport { IERC721Metadata } from \\\"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\\\";\\nimport { ERC165Checker } from \\\"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\\\";\\nimport { Strings } from \\\"@openzeppelin/contracts/utils/Strings.sol\\\";\\nimport { UUPSUpgradeable } from \\\"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\\\";\\n\\nimport { IIPAccount } from \\\"../interfaces/IIPAccount.sol\\\";\\nimport { IIPAssetRegistry } from \\\"../interfaces/registries/IIPAssetRegistry.sol\\\";\\nimport { ProtocolPausableUpgradeable } from \\\"../pause/ProtocolPausableUpgradeable.sol\\\";\\nimport { IPAccountRegistry } from \\\"../registries/IPAccountRegistry.sol\\\";\\nimport { Errors } from \\\"../lib/Errors.sol\\\";\\nimport { IPAccountStorageOps } from \\\"../lib/IPAccountStorageOps.sol\\\";\\n\\n/// @title IP Asset Registry\\n/// @notice This contract acts as the source of truth for all IP registered in\\n///         Story Protocol. An IP is identified by its contract address, token\\n///         id, and coin type, meaning any NFT may be conceptualized as an IP.\\n///         Once an IP is registered into the protocol, a corresponding IP\\n///         asset is generated, which references an IP resolver for metadata\\n///         attribution and an IP account for protocol authorization.\\n///         IMPORTANT: The IP account address, besides being used for protocol\\n///                    auth, is also the canonical IP identifier for the IP NFT.\\ncontract IPAssetRegistry is IIPAssetRegistry, IPAccountRegistry, ProtocolPausableUpgradeable, UUPSUpgradeable {\\n    using ERC165Checker for address;\\n    using Strings for *;\\n    using IPAccountStorageOps for IIPAccount;\\n\\n    /// @dev Storage structure for the IPAssetRegistry\\n    /// @notice Tracks the total number of IP assets in existence.\\n    /// @custom:storage-location erc7201:story-protocol.IPAssetRegistry\\n    struct IPAssetRegistryStorage {\\n        uint256 totalSupply;\\n    }\\n\\n    // keccak256(abi.encode(uint256(keccak256(\\\"story-protocol.IPAssetRegistry\\\")) - 1)) & ~bytes32(uint256(0xff));\\n    bytes32 private constant IPAssetRegistryStorageLocation =\\n        0x987c61809af5a42943abd137c7acff8426aab6f7a1f5c967a03d1d718ba5cf00;\\n\\n    /// @custom:oz-upgrades-unsafe-allow constructor\\n    constructor(address erc6551Registry, address ipAccountImpl) IPAccountRegistry(erc6551Registry, ipAccountImpl) {\\n        _disableInitializers();\\n    }\\n\\n    /// @notice Initializes the IPAssetRegistry contract.\\n    /// @param accessManager The address of the access manager.\\n    function initialize(address accessManager) public initializer {\\n        if (accessManager == address(0)) {\\n            revert Errors.IPAssetRegistry__ZeroAccessManager();\\n        }\\n        __ProtocolPausable_init(accessManager);\\n        __UUPSUpgradeable_init();\\n    }\\n\\n    /// @notice Registers an NFT as an IP asset.\\n    /// @dev The IP required metadata name and URI are derived from the NFT's metadata.\\n    /// @param chainid The chain identifier of where the IP NFT resides.\\n    /// @param tokenContract The address of the NFT.\\n    /// @param tokenId The token identifier of the NFT.\\n    /// @return id The address of the newly registered IP.\\n    function register(\\n        uint256 chainid,\\n        address tokenContract,\\n        uint256 tokenId\\n    ) external whenNotPaused returns (address id) {\\n        id = registerIpAccount(chainid, tokenContract, tokenId);\\n        IIPAccount ipAccount = IIPAccount(payable(id));\\n\\n        if (bytes(ipAccount.getString(\\\"NAME\\\")).length != 0) {\\n            revert Errors.IPAssetRegistry__AlreadyRegistered();\\n        }\\n\\n        (string memory name, string memory uri) = _getNameAndUri(chainid, tokenContract, tokenId);\\n        uint256 registrationDate = block.timestamp;\\n        ipAccount.setString(\\\"NAME\\\", name);\\n        ipAccount.setString(\\\"URI\\\", uri);\\n        ipAccount.setUint256(\\\"REGISTRATION_DATE\\\", registrationDate);\\n\\n        _getIPAssetRegistryStorage().totalSupply++;\\n\\n        emit IPRegistered(id, chainid, tokenContract, tokenId, name, uri, registrationDate);\\n    }\\n\\n    /// @notice Gets the canonical IP identifier associated with an IP NFT.\\n    /// @dev This is equivalent to the address of its bound IP account.\\n    /// @param chainId The chain identifier of where the IP resides.\\n    /// @param tokenContract The address of the IP.\\n    /// @param tokenId The token identifier of the IP.\\n    /// @return ipId The IP's canonical address identifier.\\n    function ipId(uint256 chainId, address tokenContract, uint256 tokenId) public view returns (address) {\\n        return super.ipAccount(chainId, tokenContract, tokenId);\\n    }\\n\\n    /// @notice Checks whether an IP was registered based on its ID.\\n    /// @param id The canonical identifier for the IP.\\n    /// @return isRegistered Whether the IP was registered into the protocol.\\n    function isRegistered(address id) external view returns (bool) {\\n        if (id == address(0)) return false;\\n        if (id.code.length == 0) return false;\\n        if (!ERC165Checker.supportsInterface(id, type(IIPAccount).interfaceId)) return false;\\n        (uint chainId, address tokenContract, uint tokenId) = IIPAccount(payable(id)).token();\\n        if (id != ipAccount(chainId, tokenContract, tokenId)) return false;\\n        return bytes(IIPAccount(payable(id)).getString(\\\"NAME\\\")).length != 0;\\n    }\\n\\n    /// @notice Gets the total number of IP assets registered in the protocol.\\n    function totalSupply() external view returns (uint256) {\\n        return _getIPAssetRegistryStorage().totalSupply;\\n    }\\n\\n    /// @dev Retrieves the name and URI of from IP NFT.\\n    function _getNameAndUri(\\n        uint256 chainid,\\n        address tokenContract,\\n        uint256 tokenId\\n    ) internal view returns (string memory name, string memory uri) {\\n        if (chainid != block.chainid) {\\n            name = string.concat(chainid.toString(), \\\": \\\", tokenContract.toHexString(), \\\" #\\\", tokenId.toString());\\n            uri = \\\"\\\";\\n            return (name, uri);\\n        }\\n        // Handle NFT on the same chain\\n        if (!tokenContract.supportsInterface(type(IERC721).interfaceId)) {\\n            revert Errors.IPAssetRegistry__UnsupportedIERC721(tokenContract);\\n        }\\n\\n        if (IERC721(tokenContract).ownerOf(tokenId) == address(0)) {\\n            revert Errors.IPAssetRegistry__InvalidToken(tokenContract, tokenId);\\n        }\\n\\n        if (!tokenContract.supportsInterface(type(IERC721Metadata).interfaceId)) {\\n            revert Errors.IPAssetRegistry__UnsupportedIERC721Metadata(tokenContract);\\n        }\\n\\n        name = string.concat(\\n            block.chainid.toString(),\\n            \\\": \\\",\\n            IERC721Metadata(tokenContract).name(),\\n            \\\" #\\\",\\n            tokenId.toString()\\n        );\\n        uri = IERC721Metadata(tokenContract).tokenURI(tokenId);\\n    }\\n\\n    /// @dev Hook to authorize the upgrade according to UUPSUpgradeable\\n    /// @param newImplementation The address of the new implementation\\n    function _authorizeUpgrade(address newImplementation) internal override restricted {}\\n\\n    /// @dev Returns the storage struct of IPAssetRegistry.\\n    function _getIPAssetRegistryStorage() private pure returns (IPAssetRegistryStorage storage $) {\\n        assembly {\\n            $.slot := IPAssetRegistryStorageLocation\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x0fce7ee6028cc9e750cd2c3eda20676c2aa564a3c281ffa583cfcabc45eea2b7\",\"license\":\"BUSL-1.1\"},\"contracts/shares/bodhi.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\nimport {ERC1155} from \\\"solmate/src/tokens/ERC1155.sol\\\";\\nimport \\\"@story-protocol/protocol-core/contracts/registries/IPAssetRegistry.sol\\\";\\n//6909 need to check\\nimport \\\"hardhat/console.sol\\\";\\n\\nerror Unauthorized();\\n\\ncontract Bodhi is ERC1155 {\\n    event Create(\\n        uint256 indexed assetId,\\n        address indexed sender,\\n        string arTxId\\n    );\\n    event Remove(uint256 indexed assetId, address indexed sender);\\n    event Trade(\\n        TradeType indexed tradeType,\\n        uint256 indexed assetId,\\n        address indexed sender,\\n        uint256 tokenAmount,\\n        uint256 ethAmount,\\n        uint256 creatorFee\\n    );\\n\\n    event ChapterCreated(address indexed sender, address indexed ipId);\\n\\n    struct Asset {\\n        uint256 id;\\n        string arTxId; // arweave transaction id\\n        address creator;\\n    }\\n\\n    IPAssetRegistry public immutable REGISTRY_MODULE;\\n\\n    uint256 public assetIndex;\\n\\n    address immutable owner;\\n\\n    mapping(uint256 => Asset) public assets;\\n    mapping(address => uint256[]) public userAssets;\\n    mapping(bytes32 => uint256) public txToAssetId;\\n    mapping(uint256 => uint256) public totalSupply;\\n    mapping(uint256 => uint256) public pool;\\n\\n    uint256 public constant CREATOR_PREMINT = 1 ether; // 1e18\\n    uint256 public constant CREATOR_FEE_PERCENT = 0.05 ether; // 5%\\n\\n    enum TradeType {\\n        Mint,\\n        Buy,\\n        Sell\\n    } // = 0, 1, 2\\n\\n    constructor(address _registry) {\\n        REGISTRY_MODULE = IPAssetRegistry(_registry);\\n    }\\n\\n    // Bodhi Contract Functions\\n\\n    function create(string calldata arTxId) internal returns (uint256) {\\n        bytes32 txHash = keccak256(abi.encodePacked(arTxId));\\n        require(txToAssetId[txHash] == 0, \\\"Asset already exists\\\");\\n        uint256 newAssetId = assetIndex;\\n        assets[newAssetId] = Asset(newAssetId, arTxId, msg.sender);\\n        userAssets[msg.sender].push(newAssetId);\\n        txToAssetId[txHash] = newAssetId;\\n        totalSupply[newAssetId] += CREATOR_PREMINT;\\n        assetIndex = newAssetId + 1;\\n        _mint(msg.sender, newAssetId, CREATOR_PREMINT, \\\"\\\");\\n        emit Create(newAssetId, msg.sender, arTxId);\\n        emit Trade(\\n            TradeType.Mint,\\n            newAssetId,\\n            msg.sender,\\n            CREATOR_PREMINT,\\n            0,\\n            0\\n        );\\n        return assetIndex;\\n    }\\n\\n    function remove(uint256 assetId) public {\\n        Asset memory asset = assets[assetId];\\n        if (asset.creator != msg.sender) {\\n            revert Unauthorized();\\n        }\\n        delete txToAssetId[keccak256(abi.encodePacked(asset.arTxId))];\\n        delete assets[assetId];\\n        emit Remove(assetId, msg.sender);\\n    }\\n\\n    function getAssetIdsByAddress(\\n        address addr\\n    ) public view returns (uint256[] memory) {\\n        return userAssets[addr];\\n    }\\n\\n    function checkIfUserHasShares(\\n        address user,\\n        uint256 assetId\\n    ) public view returns (bool) {\\n        return balanceOf[user][assetId] > 5;\\n    }\\n\\n    function _curve(uint256 x) private pure returns (uint256) {\\n        return\\n            x <= CREATOR_PREMINT\\n                ? 0\\n                : ((x - CREATOR_PREMINT) *\\n                    (x - CREATOR_PREMINT) *\\n                    (x - CREATOR_PREMINT));\\n    }\\n\\n    function getPrice(\\n        uint256 supply,\\n        uint256 amount\\n    ) public pure returns (uint256) {\\n        return\\n            (_curve(supply + amount) - _curve(supply)) /\\n            1 ether /\\n            1 ether /\\n            50_000;\\n    }\\n\\n    function getBuyPrice(\\n        uint256 assetId,\\n        uint256 amount\\n    ) public view returns (uint256) {\\n        return getPrice(totalSupply[assetId], amount);\\n    }\\n\\n    function getSellPrice(\\n        uint256 assetId,\\n        uint256 amount\\n    ) public view returns (uint256) {\\n        return getPrice(totalSupply[assetId] - amount, amount);\\n    }\\n\\n    function getBuyPriceAfterFee(\\n        uint256 assetId,\\n        uint256 amount\\n    ) public view returns (uint256) {\\n        uint256 price = getBuyPrice(assetId, amount);\\n        uint256 creatorFee = (price * CREATOR_FEE_PERCENT) / 1 ether;\\n        return price + creatorFee;\\n    }\\n\\n    function getSellPriceAfterFee(\\n        uint256 assetId,\\n        uint256 amount\\n    ) public view returns (uint256) {\\n        uint256 price = getSellPrice(assetId, amount);\\n        uint256 creatorFee = (price * CREATOR_FEE_PERCENT) / 1 ether;\\n        return price - creatorFee;\\n    }\\n\\n    function buy(uint256 assetId, uint256 amount) public payable {\\n        require(assetId < assetIndex, \\\"Asset does not exist\\\");\\n        uint256 price = getBuyPrice(assetId, amount);\\n        uint256 creatorFee = (price * CREATOR_FEE_PERCENT) / 1 ether;\\n        require(msg.value >= price + creatorFee, \\\"Insufficient payment\\\");\\n        totalSupply[assetId] += amount;\\n        pool[assetId] += price;\\n        _mint(msg.sender, assetId, amount, \\\"\\\");\\n        emit Trade(\\n            TradeType.Buy,\\n            assetId,\\n            msg.sender,\\n            amount,\\n            price,\\n            creatorFee\\n        );\\n        (bool creatorFeeSent, ) = payable(assets[assetId].creator).call{\\n            value: creatorFee\\n        }(\\\"\\\");\\n        require(creatorFeeSent, \\\"Failed to send Ether\\\");\\n    }\\n\\n    function sell(uint256 assetId, uint256 amount) public {\\n        require(assetId < assetIndex, \\\"Asset does not exist\\\");\\n        require(\\n            balanceOf[msg.sender][assetId] >= amount,\\n            \\\"Insufficient balance\\\"\\n        );\\n        uint256 supply = totalSupply[assetId];\\n        require(\\n            supply - amount >= CREATOR_PREMINT,\\n            \\\"Supply not allowed below premint amount\\\"\\n        );\\n        uint256 price = getSellPrice(assetId, amount);\\n        uint256 creatorFee = (price * CREATOR_FEE_PERCENT) / 1 ether;\\n        _burn(msg.sender, assetId, amount);\\n        totalSupply[assetId] = supply - amount;\\n        pool[assetId] -= price;\\n        emit Trade(\\n            TradeType.Sell,\\n            assetId,\\n            msg.sender,\\n            amount,\\n            price,\\n            creatorFee\\n        );\\n        (bool sent, ) = payable(msg.sender).call{value: price - creatorFee}(\\\"\\\");\\n        (bool creatorFeeSent, ) = payable(assets[assetId].creator).call{\\n            value: creatorFee\\n        }(\\\"\\\");\\n        require(sent && creatorFeeSent, \\\"Failed to send Ether\\\");\\n    }\\n\\n    function uri(uint256 id) public view override returns (string memory) {\\n        return assets[id].arTxId;\\n    }\\n\\n    // Story Protocol Functions\\n\\n    function _registorIPAccount(uint256 assetId) internal returns (address) {\\n        address ipId = REGISTRY_MODULE.register(\\n            block.chainid,\\n            address(this),\\n            assetId\\n        );\\n        return ipId;\\n    }\\n\\n    // function _registerPILTerms(\\n    //     address ipId,\\n    //     PILTerms calldata template\\n    // ) internal returns (address) {\\n    //     licenseTerms = PIL_TEMPLATE.registerLicenseTerms(terms);\\n\\n    //     if (\\n    //         LICENSE_REGISTRY.hasIpAttachedLicenseTerms(\\n    //             ipId,\\n    //             address(PIL_TEMPLATE),\\n    //             licenseTermsId\\n    //         )\\n    //     ) return licenseTermsId;\\n\\n    //     LICENSING_MODULE.attachLicenseTerms(\\n    //         ipId,\\n    //         address(PIL_TEMPLATE),\\n    //         licenseTermsId\\n    //     );\\n    // }\\n\\n    // Public Functions\\n\\n    function createChapter(\\n        string calldata arTxId // PILTerms calldata terms\\n    ) external returns (address) {\\n        uint256 assetId = create(arTxId);\\n        address ipId = _registorIPAccount(assetId);\\n        // _registerPILTerms(ipId, PILTerms(arTxId));\\n        return ipId;\\n    }\\n}\\n\",\"keccak256\":\"0xbd96a7d6618bcde498727d010351135a0bfd41f658c353aa68bbced0f8a1ef9a\",\"license\":\"MIT\"},\"erc6551/interfaces/IERC6551Account.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/// @dev the ERC-165 identifier for this interface is `0x6faff5f1`\\ninterface IERC6551Account {\\n    /**\\n     * @dev Allows the account to receive Ether.\\n     *\\n     * Accounts MUST implement a `receive` function.\\n     *\\n     * Accounts MAY perform arbitrary logic to restrict conditions\\n     * under which Ether can be received.\\n     */\\n    receive() external payable;\\n\\n    /**\\n     * @dev Returns the identifier of the non-fungible token which owns the account.\\n     *\\n     * The return value of this function MUST be constant - it MUST NOT change over time.\\n     *\\n     * @return chainId       The EIP-155 ID of the chain the token exists on\\n     * @return tokenContract The contract address of the token\\n     * @return tokenId       The ID of the token\\n     */\\n    function token()\\n        external\\n        view\\n        returns (uint256 chainId, address tokenContract, uint256 tokenId);\\n\\n    /**\\n     * @dev Returns a value that SHOULD be modified each time the account changes state.\\n     *\\n     * @return The current account state\\n     */\\n    function state() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns a magic value indicating whether a given signer is authorized to act on behalf\\n     * of the account.\\n     *\\n     * MUST return the bytes4 magic value 0x523e3260 if the given signer is valid.\\n     *\\n     * By default, the holder of the non-fungible token the account is bound to MUST be considered\\n     * a valid signer.\\n     *\\n     * Accounts MAY implement additional authorization logic which invalidates the holder as a\\n     * signer or grants signing permissions to other non-holder accounts.\\n     *\\n     * @param  signer     The address to check signing authorization for\\n     * @param  context    Additional data used to determine whether the signer is valid\\n     * @return magicValue Magic value indicating whether the signer is valid\\n     */\\n    function isValidSigner(address signer, bytes calldata context)\\n        external\\n        view\\n        returns (bytes4 magicValue);\\n}\\n\",\"keccak256\":\"0xda097894cc052f451ad669c5a07a9eda3f53a948f8080714850dc68cc1040b42\",\"license\":\"MIT\"},\"erc6551/interfaces/IERC6551Registry.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IERC6551Registry {\\n    /**\\n     * @dev The registry MUST emit the ERC6551AccountCreated event upon successful account creation.\\n     */\\n    event ERC6551AccountCreated(\\n        address account,\\n        address indexed implementation,\\n        bytes32 salt,\\n        uint256 chainId,\\n        address indexed tokenContract,\\n        uint256 indexed tokenId\\n    );\\n\\n    /**\\n     * @dev The registry MUST revert with AccountCreationFailed error if the create2 operation fails.\\n     */\\n    error AccountCreationFailed();\\n\\n    /**\\n     * @dev Creates a token bound account for a non-fungible token.\\n     *\\n     * If account has already been created, returns the account address without calling create2.\\n     *\\n     * Emits ERC6551AccountCreated event.\\n     *\\n     * @return account The address of the token bound account\\n     */\\n    function createAccount(\\n        address implementation,\\n        bytes32 salt,\\n        uint256 chainId,\\n        address tokenContract,\\n        uint256 tokenId\\n    ) external returns (address account);\\n\\n    /**\\n     * @dev Returns the computed token bound account address for a non-fungible token.\\n     *\\n     * @return account The address of the token bound account\\n     */\\n    function account(\\n        address implementation,\\n        bytes32 salt,\\n        uint256 chainId,\\n        address tokenContract,\\n        uint256 tokenId\\n    ) external view returns (address account);\\n}\\n\",\"keccak256\":\"0x871be5b51883d915c0b871cb0baf7bbddd41a2b2e42ae109b922c6418ee7141b\",\"license\":\"MIT\"},\"hardhat/console.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.4.22 <0.9.0;\\n\\nlibrary console {\\n    address constant CONSOLE_ADDRESS =\\n        0x000000000000000000636F6e736F6c652e6c6f67;\\n\\n    function _sendLogPayloadImplementation(bytes memory payload) internal view {\\n        address consoleAddress = CONSOLE_ADDRESS;\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            pop(\\n                staticcall(\\n                    gas(),\\n                    consoleAddress,\\n                    add(payload, 32),\\n                    mload(payload),\\n                    0,\\n                    0\\n                )\\n            )\\n        }\\n    }\\n\\n    function _castToPure(\\n      function(bytes memory) internal view fnIn\\n    ) internal pure returns (function(bytes memory) pure fnOut) {\\n        assembly {\\n            fnOut := fnIn\\n        }\\n    }\\n\\n    function _sendLogPayload(bytes memory payload) internal pure {\\n        _castToPure(_sendLogPayloadImplementation)(payload);\\n    }\\n\\n    function log() internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log()\\\"));\\n    }\\n    function logInt(int256 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(int256)\\\", p0));\\n    }\\n\\n    function logUint(uint256 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256)\\\", p0));\\n    }\\n\\n    function logString(string memory p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n    }\\n\\n    function logBool(bool p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n    }\\n\\n    function logAddress(address p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n    }\\n\\n    function logBytes(bytes memory p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes)\\\", p0));\\n    }\\n\\n    function logBytes1(bytes1 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes1)\\\", p0));\\n    }\\n\\n    function logBytes2(bytes2 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes2)\\\", p0));\\n    }\\n\\n    function logBytes3(bytes3 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes3)\\\", p0));\\n    }\\n\\n    function logBytes4(bytes4 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes4)\\\", p0));\\n    }\\n\\n    function logBytes5(bytes5 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes5)\\\", p0));\\n    }\\n\\n    function logBytes6(bytes6 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes6)\\\", p0));\\n    }\\n\\n    function logBytes7(bytes7 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes7)\\\", p0));\\n    }\\n\\n    function logBytes8(bytes8 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes8)\\\", p0));\\n    }\\n\\n    function logBytes9(bytes9 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes9)\\\", p0));\\n    }\\n\\n    function logBytes10(bytes10 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes10)\\\", p0));\\n    }\\n\\n    function logBytes11(bytes11 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes11)\\\", p0));\\n    }\\n\\n    function logBytes12(bytes12 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes12)\\\", p0));\\n    }\\n\\n    function logBytes13(bytes13 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes13)\\\", p0));\\n    }\\n\\n    function logBytes14(bytes14 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes14)\\\", p0));\\n    }\\n\\n    function logBytes15(bytes15 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes15)\\\", p0));\\n    }\\n\\n    function logBytes16(bytes16 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes16)\\\", p0));\\n    }\\n\\n    function logBytes17(bytes17 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes17)\\\", p0));\\n    }\\n\\n    function logBytes18(bytes18 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes18)\\\", p0));\\n    }\\n\\n    function logBytes19(bytes19 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes19)\\\", p0));\\n    }\\n\\n    function logBytes20(bytes20 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes20)\\\", p0));\\n    }\\n\\n    function logBytes21(bytes21 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes21)\\\", p0));\\n    }\\n\\n    function logBytes22(bytes22 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes22)\\\", p0));\\n    }\\n\\n    function logBytes23(bytes23 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes23)\\\", p0));\\n    }\\n\\n    function logBytes24(bytes24 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes24)\\\", p0));\\n    }\\n\\n    function logBytes25(bytes25 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes25)\\\", p0));\\n    }\\n\\n    function logBytes26(bytes26 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes26)\\\", p0));\\n    }\\n\\n    function logBytes27(bytes27 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes27)\\\", p0));\\n    }\\n\\n    function logBytes28(bytes28 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes28)\\\", p0));\\n    }\\n\\n    function logBytes29(bytes29 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes29)\\\", p0));\\n    }\\n\\n    function logBytes30(bytes30 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes30)\\\", p0));\\n    }\\n\\n    function logBytes31(bytes31 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes31)\\\", p0));\\n    }\\n\\n    function logBytes32(bytes32 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes32)\\\", p0));\\n    }\\n\\n    function log(uint256 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256)\\\", p0));\\n    }\\n\\n    function log(string memory p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n    }\\n\\n    function log(bool p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n    }\\n\\n    function log(address p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n    }\\n\\n    function log(uint256 p0, uint256 p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256)\\\", p0, p1));\\n    }\\n\\n    function log(uint256 p0, string memory p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string)\\\", p0, p1));\\n    }\\n\\n    function log(uint256 p0, bool p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool)\\\", p0, p1));\\n    }\\n\\n    function log(uint256 p0, address p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, uint256 p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, string memory p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, bool p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, address p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, uint256 p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, string memory p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, bool p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, address p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, uint256 p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, string memory p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, bool p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, address p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address)\\\", p0, p1));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n}\\n\",\"keccak256\":\"0x7434453e6d3b7d0e5d0eb7846ffdbc27f0ccf3b163591263739b628074dc103a\",\"license\":\"MIT\"},\"solmate/src/tokens/ERC1155.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Minimalist and gas efficient standard ERC1155 implementation.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC1155.sol)\\nabstract contract ERC1155 {\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event TransferSingle(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256 id,\\n        uint256 amount\\n    );\\n\\n    event TransferBatch(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256[] ids,\\n        uint256[] amounts\\n    );\\n\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    event URI(string value, uint256 indexed id);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                             ERC1155 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    mapping(address => mapping(uint256 => uint256)) public balanceOf;\\n\\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                             METADATA LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function uri(uint256 id) public view virtual returns (string memory);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC1155 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function setApprovalForAll(address operator, bool approved) public virtual {\\n        isApprovedForAll[msg.sender][operator] = approved;\\n\\n        emit ApprovalForAll(msg.sender, operator, approved);\\n    }\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes calldata data\\n    ) public virtual {\\n        require(msg.sender == from || isApprovedForAll[from][msg.sender], \\\"NOT_AUTHORIZED\\\");\\n\\n        balanceOf[from][id] -= amount;\\n        balanceOf[to][id] += amount;\\n\\n        emit TransferSingle(msg.sender, from, to, id, amount);\\n\\n        require(\\n            to.code.length == 0\\n                ? to != address(0)\\n                : ERC1155TokenReceiver(to).onERC1155Received(msg.sender, from, id, amount, data) ==\\n                    ERC1155TokenReceiver.onERC1155Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts,\\n        bytes calldata data\\n    ) public virtual {\\n        require(ids.length == amounts.length, \\\"LENGTH_MISMATCH\\\");\\n\\n        require(msg.sender == from || isApprovedForAll[from][msg.sender], \\\"NOT_AUTHORIZED\\\");\\n\\n        // Storing these outside the loop saves ~15 gas per iteration.\\n        uint256 id;\\n        uint256 amount;\\n\\n        for (uint256 i = 0; i < ids.length; ) {\\n            id = ids[i];\\n            amount = amounts[i];\\n\\n            balanceOf[from][id] -= amount;\\n            balanceOf[to][id] += amount;\\n\\n            // An array can't have a total length\\n            // larger than the max uint256 value.\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        emit TransferBatch(msg.sender, from, to, ids, amounts);\\n\\n        require(\\n            to.code.length == 0\\n                ? to != address(0)\\n                : ERC1155TokenReceiver(to).onERC1155BatchReceived(msg.sender, from, ids, amounts, data) ==\\n                    ERC1155TokenReceiver.onERC1155BatchReceived.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    function balanceOfBatch(address[] calldata owners, uint256[] calldata ids)\\n        public\\n        view\\n        virtual\\n        returns (uint256[] memory balances)\\n    {\\n        require(owners.length == ids.length, \\\"LENGTH_MISMATCH\\\");\\n\\n        balances = new uint256[](owners.length);\\n\\n        // Unchecked because the only math done is incrementing\\n        // the array index counter which cannot possibly overflow.\\n        unchecked {\\n            for (uint256 i = 0; i < owners.length; ++i) {\\n                balances[i] = balanceOf[owners[i]][ids[i]];\\n            }\\n        }\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC165 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\\n        return\\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\\n            interfaceId == 0xd9b67a26 || // ERC165 Interface ID for ERC1155\\n            interfaceId == 0x0e89341c; // ERC165 Interface ID for ERC1155MetadataURI\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes memory data\\n    ) internal virtual {\\n        balanceOf[to][id] += amount;\\n\\n        emit TransferSingle(msg.sender, address(0), to, id, amount);\\n\\n        require(\\n            to.code.length == 0\\n                ? to != address(0)\\n                : ERC1155TokenReceiver(to).onERC1155Received(msg.sender, address(0), id, amount, data) ==\\n                    ERC1155TokenReceiver.onERC1155Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    function _batchMint(\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) internal virtual {\\n        uint256 idsLength = ids.length; // Saves MLOADs.\\n\\n        require(idsLength == amounts.length, \\\"LENGTH_MISMATCH\\\");\\n\\n        for (uint256 i = 0; i < idsLength; ) {\\n            balanceOf[to][ids[i]] += amounts[i];\\n\\n            // An array can't have a total length\\n            // larger than the max uint256 value.\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        emit TransferBatch(msg.sender, address(0), to, ids, amounts);\\n\\n        require(\\n            to.code.length == 0\\n                ? to != address(0)\\n                : ERC1155TokenReceiver(to).onERC1155BatchReceived(msg.sender, address(0), ids, amounts, data) ==\\n                    ERC1155TokenReceiver.onERC1155BatchReceived.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    function _batchBurn(\\n        address from,\\n        uint256[] memory ids,\\n        uint256[] memory amounts\\n    ) internal virtual {\\n        uint256 idsLength = ids.length; // Saves MLOADs.\\n\\n        require(idsLength == amounts.length, \\\"LENGTH_MISMATCH\\\");\\n\\n        for (uint256 i = 0; i < idsLength; ) {\\n            balanceOf[from][ids[i]] -= amounts[i];\\n\\n            // An array can't have a total length\\n            // larger than the max uint256 value.\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        emit TransferBatch(msg.sender, from, address(0), ids, amounts);\\n    }\\n\\n    function _burn(\\n        address from,\\n        uint256 id,\\n        uint256 amount\\n    ) internal virtual {\\n        balanceOf[from][id] -= amount;\\n\\n        emit TransferSingle(msg.sender, from, address(0), id, amount);\\n    }\\n}\\n\\n/// @notice A generic interface for a contract which properly accepts ERC1155 tokens.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC1155.sol)\\nabstract contract ERC1155TokenReceiver {\\n    function onERC1155Received(\\n        address,\\n        address,\\n        uint256,\\n        uint256,\\n        bytes calldata\\n    ) external virtual returns (bytes4) {\\n        return ERC1155TokenReceiver.onERC1155Received.selector;\\n    }\\n\\n    function onERC1155BatchReceived(\\n        address,\\n        address,\\n        uint256[] calldata,\\n        uint256[] calldata,\\n        bytes calldata\\n    ) external virtual returns (bytes4) {\\n        return ERC1155TokenReceiver.onERC1155BatchReceived.selector;\\n    }\\n}\\n\",\"keccak256\":\"0x00502c7d7671d9dce495858572943999633ac298f20dbb70476280a93720d412\",\"license\":\"AGPL-3.0-only\"}},\"version\":1}",
  "bytecode": "0x60c060405234801561001057600080fd5b50604051620025693803806200256983398101604081905261003191610042565b6001600160a01b0316608052610072565b60006020828403121561005457600080fd5b81516001600160a01b038116811461006b57600080fd5b9392505050565b60805160a0516124cd6200009c60003960005050600081816105c1015261197b01526124cd6000f3fe6080604052600436106101b65760003560e01c8063bd85b039116100ec578063da23eb631161008a578063e985e9c511610064578063e985e9c514610554578063f242432a1461058f578063f2e01f28146105af578063fe313112146105e357600080fd5b8063da23eb63146104f6578063e07b098a14610511578063e0e1b2c01461052757600080fd5b8063cd9c7121116100c6578063cd9c712114610474578063cf35bdd014610494578063d6febde8146104c3578063d79875eb146104d657600080fd5b8063bd85b039146103e3578063c157253d14610410578063c411cbaa1461043057600080fd5b80635cf4ee91116101595780639477d85d116101335780639477d85d1461034b578063a22cb4651461036b578063b5dfd7351461038b578063b84992ce146103ab57600080fd5b80635cf4ee91146102ef5780636a8a69aa1461030f5780637ffb25ac1461032f57600080fd5b80630e89341c116101955780630e89341c146102535780632eb2c2d6146102805780634cc82215146102a25780634e1273f4146102c257600080fd5b8062fdd58e146101bb57806301ffc9a714610203578063063a741f14610233575b600080fd5b3480156101c757600080fd5b506101f06101d6366004611c1f565b600060208181529281526040808220909352908152205481565b6040519081526020015b60405180910390f35b34801561020f57600080fd5b5061022361021e366004611c61565b610610565b60405190151581526020016101fa565b34801561023f57600080fd5b506101f061024e366004611c7e565b610662565b34801561025f57600080fd5b5061027361026e366004611ca0565b6106ac565b6040516101fa9190611d09565b34801561028c57600080fd5b506102a061029b366004611daa565b610751565b005b3480156102ae57600080fd5b506102a06102bd366004611ca0565b6109f9565b3480156102ce57600080fd5b506102e26102dd366004611e69565b610b9a565b6040516101fa9190611ed5565b3480156102fb57600080fd5b506101f061030a366004611c7e565b610ccf565b34801561031b57600080fd5b506101f061032a366004611c1f565b610d28565b34801561033b57600080fd5b506101f0670de0b6b3a764000081565b34801561035757600080fd5b506101f0610366366004611c7e565b610d59565b34801561037757600080fd5b506102a0610386366004611f19565b610d7d565b34801561039757600080fd5b506102e26103a6366004611f57565b610de9565b3480156103b757600080fd5b506103cb6103c6366004611f74565b610e54565b6040516001600160a01b0390911681526020016101fa565b3480156103ef57600080fd5b506101f06103fe366004611ca0565b60066020526000908152604090205481565b34801561041c57600080fd5b506101f061042b366004611c7e565b610e6e565b34801561043c57600080fd5b5061022361044b366004611c1f565b6001600160a01b0391909116600090815260208181526040808320938352929052205460051090565b34801561048057600080fd5b506101f061048f366004611c7e565b610e87565b3480156104a057600080fd5b506104b46104af366004611ca0565b610ec8565b6040516101fa93929190611fb6565b6102a06104d1366004611c7e565b610f7c565b3480156104e257600080fd5b506102a06104f1366004611c7e565b6111a1565b34801561050257600080fd5b506101f066b1a2bc2ec5000081565b34801561051d57600080fd5b506101f060025481565b34801561053357600080fd5b506101f0610542366004611ca0565b60056020526000908152604090205481565b34801561056057600080fd5b5061022361056f366004611fe7565b600160209081526000928352604080842090915290825290205460ff1681565b34801561059b57600080fd5b506102a06105aa366004612015565b611499565b3480156105bb57600080fd5b506103cb7f000000000000000000000000000000000000000000000000000000000000000081565b3480156105ef57600080fd5b506101f06105fe366004611ca0565b60076020526000908152604090205481565b60006301ffc9a760e01b6001600160e01b0319831614806106415750636cdb3d1360e11b6001600160e01b03198316145b8061065c57506303a24d0760e21b6001600160e01b03198316145b92915050565b60008061066f8484610e6e565b90506000670de0b6b3a764000061068d66b1a2bc2ec50000846120a7565b61069791906120be565b90506106a381836120e0565b95945050505050565b60008181526003602052604090206001018054606091906106cc906120f3565b80601f01602080910402602001604051908101604052809291908181526020018280546106f8906120f3565b80156107455780601f1061071a57610100808354040283529160200191610745565b820191906000526020600020905b81548152906001019060200180831161072857829003601f168201915b50505050509050919050565b8483146107975760405162461bcd60e51b815260206004820152600f60248201526e0988a9c8ea890be9a92a69a82a8869608b1b60448201526064015b60405180910390fd5b336001600160a01b03891614806107d157506001600160a01b038816600090815260016020908152604080832033845290915290205460ff165b61080e5760405162461bcd60e51b815260206004820152600e60248201526d1393d517d055551213d49256915160921b604482015260640161078e565b60008060005b878110156108c95788888281811061082e5761082e61212d565b9050602002013592508686828181106108495761084961212d565b6001600160a01b038e1660009081526020818152604080832089845282528220805493909102949094013595508593925090610886908490612143565b90915550506001600160a01b038a16600090815260208181526040808320868452909152812080548492906108bc9084906120e0565b9091555050600101610814565b50886001600160a01b03168a6001600160a01b0316336001600160a01b03167f4a39dc06d4c0dbc64b70af90fd698a233a518aa5d07e595d983b8c0526c8f7fb8b8b8b8b60405161091d9493929190612188565b60405180910390a46001600160a01b0389163b156109c45760405163bc197c8160e01b808252906001600160a01b038b169063bc197c81906109719033908f908e908e908e908e908e908e906004016121e3565b6020604051808303816000875af1158015610990573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906109b49190612247565b6001600160e01b031916146109d1565b6001600160a01b03891615155b6109ed5760405162461bcd60e51b815260040161078e90612264565b50505050505050505050565b60006003600083815260200190815260200160002060405180606001604052908160008201548152602001600182018054610a33906120f3565b80601f0160208091040260200160405190810160405280929190818152602001828054610a5f906120f3565b8015610aac5780601f10610a8157610100808354040283529160200191610aac565b820191906000526020600020905b815481529060010190602001808311610a8f57829003601f168201915b5050509183525050600291909101546001600160a01b039081166020909201919091526040820151919250163314610af6576040516282b42960e81b815260040160405180910390fd5b600560008260200151604051602001610b0f919061228e565b60408051601f1981840301815291815281516020928301208352828201939093529082016000908120819055848152600390915290812081815590610b576001830182611bb4565b5060020180546001600160a01b0319169055604051339083907fe52b7042a48e37bfb277e8a210794950be40bfaedea374e2dfbe0c6edff8791d90600090a35050565b6060838214610bdd5760405162461bcd60e51b815260206004820152600f60248201526e0988a9c8ea890be9a92a69a82a8869608b1b604482015260640161078e565b8367ffffffffffffffff811115610bf657610bf66122aa565b604051908082528060200260200182016040528015610c1f578160200160208202803683370190505b50905060005b84811015610cc657600080878784818110610c4257610c4261212d565b9050602002016020810190610c579190611f57565b6001600160a01b03166001600160a01b031681526020019081526020016000206000858584818110610c8b57610c8b61212d565b90506020020135815260200190815260200160002054828281518110610cb357610cb361212d565b6020908102919091010152600101610c25565b50949350505050565b600061c350670de0b6b3a764000080610ce786611693565b610cf9610cf487896120e0565b611693565b610d039190612143565b610d0d91906120be565b610d1791906120be565b610d2191906120be565b9392505050565b60046020528160005260406000208181548110610d4457600080fd5b90600052602060002001600091509150505481565b600082815260066020526040812054610d2190610d77908490612143565b83610ccf565b3360008181526001602090815260408083206001600160a01b03871680855290835292819020805460ff191686151590811790915590519081529192917f17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31910160405180910390a35050565b6001600160a01b03811660009081526004602090815260409182902080548351818402810184019094528084526060939283018282801561074557602002820191906000526020600020905b815481526020019060010190808311610e355750505050509050919050565b600080610e6184846116fc565b905060006106a38261194c565b600082815260066020526040812054610d219083610ccf565b600080610e948484610d59565b90506000670de0b6b3a7640000610eb266b1a2bc2ec50000846120a7565b610ebc91906120be565b90506106a38183612143565b60036020526000908152604090208054600182018054919291610eea906120f3565b80601f0160208091040260200160405190810160405280929190818152602001828054610f16906120f3565b8015610f635780601f10610f3857610100808354040283529160200191610f63565b820191906000526020600020905b815481529060010190602001808311610f4657829003601f168201915b505050600290930154919250506001600160a01b031683565b6002548210610fc45760405162461bcd60e51b8152602060048201526014602482015273105cdcd95d08191bd95cc81b9bdd08195e1a5cdd60621b604482015260640161078e565b6000610fd08383610e6e565b90506000670de0b6b3a7640000610fee66b1a2bc2ec50000846120a7565b610ff891906120be565b905061100481836120e0565b34101561104a5760405162461bcd60e51b8152602060048201526014602482015273125b9cdd59999a58da595b9d081c185e5b595b9d60621b604482015260640161078e565b600084815260066020526040812080548592906110689084906120e0565b90915550506000848152600760205260408120805484929061108b9084906120e0565b925050819055506110ad338585604051806020016040528060008152506119e8565b3384600160408051878152602081018790529081018590527f4373618509eab3295fc837b6b78ce8f6fc820f403d4a22076932311ad1e4b51e9060600160405180910390a46000848152600360205260408082206002015490516001600160a01b039091169083908381818185875af1925050503d806000811461114d576040519150601f19603f3d011682016040523d82523d6000602084013e611152565b606091505b505090508061119a5760405162461bcd60e51b81526020600482015260146024820152732330b4b632b2103a379039b2b7321022ba3432b960611b604482015260640161078e565b5050505050565b60025482106111e95760405162461bcd60e51b8152602060048201526014602482015273105cdcd95d08191bd95cc81b9bdd08195e1a5cdd60621b604482015260640161078e565b336000908152602081815260408083208584529091529020548111156112485760405162461bcd60e51b8152602060048201526014602482015273496e73756666696369656e742062616c616e636560601b604482015260640161078e565b600082815260066020526040902054670de0b6b3a764000061126a8383612143565b10156112c85760405162461bcd60e51b815260206004820152602760248201527f537570706c79206e6f7420616c6c6f7765642062656c6f77207072656d696e7460448201526608185b5bdd5b9d60ca1b606482015260840161078e565b60006112d48484610d59565b90506000670de0b6b3a76400006112f266b1a2bc2ec50000846120a7565b6112fc91906120be565b9050611309338686611b30565b6113138484612143565b60008681526006602090815260408083209390935560079052908120805484929061133f908490612143565b9091555033905085600260408051888152602081018790529081018590527f4373618509eab3295fc837b6b78ce8f6fc820f403d4a22076932311ad1e4b51e9060600160405180910390a46000336113978385612143565b604051600081818185875af1925050503d80600081146113d3576040519150601f19603f3d011682016040523d82523d6000602084013e6113d8565b606091505b505060008781526003602052604080822060020154905192935090916001600160a01b039091169084908381818185875af1925050503d806000811461143a576040519150601f19603f3d011682016040523d82523d6000602084013e61143f565b606091505b5050905081801561144d5750805b6114905760405162461bcd60e51b81526020600482015260146024820152732330b4b632b2103a379039b2b7321022ba3432b960611b604482015260640161078e565b50505050505050565b336001600160a01b03871614806114d357506001600160a01b038616600090815260016020908152604080832033845290915290205460ff165b6115105760405162461bcd60e51b815260206004820152600e60248201526d1393d517d055551213d49256915160921b604482015260640161078e565b6001600160a01b03861660009081526020818152604080832087845290915281208054859290611541908490612143565b90915550506001600160a01b038516600090815260208181526040808320878452909152812080548592906115779084906120e0565b909155505060408051858152602081018590526001600160a01b03808816929089169133917fc3d58168c5ae7397731d063d5bbf3d657854427343f4c083240f7aacaa2d0f62910160405180910390a46001600160a01b0385163b156116625760405163f23a6e6160e01b808252906001600160a01b0387169063f23a6e619061160f9033908b908a908a908a908a906004016122c0565b6020604051808303816000875af115801561162e573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906116529190612247565b6001600160e01b0319161461166f565b6001600160a01b03851615155b61168b5760405162461bcd60e51b815260040161078e90612264565b505050505050565b6000670de0b6b3a76400008211156116f4576116b7670de0b6b3a764000083612143565b6116c9670de0b6b3a764000084612143565b6116db670de0b6b3a764000085612143565b6116e591906120a7565b6116ef91906120a7565b61065c565b600092915050565b6000808383604051602001611712929190612307565b60408051601f198184030181529181528151602092830120600081815260059093529120549091501561177e5760405162461bcd60e51b8152602060048201526014602482015273417373657420616c72656164792065786973747360601b604482015260640161078e565b60006002549050604051806060016040528082815260200186868080601f0160208091040260200160405190810160405280939291908181526020018383808284376000920182905250938552505033602093840152508381526003825260409020825181559082015160018201906117f79082612364565b5060409182015160029190910180546001600160a01b0319166001600160a01b039092169190911790553360009081526004602090815282822080546001810182559083528183200184905584825260058152828220849055838252600690529081208054670de0b6b3a764000092906118729084906120e0565b9091555061188390508160016120e0565b6002819055506118ac3382670de0b6b3a7640000604051806020016040528060008152506119e8565b336001600160a01b0316817fb683691564ab594b1f9e9db91abaf085736871256a4741baa41bf30cb9d4f23687876040516118e8929190612424565b60405180910390a33381600060408051670de0b6b3a76400008152600060208201819052918101919091527f4373618509eab3295fc837b6b78ce8f6fc820f403d4a22076932311ad1e4b51e9060600160405180910390a450506002549392505050565b604051633f2891eb60e21b81524660048201523060248201526044810182905260009081906001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000169063fca247ac906064016020604051808303816000875af11580156119c4573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610d219190612440565b6001600160a01b03841660009081526020818152604080832086845290915281208054849290611a199084906120e0565b909155505060408051848152602081018490526001600160a01b0386169160009133917fc3d58168c5ae7397731d063d5bbf3d657854427343f4c083240f7aacaa2d0f62910160405180910390a46001600160a01b0384163b15611b015760405163f23a6e6160e01b808252906001600160a01b0386169063f23a6e6190611aae90339060009089908990899060040161245d565b6020604051808303816000875af1158015611acd573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611af19190612247565b6001600160e01b03191614611b0e565b6001600160a01b03841615155b611b2a5760405162461bcd60e51b815260040161078e90612264565b50505050565b6001600160a01b03831660009081526020818152604080832085845290915281208054839290611b61908490612143565b909155505060408051838152602081018390526000916001600160a01b0386169133917fc3d58168c5ae7397731d063d5bbf3d657854427343f4c083240f7aacaa2d0f62910160405180910390a4505050565b508054611bc0906120f3565b6000825580601f10611bd0575050565b601f016020900490600052602060002090810190611bee9190611bf1565b50565b5b80821115611c065760008155600101611bf2565b5090565b6001600160a01b0381168114611bee57600080fd5b60008060408385031215611c3257600080fd5b8235611c3d81611c0a565b946020939093013593505050565b6001600160e01b031981168114611bee57600080fd5b600060208284031215611c7357600080fd5b8135610d2181611c4b565b60008060408385031215611c9157600080fd5b50508035926020909101359150565b600060208284031215611cb257600080fd5b5035919050565b60005b83811015611cd4578181015183820152602001611cbc565b50506000910152565b60008151808452611cf5816020860160208601611cb9565b601f01601f19169290920160200192915050565b602081526000610d216020830184611cdd565b60008083601f840112611d2e57600080fd5b50813567ffffffffffffffff811115611d4657600080fd5b6020830191508360208260051b8501011115611d6157600080fd5b9250929050565b60008083601f840112611d7a57600080fd5b50813567ffffffffffffffff811115611d9257600080fd5b602083019150836020828501011115611d6157600080fd5b60008060008060008060008060a0898b031215611dc657600080fd5b8835611dd181611c0a565b97506020890135611de181611c0a565b9650604089013567ffffffffffffffff80821115611dfe57600080fd5b611e0a8c838d01611d1c565b909850965060608b0135915080821115611e2357600080fd5b611e2f8c838d01611d1c565b909650945060808b0135915080821115611e4857600080fd5b50611e558b828c01611d68565b999c989b5096995094979396929594505050565b60008060008060408587031215611e7f57600080fd5b843567ffffffffffffffff80821115611e9757600080fd5b611ea388838901611d1c565b90965094506020870135915080821115611ebc57600080fd5b50611ec987828801611d1c565b95989497509550505050565b6020808252825182820181905260009190848201906040850190845b81811015611f0d57835183529284019291840191600101611ef1565b50909695505050505050565b60008060408385031215611f2c57600080fd5b8235611f3781611c0a565b915060208301358015158114611f4c57600080fd5b809150509250929050565b600060208284031215611f6957600080fd5b8135610d2181611c0a565b60008060208385031215611f8757600080fd5b823567ffffffffffffffff811115611f9e57600080fd5b611faa85828601611d68565b90969095509350505050565b838152606060208201526000611fcf6060830185611cdd565b905060018060a01b0383166040830152949350505050565b60008060408385031215611ffa57600080fd5b823561200581611c0a565b91506020830135611f4c81611c0a565b60008060008060008060a0878903121561202e57600080fd5b863561203981611c0a565b9550602087013561204981611c0a565b94506040870135935060608701359250608087013567ffffffffffffffff81111561207357600080fd5b61207f89828a01611d68565b979a9699509497509295939492505050565b634e487b7160e01b600052601160045260246000fd5b808202811582820484141761065c5761065c612091565b6000826120db57634e487b7160e01b600052601260045260246000fd5b500490565b8082018082111561065c5761065c612091565b600181811c9082168061210757607f821691505b60208210810361212757634e487b7160e01b600052602260045260246000fd5b50919050565b634e487b7160e01b600052603260045260246000fd5b8181038181111561065c5761065c612091565b81835260006001600160fb1b0383111561216f57600080fd5b8260051b80836020870137939093016020019392505050565b60408152600061219c604083018688612156565b82810360208401526121af818587612156565b979650505050505050565b81835281816020850137506000828201602090810191909152601f909101601f19169091010190565b6001600160a01b0389811682528816602082015260a060408201819052600090612210908301888a612156565b8281036060840152612223818789612156565b905082810360808401526122388185876121ba565b9b9a5050505050505050505050565b60006020828403121561225957600080fd5b8151610d2181611c4b565b60208082526010908201526f155394d0519157d49150d2541251539560821b604082015260600190565b600082516122a0818460208701611cb9565b9190910192915050565b634e487b7160e01b600052604160045260246000fd5b6001600160a01b03878116825286166020820152604081018590526060810184905260a0608082018190526000906122fb90830184866121ba565b98975050505050505050565b8183823760009101908152919050565b601f82111561235f576000816000526020600020601f850160051c810160208610156123405750805b601f850160051c820191505b8181101561168b5782815560010161234c565b505050565b815167ffffffffffffffff81111561237e5761237e6122aa565b6123928161238c84546120f3565b84612317565b602080601f8311600181146123c757600084156123af5750858301515b600019600386901b1c1916600185901b17855561168b565b600085815260208120601f198616915b828110156123f6578886015182559484019460019091019084016123d7565b50858210156124145787850151600019600388901b60f8161c191681555b5050505050600190811b01905550565b6020815260006124386020830184866121ba565b949350505050565b60006020828403121561245257600080fd5b8151610d2181611c0a565b6001600160a01b03868116825285166020820152604081018490526060810183905260a0608082018190526000906121af90830184611cdd56fea264697066735822122063303a96a320705dd6f324b96dad608f00e269a503628407debfcc0a05acd1bd64736f6c63430008170033",
  "deployedBytecode": "0x6080604052600436106101b65760003560e01c8063bd85b039116100ec578063da23eb631161008a578063e985e9c511610064578063e985e9c514610554578063f242432a1461058f578063f2e01f28146105af578063fe313112146105e357600080fd5b8063da23eb63146104f6578063e07b098a14610511578063e0e1b2c01461052757600080fd5b8063cd9c7121116100c6578063cd9c712114610474578063cf35bdd014610494578063d6febde8146104c3578063d79875eb146104d657600080fd5b8063bd85b039146103e3578063c157253d14610410578063c411cbaa1461043057600080fd5b80635cf4ee91116101595780639477d85d116101335780639477d85d1461034b578063a22cb4651461036b578063b5dfd7351461038b578063b84992ce146103ab57600080fd5b80635cf4ee91146102ef5780636a8a69aa1461030f5780637ffb25ac1461032f57600080fd5b80630e89341c116101955780630e89341c146102535780632eb2c2d6146102805780634cc82215146102a25780634e1273f4146102c257600080fd5b8062fdd58e146101bb57806301ffc9a714610203578063063a741f14610233575b600080fd5b3480156101c757600080fd5b506101f06101d6366004611c1f565b600060208181529281526040808220909352908152205481565b6040519081526020015b60405180910390f35b34801561020f57600080fd5b5061022361021e366004611c61565b610610565b60405190151581526020016101fa565b34801561023f57600080fd5b506101f061024e366004611c7e565b610662565b34801561025f57600080fd5b5061027361026e366004611ca0565b6106ac565b6040516101fa9190611d09565b34801561028c57600080fd5b506102a061029b366004611daa565b610751565b005b3480156102ae57600080fd5b506102a06102bd366004611ca0565b6109f9565b3480156102ce57600080fd5b506102e26102dd366004611e69565b610b9a565b6040516101fa9190611ed5565b3480156102fb57600080fd5b506101f061030a366004611c7e565b610ccf565b34801561031b57600080fd5b506101f061032a366004611c1f565b610d28565b34801561033b57600080fd5b506101f0670de0b6b3a764000081565b34801561035757600080fd5b506101f0610366366004611c7e565b610d59565b34801561037757600080fd5b506102a0610386366004611f19565b610d7d565b34801561039757600080fd5b506102e26103a6366004611f57565b610de9565b3480156103b757600080fd5b506103cb6103c6366004611f74565b610e54565b6040516001600160a01b0390911681526020016101fa565b3480156103ef57600080fd5b506101f06103fe366004611ca0565b60066020526000908152604090205481565b34801561041c57600080fd5b506101f061042b366004611c7e565b610e6e565b34801561043c57600080fd5b5061022361044b366004611c1f565b6001600160a01b0391909116600090815260208181526040808320938352929052205460051090565b34801561048057600080fd5b506101f061048f366004611c7e565b610e87565b3480156104a057600080fd5b506104b46104af366004611ca0565b610ec8565b6040516101fa93929190611fb6565b6102a06104d1366004611c7e565b610f7c565b3480156104e257600080fd5b506102a06104f1366004611c7e565b6111a1565b34801561050257600080fd5b506101f066b1a2bc2ec5000081565b34801561051d57600080fd5b506101f060025481565b34801561053357600080fd5b506101f0610542366004611ca0565b60056020526000908152604090205481565b34801561056057600080fd5b5061022361056f366004611fe7565b600160209081526000928352604080842090915290825290205460ff1681565b34801561059b57600080fd5b506102a06105aa366004612015565b611499565b3480156105bb57600080fd5b506103cb7f000000000000000000000000000000000000000000000000000000000000000081565b3480156105ef57600080fd5b506101f06105fe366004611ca0565b60076020526000908152604090205481565b60006301ffc9a760e01b6001600160e01b0319831614806106415750636cdb3d1360e11b6001600160e01b03198316145b8061065c57506303a24d0760e21b6001600160e01b03198316145b92915050565b60008061066f8484610e6e565b90506000670de0b6b3a764000061068d66b1a2bc2ec50000846120a7565b61069791906120be565b90506106a381836120e0565b95945050505050565b60008181526003602052604090206001018054606091906106cc906120f3565b80601f01602080910402602001604051908101604052809291908181526020018280546106f8906120f3565b80156107455780601f1061071a57610100808354040283529160200191610745565b820191906000526020600020905b81548152906001019060200180831161072857829003601f168201915b50505050509050919050565b8483146107975760405162461bcd60e51b815260206004820152600f60248201526e0988a9c8ea890be9a92a69a82a8869608b1b60448201526064015b60405180910390fd5b336001600160a01b03891614806107d157506001600160a01b038816600090815260016020908152604080832033845290915290205460ff165b61080e5760405162461bcd60e51b815260206004820152600e60248201526d1393d517d055551213d49256915160921b604482015260640161078e565b60008060005b878110156108c95788888281811061082e5761082e61212d565b9050602002013592508686828181106108495761084961212d565b6001600160a01b038e1660009081526020818152604080832089845282528220805493909102949094013595508593925090610886908490612143565b90915550506001600160a01b038a16600090815260208181526040808320868452909152812080548492906108bc9084906120e0565b9091555050600101610814565b50886001600160a01b03168a6001600160a01b0316336001600160a01b03167f4a39dc06d4c0dbc64b70af90fd698a233a518aa5d07e595d983b8c0526c8f7fb8b8b8b8b60405161091d9493929190612188565b60405180910390a46001600160a01b0389163b156109c45760405163bc197c8160e01b808252906001600160a01b038b169063bc197c81906109719033908f908e908e908e908e908e908e906004016121e3565b6020604051808303816000875af1158015610990573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906109b49190612247565b6001600160e01b031916146109d1565b6001600160a01b03891615155b6109ed5760405162461bcd60e51b815260040161078e90612264565b50505050505050505050565b60006003600083815260200190815260200160002060405180606001604052908160008201548152602001600182018054610a33906120f3565b80601f0160208091040260200160405190810160405280929190818152602001828054610a5f906120f3565b8015610aac5780601f10610a8157610100808354040283529160200191610aac565b820191906000526020600020905b815481529060010190602001808311610a8f57829003601f168201915b5050509183525050600291909101546001600160a01b039081166020909201919091526040820151919250163314610af6576040516282b42960e81b815260040160405180910390fd5b600560008260200151604051602001610b0f919061228e565b60408051601f1981840301815291815281516020928301208352828201939093529082016000908120819055848152600390915290812081815590610b576001830182611bb4565b5060020180546001600160a01b0319169055604051339083907fe52b7042a48e37bfb277e8a210794950be40bfaedea374e2dfbe0c6edff8791d90600090a35050565b6060838214610bdd5760405162461bcd60e51b815260206004820152600f60248201526e0988a9c8ea890be9a92a69a82a8869608b1b604482015260640161078e565b8367ffffffffffffffff811115610bf657610bf66122aa565b604051908082528060200260200182016040528015610c1f578160200160208202803683370190505b50905060005b84811015610cc657600080878784818110610c4257610c4261212d565b9050602002016020810190610c579190611f57565b6001600160a01b03166001600160a01b031681526020019081526020016000206000858584818110610c8b57610c8b61212d565b90506020020135815260200190815260200160002054828281518110610cb357610cb361212d565b6020908102919091010152600101610c25565b50949350505050565b600061c350670de0b6b3a764000080610ce786611693565b610cf9610cf487896120e0565b611693565b610d039190612143565b610d0d91906120be565b610d1791906120be565b610d2191906120be565b9392505050565b60046020528160005260406000208181548110610d4457600080fd5b90600052602060002001600091509150505481565b600082815260066020526040812054610d2190610d77908490612143565b83610ccf565b3360008181526001602090815260408083206001600160a01b03871680855290835292819020805460ff191686151590811790915590519081529192917f17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31910160405180910390a35050565b6001600160a01b03811660009081526004602090815260409182902080548351818402810184019094528084526060939283018282801561074557602002820191906000526020600020905b815481526020019060010190808311610e355750505050509050919050565b600080610e6184846116fc565b905060006106a38261194c565b600082815260066020526040812054610d219083610ccf565b600080610e948484610d59565b90506000670de0b6b3a7640000610eb266b1a2bc2ec50000846120a7565b610ebc91906120be565b90506106a38183612143565b60036020526000908152604090208054600182018054919291610eea906120f3565b80601f0160208091040260200160405190810160405280929190818152602001828054610f16906120f3565b8015610f635780601f10610f3857610100808354040283529160200191610f63565b820191906000526020600020905b815481529060010190602001808311610f4657829003601f168201915b505050600290930154919250506001600160a01b031683565b6002548210610fc45760405162461bcd60e51b8152602060048201526014602482015273105cdcd95d08191bd95cc81b9bdd08195e1a5cdd60621b604482015260640161078e565b6000610fd08383610e6e565b90506000670de0b6b3a7640000610fee66b1a2bc2ec50000846120a7565b610ff891906120be565b905061100481836120e0565b34101561104a5760405162461bcd60e51b8152602060048201526014602482015273125b9cdd59999a58da595b9d081c185e5b595b9d60621b604482015260640161078e565b600084815260066020526040812080548592906110689084906120e0565b90915550506000848152600760205260408120805484929061108b9084906120e0565b925050819055506110ad338585604051806020016040528060008152506119e8565b3384600160408051878152602081018790529081018590527f4373618509eab3295fc837b6b78ce8f6fc820f403d4a22076932311ad1e4b51e9060600160405180910390a46000848152600360205260408082206002015490516001600160a01b039091169083908381818185875af1925050503d806000811461114d576040519150601f19603f3d011682016040523d82523d6000602084013e611152565b606091505b505090508061119a5760405162461bcd60e51b81526020600482015260146024820152732330b4b632b2103a379039b2b7321022ba3432b960611b604482015260640161078e565b5050505050565b60025482106111e95760405162461bcd60e51b8152602060048201526014602482015273105cdcd95d08191bd95cc81b9bdd08195e1a5cdd60621b604482015260640161078e565b336000908152602081815260408083208584529091529020548111156112485760405162461bcd60e51b8152602060048201526014602482015273496e73756666696369656e742062616c616e636560601b604482015260640161078e565b600082815260066020526040902054670de0b6b3a764000061126a8383612143565b10156112c85760405162461bcd60e51b815260206004820152602760248201527f537570706c79206e6f7420616c6c6f7765642062656c6f77207072656d696e7460448201526608185b5bdd5b9d60ca1b606482015260840161078e565b60006112d48484610d59565b90506000670de0b6b3a76400006112f266b1a2bc2ec50000846120a7565b6112fc91906120be565b9050611309338686611b30565b6113138484612143565b60008681526006602090815260408083209390935560079052908120805484929061133f908490612143565b9091555033905085600260408051888152602081018790529081018590527f4373618509eab3295fc837b6b78ce8f6fc820f403d4a22076932311ad1e4b51e9060600160405180910390a46000336113978385612143565b604051600081818185875af1925050503d80600081146113d3576040519150601f19603f3d011682016040523d82523d6000602084013e6113d8565b606091505b505060008781526003602052604080822060020154905192935090916001600160a01b039091169084908381818185875af1925050503d806000811461143a576040519150601f19603f3d011682016040523d82523d6000602084013e61143f565b606091505b5050905081801561144d5750805b6114905760405162461bcd60e51b81526020600482015260146024820152732330b4b632b2103a379039b2b7321022ba3432b960611b604482015260640161078e565b50505050505050565b336001600160a01b03871614806114d357506001600160a01b038616600090815260016020908152604080832033845290915290205460ff165b6115105760405162461bcd60e51b815260206004820152600e60248201526d1393d517d055551213d49256915160921b604482015260640161078e565b6001600160a01b03861660009081526020818152604080832087845290915281208054859290611541908490612143565b90915550506001600160a01b038516600090815260208181526040808320878452909152812080548592906115779084906120e0565b909155505060408051858152602081018590526001600160a01b03808816929089169133917fc3d58168c5ae7397731d063d5bbf3d657854427343f4c083240f7aacaa2d0f62910160405180910390a46001600160a01b0385163b156116625760405163f23a6e6160e01b808252906001600160a01b0387169063f23a6e619061160f9033908b908a908a908a908a906004016122c0565b6020604051808303816000875af115801561162e573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906116529190612247565b6001600160e01b0319161461166f565b6001600160a01b03851615155b61168b5760405162461bcd60e51b815260040161078e90612264565b505050505050565b6000670de0b6b3a76400008211156116f4576116b7670de0b6b3a764000083612143565b6116c9670de0b6b3a764000084612143565b6116db670de0b6b3a764000085612143565b6116e591906120a7565b6116ef91906120a7565b61065c565b600092915050565b6000808383604051602001611712929190612307565b60408051601f198184030181529181528151602092830120600081815260059093529120549091501561177e5760405162461bcd60e51b8152602060048201526014602482015273417373657420616c72656164792065786973747360601b604482015260640161078e565b60006002549050604051806060016040528082815260200186868080601f0160208091040260200160405190810160405280939291908181526020018383808284376000920182905250938552505033602093840152508381526003825260409020825181559082015160018201906117f79082612364565b5060409182015160029190910180546001600160a01b0319166001600160a01b039092169190911790553360009081526004602090815282822080546001810182559083528183200184905584825260058152828220849055838252600690529081208054670de0b6b3a764000092906118729084906120e0565b9091555061188390508160016120e0565b6002819055506118ac3382670de0b6b3a7640000604051806020016040528060008152506119e8565b336001600160a01b0316817fb683691564ab594b1f9e9db91abaf085736871256a4741baa41bf30cb9d4f23687876040516118e8929190612424565b60405180910390a33381600060408051670de0b6b3a76400008152600060208201819052918101919091527f4373618509eab3295fc837b6b78ce8f6fc820f403d4a22076932311ad1e4b51e9060600160405180910390a450506002549392505050565b604051633f2891eb60e21b81524660048201523060248201526044810182905260009081906001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000169063fca247ac906064016020604051808303816000875af11580156119c4573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610d219190612440565b6001600160a01b03841660009081526020818152604080832086845290915281208054849290611a199084906120e0565b909155505060408051848152602081018490526001600160a01b0386169160009133917fc3d58168c5ae7397731d063d5bbf3d657854427343f4c083240f7aacaa2d0f62910160405180910390a46001600160a01b0384163b15611b015760405163f23a6e6160e01b808252906001600160a01b0386169063f23a6e6190611aae90339060009089908990899060040161245d565b6020604051808303816000875af1158015611acd573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611af19190612247565b6001600160e01b03191614611b0e565b6001600160a01b03841615155b611b2a5760405162461bcd60e51b815260040161078e90612264565b50505050565b6001600160a01b03831660009081526020818152604080832085845290915281208054839290611b61908490612143565b909155505060408051838152602081018390526000916001600160a01b0386169133917fc3d58168c5ae7397731d063d5bbf3d657854427343f4c083240f7aacaa2d0f62910160405180910390a4505050565b508054611bc0906120f3565b6000825580601f10611bd0575050565b601f016020900490600052602060002090810190611bee9190611bf1565b50565b5b80821115611c065760008155600101611bf2565b5090565b6001600160a01b0381168114611bee57600080fd5b60008060408385031215611c3257600080fd5b8235611c3d81611c0a565b946020939093013593505050565b6001600160e01b031981168114611bee57600080fd5b600060208284031215611c7357600080fd5b8135610d2181611c4b565b60008060408385031215611c9157600080fd5b50508035926020909101359150565b600060208284031215611cb257600080fd5b5035919050565b60005b83811015611cd4578181015183820152602001611cbc565b50506000910152565b60008151808452611cf5816020860160208601611cb9565b601f01601f19169290920160200192915050565b602081526000610d216020830184611cdd565b60008083601f840112611d2e57600080fd5b50813567ffffffffffffffff811115611d4657600080fd5b6020830191508360208260051b8501011115611d6157600080fd5b9250929050565b60008083601f840112611d7a57600080fd5b50813567ffffffffffffffff811115611d9257600080fd5b602083019150836020828501011115611d6157600080fd5b60008060008060008060008060a0898b031215611dc657600080fd5b8835611dd181611c0a565b97506020890135611de181611c0a565b9650604089013567ffffffffffffffff80821115611dfe57600080fd5b611e0a8c838d01611d1c565b909850965060608b0135915080821115611e2357600080fd5b611e2f8c838d01611d1c565b909650945060808b0135915080821115611e4857600080fd5b50611e558b828c01611d68565b999c989b5096995094979396929594505050565b60008060008060408587031215611e7f57600080fd5b843567ffffffffffffffff80821115611e9757600080fd5b611ea388838901611d1c565b90965094506020870135915080821115611ebc57600080fd5b50611ec987828801611d1c565b95989497509550505050565b6020808252825182820181905260009190848201906040850190845b81811015611f0d57835183529284019291840191600101611ef1565b50909695505050505050565b60008060408385031215611f2c57600080fd5b8235611f3781611c0a565b915060208301358015158114611f4c57600080fd5b809150509250929050565b600060208284031215611f6957600080fd5b8135610d2181611c0a565b60008060208385031215611f8757600080fd5b823567ffffffffffffffff811115611f9e57600080fd5b611faa85828601611d68565b90969095509350505050565b838152606060208201526000611fcf6060830185611cdd565b905060018060a01b0383166040830152949350505050565b60008060408385031215611ffa57600080fd5b823561200581611c0a565b91506020830135611f4c81611c0a565b60008060008060008060a0878903121561202e57600080fd5b863561203981611c0a565b9550602087013561204981611c0a565b94506040870135935060608701359250608087013567ffffffffffffffff81111561207357600080fd5b61207f89828a01611d68565b979a9699509497509295939492505050565b634e487b7160e01b600052601160045260246000fd5b808202811582820484141761065c5761065c612091565b6000826120db57634e487b7160e01b600052601260045260246000fd5b500490565b8082018082111561065c5761065c612091565b600181811c9082168061210757607f821691505b60208210810361212757634e487b7160e01b600052602260045260246000fd5b50919050565b634e487b7160e01b600052603260045260246000fd5b8181038181111561065c5761065c612091565b81835260006001600160fb1b0383111561216f57600080fd5b8260051b80836020870137939093016020019392505050565b60408152600061219c604083018688612156565b82810360208401526121af818587612156565b979650505050505050565b81835281816020850137506000828201602090810191909152601f909101601f19169091010190565b6001600160a01b0389811682528816602082015260a060408201819052600090612210908301888a612156565b8281036060840152612223818789612156565b905082810360808401526122388185876121ba565b9b9a5050505050505050505050565b60006020828403121561225957600080fd5b8151610d2181611c4b565b60208082526010908201526f155394d0519157d49150d2541251539560821b604082015260600190565b600082516122a0818460208701611cb9565b9190910192915050565b634e487b7160e01b600052604160045260246000fd5b6001600160a01b03878116825286166020820152604081018590526060810184905260a0608082018190526000906122fb90830184866121ba565b98975050505050505050565b8183823760009101908152919050565b601f82111561235f576000816000526020600020601f850160051c810160208610156123405750805b601f850160051c820191505b8181101561168b5782815560010161234c565b505050565b815167ffffffffffffffff81111561237e5761237e6122aa565b6123928161238c84546120f3565b84612317565b602080601f8311600181146123c757600084156123af5750858301515b600019600386901b1c1916600185901b17855561168b565b600085815260208120601f198616915b828110156123f6578886015182559484019460019091019084016123d7565b50858210156124145787850151600019600388901b60f8161c191681555b5050505050600190811b01905550565b6020815260006124386020830184866121ba565b949350505050565b60006020828403121561245257600080fd5b8151610d2181611c0a565b6001600160a01b03868116825285166020820152604081018490526060810183905260a0608082018190526000906121af90830184611cdd56fea264697066735822122063303a96a320705dd6f324b96dad608f00e269a503628407debfcc0a05acd1bd64736f6c63430008170033",
  "devdoc": {
    "kind": "dev",
    "methods": {},
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 26754,
        "contract": "contracts/shares/bodhi.sol:Bodhi",
        "label": "balanceOf",
        "offset": 0,
        "slot": "0",
        "type": "t_mapping(t_address,t_mapping(t_uint256,t_uint256))"
      },
      {
        "astId": 26760,
        "contract": "contracts/shares/bodhi.sol:Bodhi",
        "label": "isApprovedForAll",
        "offset": 0,
        "slot": "1",
        "type": "t_mapping(t_address,t_mapping(t_address,t_bool))"
      },
      {
        "astId": 17737,
        "contract": "contracts/shares/bodhi.sol:Bodhi",
        "label": "assetIndex",
        "offset": 0,
        "slot": "2",
        "type": "t_uint256"
      },
      {
        "astId": 17744,
        "contract": "contracts/shares/bodhi.sol:Bodhi",
        "label": "assets",
        "offset": 0,
        "slot": "3",
        "type": "t_mapping(t_uint256,t_struct(Asset)17732_storage)"
      },
      {
        "astId": 17749,
        "contract": "contracts/shares/bodhi.sol:Bodhi",
        "label": "userAssets",
        "offset": 0,
        "slot": "4",
        "type": "t_mapping(t_address,t_array(t_uint256)dyn_storage)"
      },
      {
        "astId": 17753,
        "contract": "contracts/shares/bodhi.sol:Bodhi",
        "label": "txToAssetId",
        "offset": 0,
        "slot": "5",
        "type": "t_mapping(t_bytes32,t_uint256)"
      },
      {
        "astId": 17757,
        "contract": "contracts/shares/bodhi.sol:Bodhi",
        "label": "totalSupply",
        "offset": 0,
        "slot": "6",
        "type": "t_mapping(t_uint256,t_uint256)"
      },
      {
        "astId": 17761,
        "contract": "contracts/shares/bodhi.sol:Bodhi",
        "label": "pool",
        "offset": 0,
        "slot": "7",
        "type": "t_mapping(t_uint256,t_uint256)"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_array(t_uint256)dyn_storage": {
        "base": "t_uint256",
        "encoding": "dynamic_array",
        "label": "uint256[]",
        "numberOfBytes": "32"
      },
      "t_bool": {
        "encoding": "inplace",
        "label": "bool",
        "numberOfBytes": "1"
      },
      "t_bytes32": {
        "encoding": "inplace",
        "label": "bytes32",
        "numberOfBytes": "32"
      },
      "t_mapping(t_address,t_array(t_uint256)dyn_storage)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => uint256[])",
        "numberOfBytes": "32",
        "value": "t_array(t_uint256)dyn_storage"
      },
      "t_mapping(t_address,t_bool)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => bool)",
        "numberOfBytes": "32",
        "value": "t_bool"
      },
      "t_mapping(t_address,t_mapping(t_address,t_bool))": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => mapping(address => bool))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_address,t_bool)"
      },
      "t_mapping(t_address,t_mapping(t_uint256,t_uint256))": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => mapping(uint256 => uint256))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_uint256,t_uint256)"
      },
      "t_mapping(t_bytes32,t_uint256)": {
        "encoding": "mapping",
        "key": "t_bytes32",
        "label": "mapping(bytes32 => uint256)",
        "numberOfBytes": "32",
        "value": "t_uint256"
      },
      "t_mapping(t_uint256,t_struct(Asset)17732_storage)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => struct Bodhi.Asset)",
        "numberOfBytes": "32",
        "value": "t_struct(Asset)17732_storage"
      },
      "t_mapping(t_uint256,t_uint256)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => uint256)",
        "numberOfBytes": "32",
        "value": "t_uint256"
      },
      "t_string_storage": {
        "encoding": "bytes",
        "label": "string",
        "numberOfBytes": "32"
      },
      "t_struct(Asset)17732_storage": {
        "encoding": "inplace",
        "label": "struct Bodhi.Asset",
        "members": [
          {
            "astId": 17727,
            "contract": "contracts/shares/bodhi.sol:Bodhi",
            "label": "id",
            "offset": 0,
            "slot": "0",
            "type": "t_uint256"
          },
          {
            "astId": 17729,
            "contract": "contracts/shares/bodhi.sol:Bodhi",
            "label": "arTxId",
            "offset": 0,
            "slot": "1",
            "type": "t_string_storage"
          },
          {
            "astId": 17731,
            "contract": "contracts/shares/bodhi.sol:Bodhi",
            "label": "creator",
            "offset": 0,
            "slot": "2",
            "type": "t_address"
          }
        ],
        "numberOfBytes": "96"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      }
    }
  }
}